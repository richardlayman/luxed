#!/bin/python

###########################################################################
# Filename: luxed 
#
# Description: Editor for LuxRender.
#
# Copyright (C) 2016 Richard Layman, rlayman2000@yahoo.com 
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###########################################################################

import time
import sys
from array import *
sys.path.append("./lib")
from types import *

import pyluxcore

from PyQt5.QtCore import pyqtSignal, Qt, QRect, QThread, QTimer
from PyQt5.QtWidgets import QMainWindow, QAbstractScrollArea, QScrollArea, QSlider, QMenuBar, QMenu, QAction, QDialog, QGroupBox, QStackedWidget, QStackedLayout, QGridLayout, QComboBox, QListWidget, QTabWidget, QLineEdit, QStatusBar, QFrame, QWidget, QPushButton, QLabel, QHBoxLayout, QVBoxLayout, QDockWidget, QFileDialog, QColorDialog, QApplication
from PyQt5.QtGui import QImage, QPalette, QIcon, QPainter, QFont, QColor, QPen, QIntValidator, QDoubleValidator


# PROPERTIES CONTAINERS

# SHAPES 
ShapesType = ['mesh']
# MATERIALS
MaterialsType = ['matte','roughmatte','glossy2','archglass','glass','roughglass','metal2','velvet','carpaint','mattetranslucent','mirror','mix','null']
# TEXTURES
TexturesType = ['imagemap','marble','mix','scale','uv','hitpointalpha','hitpointcolor','hitpointgrey','hsv','windy','wood']
TexturesWoodType = ['bands','rings','bandnoise','ringnoise']
TexturesWoodNoiseBasis2 = ['sin','saw','tri']
TexturesWoodNoiseType = ['soft_noise','hard_noise']
TexturesMappingType = ['uvmapping2d','uvmapping3d','globalmapping3d']
# VOLUMES
VolumesType = ['clear','homogeneous','heterogeneous']

class Property:
    
    def __init__(self, ntype, nname, vname, vtype, luxprop, vmin, vmax, vdefault, desc="", types=[], enabled=1):
        self.ntype = ntype
        self.nname = nname
        self.vname = vname
        # file, option and link are all types not in lux but created to make it easier on luxed - they are all 'strings' in lux
        self.vtype = vtype # bool, int, u_int, float, double, u_longlong, string, file, option, link, texture, uv, vector, normal, point, matrix4x4, spectrum
        self.value = vdefault
        self.default = vdefault 
        self.min = vmin 
        self.max = vmax 
        self.enabled = enabled
        self.desc = desc
        self.types = types
        self.luxprop = luxprop
        self.props = [] # children properties
        if len(types) > 0:
            self.initProperties() # fill in the child properties
 
    def setValue(self, val):
        self.value = val

    def getValue(self):
        return self.value
    
    def addProperty(self,prop):
        self.props.append(prop)

    def clearChildren(self):
        for prop in self.props:
            prop.clearChildren()
            del(prop)
        self.props = []

    def count(self):
        return len(self.props)

    def changeType(self,name):
        if name in self.types:
            self.value = [name]
            # whip out the the children properties and re-make them
            self.clearChildren()
            self.initProperties()
        else:
            for prop in self.props:
                prop.changeType(name)

    def getProperty(self, name):
        if name == vname:
            return self

        outprop = None        
        for prop in self.props:
            outprop = prop.getProperty(name)
            if outprop is not None:
                return outprop

        return None

    def getPropertyString(self):
        out=""
        print("getPropertyString() for %s"%self.getCallString())
        print(self.value)
        print(type(self.value))
        if self.vtype is 'file':
            out = "%s = \"%s\"" % (self.getCallString(), self.value[0])
        if self.vtype is 'option':
            out = "%s = \"%s\"" % (self.getCallString(), self.value[0])
        if self.vtype is 'link':
            out = "%s = \"%s\"" % (self.getCallString(), self.value[0])
        if self.vtype is 'string':
            out = "%s = \"%s\"" % (self.getCallString(), self.value[0])
        if self.vtype == 'bool' or self.vtype == 'int' or self.vtype == 'u_int':
            out = "%s = %d" % (self.getCallString(), int(self.value))
        if self.vtype == 'float' or self.vtype == 'double' or self.vtype == 'u_longlong' or self.vtype == 'spectrum':
            out = "%s = %f" % (self.getCallString(), float(self.value))
        if self.vtype == 'uv':
            out = "%s = %f %f" % (self.getCallString(), float(self.value[0]), float(self.value[1]))
        if self.vtype == 'point':
            out = "%s = %f %f %f" % (self.getCallString(), float(self.value[0]), float(self.value[1]), float(self.value[2]))
        if self.vtype == 'vector':
            out = "%s = %f %f %f" % (self.getCallString(), float(self.value[0]), float(self.value[1]), float(self.value[2]))
        if self.vtype == 'texture':
            print("PROPERTY VALUE")
            print(type(self.value[0]))
            print(self.value)
            if type(self.value[0]) is 'str'.__class__:
                out = "%s = \"%s\"" % (self.getCallString(), self.value[0])
            elif len(self.value) == 1:
                if type(self.value[0]) is int:
                    out = "%s = %f" % (self.getCallString(), int(self.value[0]))
                elif type(self.value[0]) is float:
                    out = "%s = %f" % (self.getCallString(), float(self.value[0]))
                else:
                    out = "%s = %s" % (self.getCallString(), self.value[0])
            elif len(self.value) == 2:
                if type(self.value[0]) is int:
                    out = "%s = %d %d" % (self.getCallString(), int(self.value[0]), int(self.value[1]))
                else:
                    out = "%s = %f %f" % (self.getCallString(), float(self.value[0]), float(self.value[1]))
            else: 
                if type(self.value[0]) is int:
                    out = "%s = %d %d %d" % (self.getCallString(), int(self.value[0]), int(self.value[1]), int(self.value[2]))
                else:
                    out = "%s = %f %f %f" % (self.getCallString(), float(self.value[0]), float(self.value[1]), float(self.value[2]))
 
        # get children property strings
        for prop in self.props:
            out += '\n' + prop.getPropertyString()

        return out

    def getCallString(self):
        if self.nname is None or self.ntype is None:
            return ''
        elif self.ntype is 'camera':
            return "scene.camera.%s"%self.vname
        elif self.ntype is 'shapes':
            return "scene.shapes.%s.%s"%(self.nname,self.vname)
        elif self.ntype is 'objects':
            return "scene.objects.%s.%s"%(self.nname,self.vname)
        elif self.ntype is 'materials':
            return "scene.materials.%s.%s"%(self.nname,self.vname)
        elif self.ntype is 'textures':
            return "scene.textures.%s.%s"%(self.nname,self.vname)
        elif self.ntype is 'volumes':
            return "scene.volumes.%s.%s"%(self.nname,self.vname)
        return "%s.%s"%(self.nname,self.vname)

    def getProperties(self):
        props = []
        props.append(self)
        for prop in self.props:
            props += prop.getProperties()
        return props

    def initProperties(self):
        self.clearChildren()

        print("initProperties")
        print(type(self.value))        

        if type(self.value) is float or type(self.value) is int:
            print("FOUND")
            return

        print("ADDING PROP %s"%self.value[0])

        if self.ntype == 'shapes':
            self.initShapesProperties()
        elif self.ntype == 'materials':
            self.initMaterialsProperties()
        elif self.ntype == 'textures':
            self.initTexturesProperties()
        elif self.ntype == 'volumes':
            self.initVolumesProperties()

    def initShapesProperties(self):

        if self.value[0] == 'mesh':
            self.props.append(Property('shapes',self.nname,'ply','file',None,None,None,[""],""))
 
    def initMaterialsProperties(self):

        if self.value[0] == 'matte':
            self.props.append(Property('materials',self.nname,'kd','texture',None,None,None,[1,1,1],"texture or constant color of the matte material"))
        if self.value[0] == 'glossy2':
            self.props.append(Property('materials',self.nname,'kd','texture',None,None,None,[1,1,1],"texture or constant diffuse color of the material"))
            self.props.append(Property('materials',self.nname,'ks','texture',None,None,None,[1,1,1],"texture or constant specular color of the material"))
            self.props.append(Property('materials',self.nname,'uroughness','texture',None,None,None,[0.1,0.1,0.1],"texture or constant roughness value along u coordinate of the material"))
            self.props.append(Property('materials',self.nname,'vroughness','texture',None,None,None,[0.1,0.1,0.1],"texture or constant roughness value along v coordinate of the material"))
            self.props.append(Property('materials',self.nname,'ka','texture',None,None,None,[0.0,0.0,0.0],"texture or constant value of coefficient of absorption of the coating layer"))
            self.props.append(Property('materials',self.nname,'d','texture',None,None,None,[0.0,0.0,0.0],"texture or constant value of the depth (thickness) of the coating layer for absorption effects. (0 = disables)"))
            self.props.append(Property('materials',self.nname,'index','texture',None,None,None,[0.0,0.0,0.0],"IOR of the coating. IOR overrides color Ks if both are specified"))

        if self.value[0] == 'glass':
            self.props.append(Property('materials',self.nname,'kr','texture',None,None,None,[1,1,1],"texture or constant reflected color of the material"))
            self.props.append(Property('materials',self.nname,'kt','texture',None,None,None,[1,1,1],"texture or constant transmitted color of the material"))
            self.props.append(Property('materials',self.nname,'interiorior','texture',None,None,None,[1,1,1],"inside texture or constant index of refraction (only for volume-less rendering)"))
            self.props.append(Property('materials',self.nname,'exteriorior','texture',None,None,None,[1,1,1],"outside texture or constant index of refraction (only for volume-less rendering)"))
 
        if self.value[0] == 'metal2':
            self.props.append(Property('materials',self.nname,'fresnel','texture',None,None,None,[1,1,1],""))
            self.props.append(Property('materials',self.nname,'uroughness','texture',None,None,None,[0.1,0.1,0.1],"texture or constant roughness value along u coordinate of the material"))
            self.props.append(Property('materials',self.nname,'vroughness','texture',None,None,None,[0.1,0.1,0.1],"texture or constant roughness value along v coordinate of the material"))
 
        if self.value[0] == 'mattetranslucent':
            self.props.append(Property('materials',self.nname,'kr','texture',None,None,None,[0.5,0.5,0.5],"texture or constant reflected color of the material"))
            self.props.append(Property('materials',self.nname,'kt','texture',None,None,None,[0.5,0.5,0.5],"texture or constant transmitted color of the material"))
  
        if self.value[0] == 'mirror':
            self.props.append(Property('materials',self.nname,'kr','texture',None,None,None,[1,1,1],"texture or constant reflected color of the material"))
  
        if self.value[0] == 'mix':
            self.props.append(Property('materials',self.nname,'material1','string',None,None,None,[''],"name of another material"))
            self.props.append(Property('materials',self.nname,'material2','string',None,None,None,[''],"name of another material"))
            self.props.append(Property('materials',self.nname,'amount','texture',None,None,None,[1,1,1],"texture or constant value used to mix the materials"))
        if self.value[0] == 'null':
            pass
        if self.value[0] == 'roughglass':
            self.props.append(Property('materials',self.nname,'kr','texture',None,None,None,[1,1,1],"texture or constant reflected color of the material"))
            self.props.append(Property('materials',self.nname,'kt','texture',None,None,None,[1,1,1],"texture or constant transmitted color of the material"))
            self.props.append(Property('materials',self.nname,'interiorior','texture',None,None,None,[1.5,1.5,1.5],"inside texture or constant index of refraction (only for volume-less rendering)"))
            self.props.append(Property('materials',self.nname,'exteriorior','texture',None,None,None,[1,1,1],"outside texture or constant index of refraction (only for volume-less rendering)"))
            self.props.append(Property('materials',self.nname,'uroughness','texture',None,None,None,[0.1,0.1,0.1],"texture or constant roughness value along u coordinate of the material"))
            self.props.append(Property('materials',self.nname,'vroughness','texture',None,None,None,[0.1,0.1,0.1],"texture or constant roughness value along v coordinate of the material"))
        if self.value[0] == 'roughmatte':
            self.props.append(Property('materials',self.nname,'kd','texture',None,None,None,[0.75,0.75,0.75],"texture or constant color of the matte material"))
            self.props.append(Property('materials',self.nname,'sigma','texture',None,None,None,[0,0,0],"texture or constant color of the matte material"))
        if self.value[0] == 'velvet':
            self.props.append(Property('materials',self.nname,'kd','texture',None,None,None,[0.5,0.5,0.5],"color of the material's fuzz"))
            self.props.append(Property('materials',self.nname,'p1','texture',None,None,None,[-2.0],"texture or constant color of the matte material"))
            self.props.append(Property('materials',self.nname,'p2','texture',None,None,None,[20.0],"texture or constant color of the matte material"))
            self.props.append(Property('materials',self.nname,'p3','texture',None,None,None,[2.0],"texture or constant color of the matte material"))
            self.props.append(Property('materials',self.nname,'p1','texture',None,None,None,[0.1],"texture or constant color of the matte material"))
        if self.value[0] == 'archglass':
            self.props.append(Property('materials',self.nname,'kr','texture',None,None,None,[1,1,1],"texture or constant reflected color of the material"))
            self.props.append(Property('materials',self.nname,'kt','texture',None,None,None,[1,1,1],"texture or constant transmitted color of the material"))
            self.props.append(Property('materials',self.nname,'interiorior','texture',None,None,None,[1.5,1.5,1.5],"inside texture or constant index of refraction (only for volume-less rendering)"))
            self.props.append(Property('materials',self.nname,'exteriorior','texture',None,None,None,[1,1,1],"outside texture or constant index of refraction (only for volume-less rendering)"))
        if self.value[0] == 'carpaint':
            self.props.append(Property('materials',self.nname,'preset','string',None,None,None,['ford f8'],"one of the avilable presets"))
            self.props.append(Property('materials',self.nname,'ka','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('materials',self.nname,'d','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('materials',self.nname,'kd','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('materials',self.nname,'ks1','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('materials',self.nname,'ks2','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('materials',self.nname,'ks3','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('materials',self.nname,'r1','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('materials',self.nname,'r2','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('materials',self.nname,'r3','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('materials',self.nname,'m1','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('materials',self.nname,'m2','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('materials',self.nname,'m3','texture',None,None,None,[0,0,0],""))
        if self.value[0] == 'cloth':
            self.props.append(Property('materials',self.nname,'preset','string',None,None,None,['denim'],"denim, silk_charmeuse, silk_shantung, cotton_twill, wool_garbardine or polyester_lining_cloth"))
            self.props.append(Property('materials',self.nname,'weft_kd','texture',None,None,None,[0.5,0.5,0.5],"coefficient of diffuse reflection in one weave direction"))
            self.props.append(Property('materials',self.nname,'weft_ks','texture',None,None,None,[0.5,0.5,0.5],"coefficient of specular reflection in one weave direction"))
            self.props.append(Property('materials',self.nname,'wrap_kd','texture',None,None,None,[0.5,0.5,0.5],"coefficient of diffuse reflection in the opposite weave direction"))
            self.props.append(Property('materials',self.nname,'wrap_ks','texture',None,None,None,[0.5,0.5,0.5],"coefficient of specular reflection in the opposite weave direction"))
            self.props.append(Property('materials',self.nname,'repeat_u','float',None,None,None,100.0,"thread count in the u direction"))
            self.props.append(Property('materials',self.nname,'repeat_v','float',None,None,None,100.0,"thread count in the v direction"))

        if self.ntype == 'materials':
            # Common
            self.props.append(Property('materials',self.nname,'bumptex','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('materials',self.nname,'normaltex','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('materials',self.nname,'samples','int',None,-1,None,-1,""))
            self.props.append(Property('materials',self.nname,'visibility.indirect.diffuse.enable','int',None,0,1,1,""))
            self.props.append(Property('materials',self.nname,'visibility.indirect.glossy.enable','int',None,0,1,1,""))
            self.props.append(Property('materials',self.nname,'visibility.indirect.specular.enable','int',None,0,1,1,""))
            self.props.append(Property('materials',self.nname,'bumpsamplingdistance','float',None,0.0,None,0.001,""))
            # this fail the material because you can't use '' with these properties
            self.props.append(Property('materials',self.nname,'volume.interior','link',None,None,None,['default_volume'],""))
            self.props.append(Property('materials',self.nname,'volume.exterior','link',None,None,None,['default_volume'],""))
            self.props.append(Property('materials',self.nname,'id','int',None,0,None,0,""))
            self.props.append(Property('materials',self.nname,'transparency','texture',None,None,None,[1,1,1],""))
            self.props.append(Property('materials',self.nname,'shadowcatcher.enable','int',None,0,1,0,""))

            # Light Emission
            self.props.append(Property('materials',self.nname,'emission','texture',None,None,None,[0,0,0],"color of the emitted light"))
            # why is gain not in the SDL and why is that lights won't work without it?
            self.props.append(Property('materials',self.nname,'emission.gain','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('materials',self.nname,'emission.power','spectrum',None,None,None,0.0,"lamp output power in watts. Setting 0 for both power and efficacy bypasses this feature and uses only the lamp gain"))
            self.props.append(Property('materials',self.nname,'emission.efficency','float',None,None,None,0.0,"luminous efficacy in lumens/watt. Setting 0 for both power and efficacy bypasses this feature and uses only the lamp gain"))
            self.props.append(Property('materials',self.nname,'emission.mapfile','string',None,None,None,[''],""))
            self.props.append(Property('materials',self.nname,'emission.gamma','float',None,None,None,2.2,""))
            self.props.append(Property('materials',self.nname,'emission.iesfile','string',None,None,None,[''],""))
            self.props.append(Property('materials',self.nname,'emission.flipz','int',None,0,1,0,""))
            self.props.append(Property('materials',self.nname,'emission.samples','int',None,-1,1000,-1,"the number of shadow ray to trace to compute direct light from this material. This property is an hint and the render engine can ignore this information. -1 means use the default global value."))
            self.props.append(Property('materials',self.nname,'emission.map.width','int',None,0,None,0,""))
            self.props.append(Property('materials',self.nname,'emission.map.height','int',None,0,None,0,""))
            self.props.append(Property('materials',self.nname,'emission.id','int',None,0,None,0,""))

    def initTexturesProperties(self):

        # TODO - need to figure out a way to get the correct mapping type when it's changed

        if self.value[0] == 'imagemap':
            self.props.append(Property('textures',self.nname,'file','string',None,None,None,['image.png'],""))
            self.props.append(Property('textures',self.nname,'gamma','float',None,None,None,2.2,""))
            self.props.append(Property('textures',self.nname,'gain','float',None,None,None,1.0,""))
            self.props.append(Property('textures',self.nname,'mapping.type','string',None,None,None,['uvmapping2d'],"",TexturesMappingType)) 

        if self.value[0] == 'marble':
            self.props.append(Property('textures',self.nname,'octaves','int',None,None,None,8,""))
            self.props.append(Property('textures',self.nname,'roughness','float',None,None,None,0.5,""))
            self.props.append(Property('textures',self.nname,'scale','float',None,None,None,1.0,""))
            self.props.append(Property('textures',self.nname,'variation','float',None,None,None,0.2,""))
            self.props.append(Property('textures',self.nname,'mapping.type','string',None,None,None,['uvmapping2d'],"",TexturesMappingType)) 
         
        if self.value[0] == 'mix':
            self.props.append(Property('textures',self.nname,'amount','texture',None,None,None,[0.5,0.5,0.5],""))
            self.props.append(Property('textures',self.nname,'texture1','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('textures',self.nname,'texture2','texture',None,None,None,[1,1,1],""))
            self.props.append(Property('textures',self.nname,'mapping.type','string',None,None,None,['uvmapping2d'],"",TexturesMappingType)) 
          
        if self.value[0] == 'scale':
            self.props.append(Property('textures',self.nname,'texture1','texture',None,None,None,[1,1,1],""))
            self.props.append(Property('textures',self.nname,'texture2','texture',None,None,None,[1,1,1],""))
            self.props.append(Property('textures',self.nname,'mapping.type','string',None,None,None,['uvmapping2d'],"",TexturesMappingType)) 

        if self.value[0] == 'uv':
            self.props.append(Property('textures',self.nname,'mapping.type','string',None,None,None,['uvmapping2d'],"",TexturesMappingType)) 

        if self.value[0] == 'hitpointalpha':
            self.props.append(Property('textures',self.nname,'mapping.type','string',None,None,None,['uvmapping2d'],"",TexturesMappingType)) 

        if self.value[0] == 'hitpointcolor':
            self.props.append(Property('textures',self.nname,'mapping.type','string',None,None,None,['uvmapping2d'],"",TexturesMappingType)) 

        if self.value[0] == 'hitpointgrey':
            self.props.append(Property('textures',self.nname,'channel','int',None,-1,None,-1,"the index of the RGB channel to use. -1 means the luminance of the RGB value"))
            self.props.append(Property('textures',self.nname,'mapping.type','string',None,None,None,['uvmapping2d'],"",TexturesMappingType)) 

        if self.value[0] == 'hsv':
            self.props.append(Property('textures',self.nname,'texture','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('textures',self.nname,'hue','texture',None,None,None,[0.5,0.5,0.5],""))
            self.props.append(Property('textures',self.nname,'saturation','texture',None,None,None,[1.0,1.0,1.0],""))
            self.props.append(Property('textures',self.nname,'value','texture',None,None,None,[1.0,1.0,1.0],""))
            self.props.append(Property('textures',self.nname,'mapping.type','string',None,None,None,['uvmapping2d'],"",TexturesMappingType)) 

        if self.value[0] == 'windy':
            self.props.append(Property('textures',self.nname,'mapping.type','string',None,None,None,['globalmapping3d'],"",TexturesMappingType)) 

        if self.value[0] == 'wood':
            self.props.append(Property('textures',self.nname,'woodtype','option',None,None,None,['bands'],"",TexturesWoodType)) 
            self.props.append(Property('textures',self.nname,'noisebasis2','option',None,None,None,['sin'],"",TexturesWoodNoiseBasis2)) 
            self.props.append(Property('textures',self.nname,'noisetype','option',None,None,None,['soft_noise'],"",TexturesWoodNoiseType)) 
            self.props.append(Property('textures',self.nname,'noisesize','float',None,None,None,0.25,"")) 
            self.props.append(Property('textures',self.nname,'turbulence','float',None,None,None,5.0,"")) 
            self.props.append(Property('textures',self.nname,'bright','float',None,None,None,1.0,"")) 
            self.props.append(Property('textures',self.nname,'contrast','float',None,None,None,1.0,"")) 
            self.props.append(Property('textures',self.nname,'mapping.type','string',None,None,None,['globalmapping3d'],"",TexturesMappingType)) 

        # Texture Mapping 
        if self.value[0] == 'uvmapping2d':
            self.props.append(Property('textures',self.nname,'mapping.uvscale','uv',None,None,None,[1.0,1.0],""))
            self.props.append(Property('textures',self.nname,'mapping.uvdelta','uv',None,None,None,[0.0,0.0],""))

        if self.value[0] == 'uvmapping3d':
            pass
            #self.props.append(Property('textures',self.nname,'mapping.uvscale','uv',None,None,None,[1.0,1.0],""))
            #self.props.append(Property('textures',self.nname,'mapping.uvdelta','uv',None,None,None,[0.0,0.0],""))

        if self.value[0] == 'globalmapping3d':
            pass
            #self.props.append(Property('textures',self.nname,'mapping.uvscale','uv',None,None,None,[1.0,1.0],""))
            #self.props.append(Property('textures',self.nname,'mapping.uvdelta','uv',None,None,None,[0.0,0.0],""))

    def initVolumesProperties(self):

        if self.value[0] == 'clear':
            pass

        if self.value[0] == 'homogeneous':
            self.props.append(Property('volumes',self.nname,'scattering','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('volumes',self.nname,'asymmetry','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('volumes',self.nname,'multiscattering','int',None,0,1,1,""))
 
        if self.value[0] == 'heterogeneous':
            self.props.append(Property('volumes',self.nname,'scattering','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('volumes',self.nname,'asymmetry','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('volumes',self.nname,'multiscattering','int',None,0,1,1,""))
            self.props.append(Property('volumes',self.nname,'steps.size','float',None,0,None,1.0,""))
            self.props.append(Property('volumes',self.nname,'steps.maxcount','int',None,0,None,1,""))
 
        if self.ntype == 'volumes':
            # Common
            self.props.append(Property('volumes',self.nname,'priority','int',None,0,None,0,""))
            self.props.append(Property('volumes',self.nname,'ior','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('volumes',self.nname,'absorption','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('volumes',self.nname,'emission','texture',None,None,None,[0,0,0],""))
            self.props.append(Property('volumes',self.nname,'emission.id','int',None,0,None,0,""))
 
# NODE
class Node:

    def __init__(self,name=None,ntype=None):
        self.name = name
        self.ntype = ntype # 'camera','lights','textures','materials','objects','shapes','volumes' 
        self.props = []

    def clear(self):
        self.name = None
        self.ntype = None
        self.props = []

    def addProperty(self,prop):
        self.props.append(prop)

    def clearProperties(self):
        for prop in self.props:
            prop.clearChildren()
            del(prop)
        self.props = []

    def getProperty(self,name):
        print("looking for %s"%name)
        for prop in self.props:
            if name == prop.vname:
                print("found prop %s"%name)
                return prop
        return None

    def getProperties(self):
        props = []
        for prop in self.props:
            props += prop.getProperties()
        return props
 
    def getPropertyString(self):
        out = ""
        for prop in self.props:
            if prop.enabled:
                out += prop.getPropertyString() + "\n"
        print("getPropertyString()")
        print(out)
        print("END")
        return out


# LUX SCENE
class Lux(QThread):

    def __init__(self):
        super().__init__()
        pyluxcore.Init()

        self.props = pyluxcore.Properties()
        self.props.Set(pyluxcore.Property("renderengine.type", ["PATHCPU"]))
        self.props.Set(pyluxcore.Property("opencl.platform.index", [-1]))
        self.props.Set(pyluxcore.Property("opencl.cpu.use", [0]))
        self.props.Set(pyluxcore.Property("opencl.gpu.use", [1]))
        self.props.Set(pyluxcore.Property("opencl.gpu.workgroup.size", [64]))
        self.props.Set(pyluxcore.Property("film.width", [1024]))
        self.props.Set(pyluxcore.Property("film.height", [576]))
        # camera
        self.sceneprops = pyluxcore.Properties()
        self.sceneprops.Set(pyluxcore.Property("scene.camera.lookat.orig", [0.64, 0.27, 0.14]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.lookat.target", [0.10, 1.04, -0.18]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.up", [0, 0, 1]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.cliphither", [0.001]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.clipyon", [1.00]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.lensradius", [0.00]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.focaldistance", [0.28]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.fieldofview", [49]))

        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain", [0, 0, 0]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.transformation", [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.samples", [-1]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.visibility.indirect.diffuse.enable", [1]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.visibility.indirect.glossy.enable", [1]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.visibility.indirect.specular.enable", [1]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.dir", [-0.51, -3.38, 0.76]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.turbidity", [2.20]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.relsize", [1]))

        self.scene = pyluxcore.Scene()
        self.scene.Parse(self.sceneprops) 
       
        self.config = pyluxcore.RenderConfig(self.props, self.scene)
        self.session = pyluxcore.RenderSession(self.config)
      
    def load(self):
        val = 0
        print("Object Count:%d"%(self.scene.GetObjectCount()))
        print("Light Count:%d"%(self.scene.GetObjectCount()))

    def startRendering(self):
        self.session.Start() 
        
    def paused(self,state):
        if(state):
            self.session.EndSceneEdit()
        else:
            self.session.BeginSceneEdit()

    def writeImage(self):
        self.session.UpdateStats()
        self.session.GetFilm().Save()

    def stopRendering(self):
        self.session.GetFilm().Save()
        self.session.Stop()

    def rotateCamera(self,angle,vector):
        self.session.BeginSceneEdit()
        self.scene.GetCamera().Rotate(angle,vector)
        self.session.EndSceneEdit()
 
    def getTime(self):
        stats = self.session.GetStats();
        return stats.Get("stats.renderengine.time").GetFloat()

    def getPass(self):
        stats = self.session.GetStats();
        return stats.Get("stats.renderengine.pass").GetInt()

    def getSpp(self):
        stats = self.session.GetStats();
        return stats.Get("stats.renderengine.total.samplesec").GetFloat()

    def getTriCount(self):
        stats = self.session.GetStats();
        return stats.Get("stats.dataset.trianglecount").GetFloat()

    def getMaterialType(self,name):
        mtype = ""
        mtype=self.scnprops.Get("scene.materials.%s.type"%name).Get() 
        print("mtype = %s"%mtype)
        return mtype 

    def getTextureType(self,name):
        return self.scnprops.Get("scene.textures.%s.type"%name).Get() 

    def beginEdit(self):
        self.session.BeginSceneEdit()

    def endEdit(self):
        self.session.EndSceneEdit()
        self.writeImage()

    # This is needed since luxcore will crash if you try to set a property that was not set in the file.
    # To fix this we will call this method before we try to set any properties.
    # When the AE is first loaded it will load the properties for lux and then this method will get called
    # for each property.
    # It will ask lux if the property exists and add it if it doesn't.   
    def verifyProperty(self,name,prop):
        if self.scnprops.IsDefined(name) is False:
            print(name + " is missing. Adding it")
            if prop.type == 'string' or prop.type == 'link' or prop.type == 'option':
                self.scnprops.Set(pyluxcore.Property(name, [prop.value]))
            if prop.type == 'bool' or prop.type == 'int' or prop.type == 'u_int':
                self.scnprops.Set(pyluxcore.Property(name, [prop.value]))
            if prop.type == 'float' or prop.type == 'double' or prop.type == 'u_longlong' or prop.type == 'spectrum':
                self.scnprops.Set(pyluxcore.Property(name, [prop.value]))
            if prop.type == 'uv':
                self.scnprops.Set(pyluxcore.Property(name, [prop.value[0],prop.value[1]]))
            if prop.type == 'point':
                self.scnprops.Set(pyluxcore.Property(name, [prop.value[0],prop.value[1],prop.value[2]]))
            if prop.type == 'vector':
                self.scnprops.Set(pyluxcore.Property(name, [prop.value[0],prop.value[1]],prop.value[2]))
            if prop.type == 'texture':
                self.scnprops.Set(pyluxcore.Property(name, [prop.value[0],prop.value[1],prop.value[2]]))

    def changeSize(self,width,height):
        print("CHANGE SIZE")
        self.setFixedWidth(width)
        self.setFixedHeight(height)

        # Stop the rendering
        self.session.Stop()
        self.session = None

        # Set the new size
        self.scene.Parse(pyluxcore.Properties().
            Set(pyluxcore.Property("film.width", [width])).
            Set(pyluxcore.Property("film.height", [height])))

        # Re-start the rendering
        self.session = pyluxcore.RenderSession(self.config)
        self.session.Start()

    def setProperties(self,propstring):
        print("PROP CALL STRING")
        print(propstring)
        self.session.BeginSceneEdit()
        try:
            self.scene.Parse(self.sceneprops.SetFromString(propstring))
        except RuntimeError:
            pass
        self.session.EndSceneEdit()
        self.writeImage()
   
    def setRenderSettings(self,propstring):
        # Stop the rendering
        self.session.Stop()
        self.session = None

        print("NEW RENDER SETTINGS")
        print(propstring)
        self.config.Parse(pyluxcore.Properties().SetFromString(propstring))

        # Re-start the rendering
        self.session = pyluxcore.RenderSession(self.config)
        self.session.Start()

    def getRenderSettings(self):
        self.session.UpdateStats()
        #props = RenderProps()
        #props.width.value = self.session.GetFilm().GetWidth()
        #props.height.value = self.session.GetFilm().GetHeight()
        #return props


    def getWidth(self):
        self.session.UpdateStats()
        return self.session.GetFilm().GetWidth()

    def getHeight(self):
        self.session.UpdateStats()
        return self.session.GetFilm().GetHeight()

    def getNode(self, node):
        for prop in node.props:
            print("PROP NAME")
            #name = prop.luxprop.GetName() #self.sceneprops.Get(prop.getCallString()).Get()
            print(prop.luxprop)
            print(self.sceneprops.GetAllUniqueSubNames(prop.getCallString()))

    # TESTING
    def setColor(self,prop,val):
        prop.Set(val)
        self.scene.Parse(self.sceneprops.Set(prop))

    # TESTING
    def getColor(self,prop):
        print(prop.Get())

    def removeNode(self,node):
        names = self.sceneprops.GetAllNames()
        print("Property List BEFORE")
        for name in names:
            print(name)
        print("END")

        for prop in node.props:
            self.sceneprops.Delete(prop.getCallString())
            self.sceneprops.Clear()

        self.session.BeginSceneEdit()
        self.scene.Parse(self.sceneprops) 
        self.scene.DeleteObject(node.name) 

        #self.session.EndSceneEdit()
        names = ""
        names = self.sceneprops.GetAllNames()
        print("Property List AFTER")
        for name in names:
            print(name)
        print("END")
            
    def addNode(self,node):

        print("ADD NODE %s"%node.name)
        for prop in node.props:
            luxprop = pyluxcore.Property(prop.getCallString(), prop.value)
            self.sceneprops.Set(luxprop)
            prop.luxprop = luxprop

        self.scene.Parse(self.sceneprops)

        return node

    def getName(self,prop):
        print("PASSED PROP NAME " + prop.vname)

        self.session.BeginSceneEdit()
        self.scene.Parse(pyluxcore.Properties().
            Set(pyluxcore.Property(prop.vname, [1,0,0]))
        ) 
        self.session.EndSceneEdit()
        #self.writeImage()
 
        names = self.scene.ToProperties().GetAllUniqueSubNames("scene.materials")
        for n in names:
            print(n)
        return("DONE")

    def fillInProperties(self,node):
        props = node.getProperties()

        for prop in props:
            try:
                val = self.sceneprops.Get(prop.getCallString()).Get()
                valpass = True
            except RuntimeError:
                print("No property %s in sceneprops, skipping the load process for this prop")
                # disable this property since there was no call string for it
                # this is usually due to parsing a file with missing props
                prop.enabled = 0
                valpass = False
            if valpass:
                if prop.vtype == 'int':
                    prop.value = int(val[0])
                elif prop.vtype == 'float' or prop.vtype == 'double' or prop.vtype == 'u_longlong' or prop.vtype == 'spectrum':
                    prop.value = float(val[0])
                elif prop.vtype == 'string' or prop.vtype == 'option' or prop.vtype == 'link' or prop.vtype == 'file':
                    prop.value = val
                elif prop.vtype == 'uv':
                    prop.value = []
                    for v in val:
                        prop.value.append(float(v))
                elif prop.vtype == 'point' or prop.vtype == 'vector':
                    prop.value = []
                    for v in val:
                        prop.value.append(float(v))
                elif prop.vtype == 'matrix':
                    pass
                else:
                    # it's a texture if it makes it this far
                    print("FILLING IN PROP %s for node %s with:"%(prop.vname,node.name))
                    print(val)
                    # check to see if it's a string
                    prop.value = []
                    if len(val) == 1:
                        try:
                            for v in val:
                                prop.value.append(int(v))
                        except ValueError:
                            prop.value = val
                            #prop.value.append(val)     
                    else: 
                        for v in val:
                            prop.value.append(float(v))
                prop.enabled = 1

# SCENEGRAPH

class SceneGraph():

    def __init__(self):
        self.lux = Lux()

        # Property containers
        #self.render = RenderProps()
        self.rendernodes = []
        self.nodes = []

        # default camera
        camera = Node('default_camera','camera')
        self.addCameraProperties(camera)
        camera.getProperty('lookat.orig').value = [0.64, 0.27, 0.14]
        camera.getProperty('lookat.target').value = [0.10, 1.04, -0.18]
        self.nodes.append(camera)

        # default volume
        volume = Node('default_volume','volumes')
        self.addVolumeProperties(volume,'clear')
        self.nodes.append(volume)

        self.initRenderNodes()
        #self.lux.setRenderSettings(self.render.getPropertyString)

    def initRenderNodes(self):
        # render engine
        renderengine = Node('renderengine','renderengine')
        renderengine.addProperty(Property('renderengine','renderengine','type','string',None,None,None,['PATHCPU'],""))
        # CPU
        cpu = Node('cpu','cpu')
        cpu.addProperty(Property('native','native','threads.count','int',None,1,None,3,""))
        # PATHCPU
        path = Node('path','path')
        path.props.append(cpu.props[0])
        path.addProperty(Property('path','path','maxdepth','int',None,1,16,5,""))
        path.addProperty(Property('path','path','russianroulette.depth','int',None,1,16,3,""))
        path.addProperty(Property('path','path','russianroulette.cap','float',None,0.0,1.0,0.5,""))
        path.addProperty(Property('path','path','clamping.variance.maxvalue','float',None,0.0,None,0.0,""))
        path.addProperty(Property('path','path','clamping.pdf.value','float',None,0.0,1.0,0.0,""))
        path.addProperty(Property('path','path','fastpixelfilter.enable','bool',None,0,1,1,""))
        # BIASPATHCPU
        biaspath = Node('biaspath','biaspath')
        biaspath.props.append(cpu.props[0])
        biaspath.addProperty(Property('biaspath','biaspath','pathdepth.total','int',None,0,16,10,""))
        biaspath.addProperty(Property('biaspath','biaspath','pathdepth.diffuse','int',None,0,16,4,""))
        biaspath.addProperty(Property('biaspath','biaspath','pathdepth.glossy','int',None,0,16,3,""))
        biaspath.addProperty(Property('biaspath','biaspath','pathdepth.specular','int',None,0,16,3,""))
        biaspath.addProperty(Property('biaspath','biaspath','sampling.aa.size','int',None,1,13,3,""))
        biaspath.addProperty(Property('biaspath','biaspath','sampling.diffuse.size','int',None,1,13,3,""))
        biaspath.addProperty(Property('biaspath','biaspath','sampling.glossy.size','int',None,1,13,2,""))
        biaspath.addProperty(Property('biaspath','biaspath','sampling.specular.size','int',None,1,13,2,""))
        biaspath.addProperty(Property('biaspath','biaspath','sampling.directlight.size','int',None,1,13,1,""))
        biaspath.addProperty(Property('biaspath','biaspath','lights.lowthreshold','float',None,0.0,None,0.0,""))
        biaspath.addProperty(Property('biaspath','biaspath','lights.nearstart','float',None,0.0,None,0.001,""))
        biaspath.addProperty(Property('biaspath','biaspath','lights.firstvertexsamples','int',None,1,16,4,""))
        biaspath.addProperty(Property('biaspath','biaspath','clamping.variance.maxvalue','float',None,0.0,0.0,0.0,""))
        biaspath.addProperty(Property('biaspath','biaspath','clamping.pdf.value','float',None,0.0,1.0,0.0,""))
        biaspath.addProperty(Property('tile','tile','size','int',None,8,256,32,""))
        biaspath.addProperty(Property('tile','tile','size.x','int',None,8,256,32,""))
        biaspath.addProperty(Property('tile','tile','size.y','int',None,8,256,32,""))
        biaspath.addProperty(Property('tile','tile','multipass.enable','int',None,0,1,1,""))
        biaspath.addProperty(Property('tile','tile','multipass.convergencetest.threshold','float',None,1.0,256.0,6.0,""))
        biaspath.addProperty(Property('tile','tile','multipass.convergencetest.threshold256','float',None,0.0,256.0,6.0,""))
        biaspath.addProperty(Property('tile','tile','multipass.convergencetest.threshold.reduction','float',None,0.0,1.0,0.0,""))
        biaspath.addProperty(Property('tile','tile','multipass.convergencetest.warmup.count','int',None,0,None,32,""))
        # BIDIRCPU 
        bidir= Node('bidir','bidir')
        bidir.props.append(cpu.props[0])
        bidir.addProperty(Property('path','path','maxdepth','int',None,1,16,5,""))
        bidir.addProperty(Property('light','light','maxdepth','int',None,1,16,5,""))
        bidir.addProperty(Property('path','path','russianroulette.depth','int',None,1,16,3,""))
        bidir.addProperty(Property('path','path','russianroulette.cap','float',None,0.0,1.0,0.5,""))

        # OpenCL Engines

        # COMMON
        opencl= Node('opencl','opencl')
        opencl.addProperty(Property('opencl','opencl','platform.index','int',None,None,None,-1,""))
        opencl.addProperty(Property('opencl','opencl','cpu.use','int',None,0,1,0,""))
        opencl.addProperty(Property('opencl','opencl','gpu.use','int',None,0,1,0,""))
        opencl.addProperty(Property('opencl','opencl','cpu.workgroup.size','int',None,0,None,0,""))
        opencl.addProperty(Property('opencl','opencl','gpu.workgroup.size','int',None,0,None,0,""))
        opencl.addProperty(Property('opencl','opencl','device.select','string',None,None,None,[''],""))
        # PATHOCL
        pathocl= Node('pathocl','pathocl')
        pathocl.addProperty(Property('pathocl','pathocl','pixelatomics.enable','int',None,0,1,0,""))
        pathocl.addProperty(Property('opencl','opencl','task.count','string',None,None,None,['Auto'],""))
        # add pathcpu attributes
        for prop in path.props:
            pathocl.props.append(prop)
        # add common attributes
        for prop in opencl.props:
            pathocl.props.append(prop) 

        # RTPATHOCL
        rtpath = Node('rtpath','rtpath')
        rtpath.addProperty(Property('rtpath','rtpath','miniterations','int',None,1,32,2,""))
        # add pathocl attributes
        for prop in pathocl.props:
            rtpath.props.append(prop)

        # BIASPATHOCL 
        biaspathocl = Node('biaspathocl','biaspathocl')
        biaspathocl.addProperty(Property('biaspathocl','biaspathocl','devices.maxtiles','int',None,1,32,16,""))
        # add pathcpu attributes
        for prop in biaspath.props:
            biaspathocl.props.append(prop)
        # add common attributes
        for prop in opencl.props:
            biaspathocl.props.append(prop) 

        # RTBIASPATHOCL 
        rtbiaspathocl = Node('rtbiaspathocl','rtbiaspathocl')
        rtbiaspathocl.addProperty(Property('rtpath','rtpath','resolutionreduction.preview','int',None,1,8,4,""))
        rtbiaspathocl.addProperty(Property('rtpath','rtpath','resolutionreduction.preview.step','int',None,1,8,2,""))
        rtbiaspathocl.addProperty(Property('rtpath','rtpath','resolutionreduction.preview.dlonly.enable','int',None,0,1,0,""))
        rtbiaspathocl.addProperty(Property('rtpath','rtpath','resolutionreduction','int',None,1,None,2,""))
        rtbiaspathocl.addProperty(Property('rtpath','rtpath','resolutionreduction.longrun','int',None,1,None,16,""))
        rtbiaspathocl.addProperty(Property('rtpath','rtpath','resolutionreduction.longrun.step','int',None,0,None,0,""))
        # add pathcpu attributes
        for prop in biaspath.props:
            rtbiaspathocl.props.append(prop)
        # add common attributes
        for prop in opencl.props:
            rtbiaspathocl.props.append(prop) 

 
        # SAMPLERS

        # METROPOLIS 
        sampler= Node('sampler','sampler')
        sampler.addProperty(Property('sampler','sampler','type','string',None,None,None,['SOBOL'],""))

        samplermetropolis = Node('sampler.metropolis','sampler.metropolis')
        samplermetropolis.addProperty(Property('sampler.metropolis','sampler.metropolis','largesteprate','float',None,0.0,1.0,0.4,""))
        samplermetropolis.addProperty(Property('sampler.metropolis','sampler.metropolis','maxconsecutivereject','int',None,0,32768,512,""))
        samplermetropolis.addProperty(Property('sampler.metropolis','sampler.metropolis','imagemutationrate','float',None,0.0,1.0,0.1,""))
 
        # film 
        film = Node('film','film')
        film.addProperty(Property('film','film','width','int',None,10,None,720,""))
        film.addProperty(Property('film','film','height','int',None,10,None,480,""))

        # FILTERS
        filter = Node('filter','filter')
        filter.addProperty(Property('film.filter','film.filter','type','string',None,None,None,['BLACKMANHARRIS'],""))
 
        # COMMON
        filtercommon = Node('filterfiler','filterfiler')
        filtercommon.addProperty(Property('film.filter','film.filter','width','float',None,0.1,3.0,2.0,""))
        filtercommon.addProperty(Property('film.filter','film.filter','xwidth','float',None,0.1,3.0,2.0,""))
        filtercommon.addProperty(Property('film.filter','film.filter','ywidth','float',None,0.1,3.0,2.0,""))
 
        # BOX
        filterbox = Node('filterbox','filterbox')
        for prop in filtercommon.props:
            filterbox.props.append(prop)

        # GAUSSIAN
        filtergaussian = Node('filtergaussian','filtergaussian')
        filtergaussian.addProperty(Property('film','film','gaussian.alpha','float',None,0.1,10.0,2.0,""))
        for prop in filtercommon.props:
            filtergaussian.props.append(prop)

        # MITCHELL
        filtermitchell = Node('filtermitchell','filtermitchell')
        filtermitchell.addProperty(Property('film.filter.mitchell','film.filter.mitchell','b','float',None,0.1,1.0,1.0/3.0,""))
        filtermitchell.addProperty(Property('film.filter.mitchell','film.filter.mitchell','c','float',None,0.1,1.0,1.0/3.0,""))
        for prop in filtercommon.props:
            filtermitchell.props.append(prop)
 
        # MITCHELL_SS
        filtermitchellss = Node('filtermitchellss','filtermitchellss')
        filtermitchellss.addProperty(Property('film.filter.mitchellss','film.filter.mitchellss','b','float',None,0.1,1.0,1.0/3.0,""))
        filtermitchellss.addProperty(Property('film.filter.mitchellss','film.filter.mitchellss','c','float',None,0.1,1.0,1.0/3.0,""))
        for prop in filtercommon.props:
            filtermitchellss.props.append(prop)
 
        # BLACKMANHARRIS 
        filterblackmanharris = Node('filterblackmanharris','filterblackmanharris')
        for prop in filtercommon.props:
            filterblackmanharris.props.append(prop)

        # ADD TO RENDERNODES
 
        # engine
        self.rendernodes.append(renderengine)
        self.rendernodes.append(path)
        self.rendernodes.append(biaspath)
        self.rendernodes.append(bidir)
        self.rendernodes.append(opencl)
        self.rendernodes.append(pathocl)
        self.rendernodes.append(rtpath)
        self.rendernodes.append(biaspathocl)
        self.rendernodes.append(rtbiaspathocl)
        # sampler
        self.rendernodes.append(sampler)
        self.rendernodes.append(samplermetropolis)
        # filter
        self.rendernodes.append(filter)
        self.rendernodes.append(filterbox)
        self.rendernodes.append(filtergaussian)
        self.rendernodes.append(filtermitchell)
        self.rendernodes.append(filtermitchellss)
        self.rendernodes.append(filterblackmanharris)
        # film
        self.rendernodes.append(film)

    def start(self):
        self.lux.startRendering() 
        self.updateAllNodes()

    def stop(self):
        self.lux.stopRendering()

    def paused(self,state):
        self.lux.paused(state)

    def write(self):
        self.lux.writeImage()

    def loadConfig(self, path):
        if(path == None):
            pass            

    def loadScene(self, path):
        if(path == None):
            pass

    def beginEdit(self):
        self.lux.beginEdit()
 
    def endEdit(self):
        self.lux.endEdit()

    # Camera Controls
    def rotateCamera(self,angle,vector):
        self.lux.rotateCamera(angle,vector)
        # TODO - update camera properties
    
    def getRenderProperty(self,ntype,pname):
        for node in self.rendernodes:
            if node.ntype == ntype:
                for prop in node.props:
                    if prop.vname == pname:
                        return prop 
        return None 
 
    def getNames(self, ntype):
        nodelist = []
        print("get names for %s"%ntype) 
        for node in self.nodes:
            print("looking at node")
            print("name=%s, type=%s"%(node.name,node.ntype))
            if node.ntype == ntype:
                print("adding node " + node.name)
                nodelist.append(node.name)

        return nodelist 

    def getRenderSettings(self):
        propstring = ''

        # ENGINE
        enginenode = None
        for node in self.rendernodes:
            if node.ntype == 'renderengine':
                enginenode = node

        propstring += enginenode.getPropertyString()         

        for node in self.rendernodes:
            if node.ntype == 'path' and enginenode.props[0].value[0] == 'PATHCPU':
                 propstring += node.getPropertyString()
            elif node.ntype == 'biaspath' and enginenode.props[0].value[0] == 'BIASPATHCPU':
                 propstring += node.getPropertyString()


        # SAMPLER
        samplernode = None
        # get sampler type
        for node in self.rendernodes:
            if node.ntype == 'sampler':
                 samplernode = node

        # build sampler string
        propstring += samplernode.getPropertyString()
        for node in self.rendernodes:
            print("sampler type = %s"%samplernode.props[0].value[0])
            if node.ntype == 'sampler.metropolis' and samplernode.props[0].value[0] == 'METROPOLIS':
                propstring += node.getPropertyString()

        # FILM
        for node in self.rendernodes:
            if node.ntype == 'film':
                propstring += node.getPropertyString()

        return propstring

    def setRenderSettings(self):
        self.lux.setRenderSettings(self.getRenderSettings())

    def updateNode(self,node):
        self.lux.setProperties(node.getPropertyString())

    def updateAllNodes(self):
        for node in self.nodes:
            self.updateNode(node)

    def getNode(self, name):
        for node in self.nodes:
            if node.name == name:
                return node

    def getRenderNode(self, name):
        for node in self.rendernodes:
            if node.name == name:
                return node

    def addNode(self, node):
        self.nodes.append(self.lux.addNode(node))

    def renameNode(self, oldname, newname):
        node = self.getNode(oldname)
        self.removeNode(oldname)
        node.name = newname
        self.nodes.append(node)
 
    def addSceneNode(self,name,ntype,subtype):
        # if the scene node already exist, replace it
        # else add it
        #print("addSceneNode() name=%s, ntype=%s, subtype=%s"%(name,ntype,subtype))
        node = None

        for n in self.nodes:
            if n.name == name and n.ntype == ntype:
                # clear out old properties
                n.clearProperties()
                self.addProperties(n,subtype)
                node = n
                self.lux.setProperties(node.getPropertyString())
            elif n.name == name:    
                print("node with name already exist but not of the same type")

        if node is None:
                node = Node(name,ntype)
                self.addProperties(node,subtype)
                self.lux.setProperties(node.getPropertyString())
                self.nodes.append(node)

        return node 

    def removeNode(self,name):
        i = 0
        for n in self.nodes:
            if n.name == name:
                print("removing %s"%n.name)
                self.lux.removeNode(n)
                del self.nodes[i]
            i += 1

    def clearScene(self):
        camera = None
        volume = None
        for n in self.nodes:
            # don't delete the camera
            if n.name == 'default_camera':
                camera = n
            if n.name == 'default_volume':
                volume = n
            else:
                self.lux.removeNode(n)
        self.nodes.clear()
        if camera is not None:
            self.nodes.append(camera)
        if volume is not None:
            self.nodes.append(volume)

    # This will parse a input string like 'scene.materials.my_material.kd'
    # and out the string type('object'), name('my_material') and value type('kd')
    def getNodeInfoFromString(self,prefix):
        data = []
        i = 0
        pi = 0
        indexs = []
        while i < len(prefix):
            try:
                i = prefix.index('.',i)
                #data.append(prefix[pi:i])
                indexs.append(i)
                pi = i+1
                i = pi+1
            except ValueError:
                pi = i
                i = pi+1
        if len(indexs) < 3:
            return None,None,None
        name = ''
        ntype = ''
        vname = ''
        # TODO - there might a time when the type is formated as 'name.name' and, in that case
        # we will need to add extra checking here
        # For the time being we know that all the lines are formated as scene.[type].[name].[vname]...
        ntype = prefix[indexs[0]+1:indexs[1]]
        name = prefix[indexs[1]+1:indexs[2]]
        vname = prefix[indexs[2]+1:]
        '''
        print(data)

        if len(data) < 4:
            return None,None,None
        ntype = data[1]
        name = data[2]
        for line in data[2]:
            if vname != '':
                vname + "."
            vname + line
        '''
        #print("out: %s,%s,%s"%(ntype,name,vname))
        return ntype,name,vname

    def parseSceneFile(self,lines):
        #print("SCN FILE START")
        #print(lines)
        #print("SCN FILE END\nAFTER CLEANUP")
        # cleanup
        setstring = ''
        cname = '' 
        nodes = []
        node = None
        for line in lines:
            line = line.strip()
            # seperate the prefix and value
            if line is not '':
                #print(line)
                setstring += line + '\n'
                i = line.index('=')
                pre = line[0:i].strip()
                val = line[i+1:].strip()
                ntype,name,vname = self.getNodeInfoFromString(pre)
                #print("IMPORT NODE %s,%s,%s"%(ntype,name,vname))
                if ntype != None and name != None and vname != None:
                    if cname != name:
                        node = Node(name,ntype)
                        nodes.append(node)
                        cname = name
                        if vname == 'ply':
                            self.addProperties(node,'ply')
                        else:
                            val = val.replace('"','')
                            self.addProperties(node,val)
                    '''
                    if vname == 'ply':
                        self.addProperties(node,'ply')
                    elif vname == 'type':
                        val = val.replace('"','')
                        self.addProperties(node,val)
                    '''
        # now we should have all our nodes
        # TODO - we need to add a check to verify all the nodes did import
        self.lux.setProperties(setstring)
        for n in nodes:
            #print("add node %s to the sg"%n.name)
            self.lux.fillInProperties(n)
            self.lux.setProperties(n.getPropertyString())
            self.nodes.append(n)

        return True
  
    def addProperties(self,node,subtype):
        if node.ntype == 'shapes':
            self.addShapeProperties(node,subtype)
        elif node.ntype == 'objects':
            self.addObjectProperties(node,subtype)
        elif node.ntype == 'materials':
            self.addMaterialProperties(node,subtype)
        elif node.ntype == 'textures':
            self.addTextureProperties(node,subtype)
        elif node.ntype == 'volumes':
            self.addVolumeProperties(node,subtype)
  
    def addCameraProperties(self,node):
        name = node.name
        node.clearProperties()
        node.addProperty(Property('camera',name,'lookat.orig','point',None,None,None,[0,1,-1],""))
        node.addProperty(Property('camera',name,'lookat.target','point',None,None,None,[0,0,0],""))
        node.addProperty(Property('camera',name,'up','vector',None,None,None,[0,0,1],""))
        node.addProperty(Property('camera',name,'cliphither','float',None,None,None,0.001,""))
        node.addProperty(Property('camera',name,'clipyon','float',None,None,None,1.0,""))
        node.addProperty(Property('camera',name,'lensradius','float',None,None,None,0.0,""))
        node.addProperty(Property('camera',name,'focaldistance','float',None,None,None,0.28,""))
        node.addProperty(Property('camera',name,'fieldofview','float',None,None,None,49.0,""))

    '''
    def addObjectProperties(self,node,subtype):
        name = node.name
        node.clearProperties()

        if subtype == 'ply':
            node.addProperty(Property('objects',name,'material','string',None,None,None,['mat'],"type of material"))
            node.addProperty(Property('objects',name,'ply','string',None,None,None,[''],"mesh path (e.g scenes/luxball/luxball-shell.ply)"))
    '''

    def addObjectProperties(self,node,subtype):
        name = node.name
        node.clearProperties()
        node.props.append(Property('objects',name,'material','link',None,None,None,[''],""))
        node.props.append(Property('objects',name,'shape','link',None,None,None,[''],""))

    def addShapeProperties(self,node,subtype):
        name = node.name
        node.clearProperties()
        node.props.append(Property('shapes',name,'type','option',None,None,None,[subtype],"",ShapesType))

    def addMaterialProperties(self,node,subtype):
        name = node.name
        node.clearProperties()
        node.props.append(Property('materials',name,'type','option',None,None,None,[subtype],"",MaterialsType))
 
    def addTextureProperties(self,node,subtype):
        name = node.name
        node.clearProperties()
        node.props.append(Property('textures',name,'type','option',None,None,None,[subtype],"",TexturesType))
 
    def addVolumeProperties(self,node,subtype):
        name = node.name
        node.clearProperties()
        node.props.append(Property('volumes',name,'type','option',None,None,None,[subtype],"",VolumesType))
 
    def getSceneString(self):
        out = ''
        for node in self.nodes:
            out += node.getPropertyString() + '\n'
        return out


class LuxWidget(QWidget):
    nodeAdded = pyqtSignal()
    updateScene = pyqtSignal()

    def __init__(self,width,height):
        super().__init__()
        self.sg = SceneGraph()
        self.setFixedWidth(self.sg.lux.getWidth())
        self.setFixedHeight(self.sg.lux.getHeight())
        self.enableCameraRotate = False
        self.enableCameraZoom = False
        self.enableCameraMove = False
        self.mouseX = 0.0
        self.mouseY = 0.0
 
    def paintEvent(self,e):
        qp = QPainter()
        qp.begin(self)
        self.drawWidget(qp)
        qp.end()

    def drawWidget(self,qp):
        rect = QRect(0,0,self.width(),self.height())
        image = QImage("image.png")
        qp.drawImage(rect,image)

    def changeSize(self,width,height):
        self.setFixedWidth(width)
        self.setFixedHeight(height)
        self.lux.changeSize(width,height)

    def startRendering(self):
        self.sg.start() 

    def writeImage(self):
        self.sg.write()

    def stopRendering(self):
        self.sg.stop()

    def getTime(self):
        return self.sg.lux.getTime()

    def getPass(self):
        return self.sg.lux.getPass() 

    def getSpp(self):
        return self.sg.lux.getSpp()

    def getTriCount(self):
        return self.sg.lux.getTriCount()

    def setRenderSettings(self):
        self.sg.setRenderSettings()
        self.setFixedWidth(self.sg.lux.getWidth())
        self.setFixedHeight(self.sg.lux.getHeight())

    def wheelEvent(self,e):
        camera = self.sg.getNode('default_camera')
        fov = camera.getProperty('fieldofview')
        fov.value = fov.value + (e.angleDelta().y() * 0.01)
        print("fov=%f"%fov.value)
        self.sg.updateNode(camera)
        self.updateScene.emit()        
        self.repaint()

    def mousePressEvent(self,e):
        self.enableCameraRotate = True 
        self.mouseX = e.x()
        self.mouseY = e.y()

    def mouseReleaseEvent(self,e):
        self.enableCameraRotate = False
        self.enableCameraZoom = False
        self.enableCameraMove = False
        self.mouseX = 0
        self.mouseY = 0

    def mouseMoveEvent(self,e):
        if self.enableCameraRotate:
            dx = self.mouseX - e.x()
            dy = self.mouseY - e.y()
            self.mouseX = e.x()
            self.mouseY = e.y()
            angle = dx*0.1
            self.sg.rotateCamera(angle,(0,0,1)) 


# EDITOR WIDGETS


# Color Widget 
class ColorWidget(QFrame):
    colorChanged = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.colorValue = QFrame()
        self.setFixedWidth(32)
        self.setFrameStyle(QFrame.StyledPanel | QFrame.Plain)
        self.setAutoFillBackground(1)
        self.palette = QPalette()
        self.palette.setColor(QPalette.Window,QColor(255,255,255))
        self.setPalette(self.palette)

    def mousePressEvent(self,e):
        color = QColorDialog(self.palette.color(QPalette.Window)).getColor()
        self.palette.setColor(QPalette.Window,color)
        self.setPalette(self.palette)
        self.colorChanged.emit()

    def getColor(self):
        return self.palette.color(QPalette.Window)
 
    def setColor(self,color):
        self.palette.setColor(QPalette.Window,color)
        self.setPalette(self.palette)


# Link Dialog
class LinkDialog(QDialog):
    linkSelected = pyqtSignal(['QString'])

    def __init__(self,lux,ltype):
        super().__init__()
        self.lux = lux
        self.list = QListWidget() 
        self.link = ""

        vbox = QVBoxLayout()
        vbox.addWidget(self.list)
        self.setLayout(vbox)

        if(ltype == 'shapes'):
            self.list.clear()
            for t in self.lux.sg.getNames('shapes'):
                self.list.addItem(t)

        if(ltype == 'materials'):
            self.list.clear()
            for t in self.lux.sg.getNames('materials'):
                self.list.addItem(t)

        if(ltype == 'textures'):
            self.list.clear()
            for t in self.lux.sg.getNames('textures'):
                self.list.addItem(t)

        if(ltype == 'volumes'):
            self.list.clear()
            for t in self.lux.sg.getNames('volumes'):
                self.list.addItem(t)

        self.show()
        self.list.itemClicked.connect(self.setCurrentLink)

    def setCurrentLink(self,item):
        self.link = item.text()
        self.linkSelected.emit(self.link)
        self.hide()

 
# Texture Attribute
class TextureAttribute(QWidget):
    valueChanged = pyqtSignal()

    def __init__(self,prop,lux):
        super().__init__()
        self.lux = lux
        self.prop = prop
        self.label = QLabel(self.prop.vname)
        self.colorValue = ColorWidget()
        self.colorValue.setFixedWidth(80)
        if self.prop.min is None:
            minVal = -10000000000.0
        else:
            minVal = self.prop.min
        if self.prop.max is None:
            maxVal = 10000000000.0
        else:
            maxVal = self.prop.max
        validator = QDoubleValidator(minVal,maxVal,4)

        self.float3Value = QLineEdit()
        self.float3Value.setValidator(validator)
        self.float3Value.setText('1.0')
        self.float3Value.setFixedHeight(20)
        self.float2Value = QLineEdit()
        self.float2Value.setText('1.0')
        self.float2Value.setValidator(validator)
        self.float2Value.setFixedHeight(20)
        self.float1Value = QLineEdit()
        self.float1Value.setText('1.0')
        self.float1Value.setValidator(validator)
        self.float1Value.setFixedHeight(20)

        hbox = QHBoxLayout()
        hbox.addWidget(self.float1Value)
        hbox.addWidget(self.float2Value)
        hbox.addWidget(self.float3Value)
        hbox.setSpacing(1)
        hbox.setContentsMargins(0,0,0,0)

        floatValue = QFrame()
        floatValue.setLayout(hbox)

        self.linkValue = QPushButton("select")
        self.enableBtn = QPushButton("X")
        self.enableBtn.setFixedWidth(30)
 
        self.stackedValue = QStackedWidget()
        self.stackedValue.setFixedWidth(80)
        self.stackedValue.setFixedHeight(20)
        self.stackedValue.addWidget(self.colorValue)
        self.stackedValue.addWidget(self.linkValue)
        self.stackedValue.addWidget(floatValue)
        self.stackedValue.setCurrentIndex(0)

        self.linkEnabled = 0 # use a color value or a texture link
        self.valueTypeBtn = QPushButton("C") # 'C'=color, 'T'=texture name, '3F'=3 floats, '2F'=2 floats, 'F'=1 float
        self.valueTypeBtn.setFixedWidth(30)
        self.link = None

        if prop.ntype == 'materials':
            if 'vol' in prop.vname:
                self.link = LinkDialog(self.lux,'volumes')
            else:
                self.link = LinkDialog(self.lux,'textures')
        if prop.ntype == 'textures':
            self.link = LinkDialog(self.lux,'textures')
        if prop.ntype == 'objects':
            self.link = LinkDialog(self.lux,'materials')

        self.setToolTip(self.prop.desc)
 
        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(self.label)
        hbox.addWidget(self.stackedValue)
        hbox.addWidget(self.valueTypeBtn)
        hbox.addWidget(self.enableBtn)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        self.colorValue.colorChanged.connect(self.changed) 
        self.float1Value.editingFinished.connect(self.changed)
        self.float2Value.editingFinished.connect(self.changed)
        self.float3Value.editingFinished.connect(self.changed)
        self.linkValue.clicked.connect(self.showLinkDialog)
        self.valueTypeBtn.clicked.connect(self.toggleValueType)
        self.enableBtn.clicked.connect(self.toggleEnabledState)

        if self.link:
            self.link.linkSelected.connect(self.setLink)
            self.link.hide()

        #self.getValue()
        self.setProperty(self.prop)
        
    def toggleEnabledState(self):
        if self.enableBtn.text() == 'X':
            self.enableBtn.setText('O')
            self.prop.enabled = 1 
            self.label.setEnabled(1)
            self.stackedValue.setEnabled(1)
            self.valueTypeBtn.setEnabled(1)
        else:
            self.enableBtn.setText('X')
            self.prop.enabled = 0
            self.label.setEnabled(0)
            self.stackedValue.setEnabled(0)
            self.valueTypeBtn.setEnabled(0)

    def enabled(self):
        return self.label.isEnabled()

    def toggleValueType(self,target=None):
        if (self.valueTypeBtn.text() == 'C' and target is False) or target == 'T':
            self.linkEnabled = 1
            self.stackedValue.setCurrentIndex(1)
            self.valueTypeBtn.setText('T')
            if(self.linkEnabled):
                self.prop.value = [self.linkValue.text()]
            else:
                self.prop.value = [''] 
        elif (self.valueTypeBtn.text() == 'T' and target is False) or target == '3F':
            self.linkEnabled = 0
            self.stackedValue.setCurrentIndex(2)
            self.valueTypeBtn.setText('3F')
            self.float1Value.show()
            self.float2Value.show()
            self.float3Value.show()
            self.prop.value = []
            self.prop.value.insert(0,float(self.float1Value.text()))
            self.prop.value.insert(1,float(self.float2Value.text()))
            self.prop.value.insert(2,float(self.float3Value.text()))
        elif (self.valueTypeBtn.text() == '3F' and target is False) or target == '2F':
            self.valueTypeBtn.setText('2F')
            self.float3Value.hide()
            self.prop.value = []
            self.prop.value.insert(0,float(self.float1Value.text()))
            self.prop.value.insert(1,float(self.float2Value.text()))
        elif (self.valueTypeBtn.text() == '2F' and target is False) or target == 'F':
            self.valueTypeBtn.setText('F')
            self.float2Value.hide()
            self.prop.value = []
            self.prop.value.insert(0,float(self.float1Value.text()))
        elif (self.valueTypeBtn.text() == 'F' and target is False) or target == 'C':
            self.stackedValue.setCurrentIndex(0)
            self.valueTypeBtn.setText('C')
            self.float1Value.hide()
            color = self.colorValue.getColor()
            self.prop.value = []
            self.prop.value = [color.red()/255.0, color.green()/255.0, color.blue()/255.0]

        self.getValue()
        
    def showLinkDialog(self):
        self.link.show()

    def setLink(self,link):
        self.linkValue.setText(link)
        self.changed()

    def changed(self):
        self.getValue() 
        self.valueChanged.emit()

    def changeColorValue(self,e):
        pass

    '''
    def getColorValue(self):
        if(self.linkEnabled):
            self.prop.type = 'string'
            self.prop.value = self.linkValue.text()
        else:
            color = self.colorValue.getColor()
            self.prop.type = 'texture'
            self.prop.value = [color.red()/255.0, color.green()/255.0, color.blue()/255.0]
        return self.prop.value
    '''

    def getValue(self):
        print("GET VALUE")
        print(self.prop.value)
        print(self.linkValue.text())
        if(self.stackedValue.currentIndex() == 0):
            #self.prop.vtype = 'texture'
            color = self.colorValue.getColor()
            self.prop.value = [color.red()/255.0, color.green()/255.0, color.blue()/255.0]
        elif(self.stackedValue.currentIndex() == 1):
            #self.prop.vtype = 'string'
            if(self.linkEnabled):
                self.prop.value = [self.linkValue.text()]
            else:
                self.prop.enabled = 0
        elif(self.stackedValue.currentIndex() == 2):
            #self.prop.vtype = 'texture'
            print("PREVALUES: %f %f %f"%(float(self.float1Value.text()),float(self.float2Value.text()),float(self.float3Value.text())))     
            print(self.prop.value)
            if len(self.prop.value) == 1:
                self.prop.value[0] = float(self.float1Value.text())
                print("VALUES: %f"%(float(self.float1Value.text())))     
            elif len(self.prop.value) == 2:
                self.prop.value[0] = float(self.float1Value.text())
                self.prop.value[1] = float(self.float2Value.text())
                print("VALUES: %f %f"%(float(self.float1Value.text()),float(self.float2Value.text())))     
            elif len(self.prop.value) == 3:
                self.prop.value[0] = float(self.float1Value.text())
                self.prop.value[1] = float(self.float2Value.text())
                self.prop.value[2] = float(self.float3Value.text())
                print("VALUES: %f %f %f"%(float(self.float1Value.text()),float(self.float2Value.text()),float(self.float3Value.text())))     

    def setProperty(self,prop):
        self.prop = prop
        print("SETTING VALUE FOR %s"%prop.vname)
        print(prop.value)
        print(prop.value[0])
        if type(self.prop.value[0]) is 'str'.__class__ and len(self.prop.value) == 1:
            self.linkEnabled = 1
            self.linkValue.setText(self.prop.value[0])
            self.toggleValueType('T')
            self.stackedValue.setCurrentIndex(1)
            return
 
        if(self.stackedValue.currentIndex() == 0):
            print("colorValue = %f %f %f"%(self.prop.value[0],self.prop.value[1],self.prop.value[2]))
            self.colorValue.setColor(QColor(255.0 * float(self.prop.value[0]), 255.0 * float(self.prop.value[1]), 255.0 * float(self.prop.value[2])))
        elif(self.stackedValue.currentIndex() == 1):
            self.linkValue.setText(self.prop.value[0])
        elif(self.stackedValue.currentIndex() == 2):
            if len(self.props.value) == 1:
                self.float1Value.setText(self.props.value[0])
            elif len(self.props.value) == 2:
                self.float1Value.setText(self.props.value[0])
                self.float2Value.setText(self.props.value[1])
            elif len(self.props.value) == 3:
                self.float1Value.setText(self.props.value[0])
                self.float2Value.setText(self.props.value[1])
                self.float3Value.setText(self.props.value[2])

        # verify that the enable btn is synced up the enabled state of the property
        if self.prop.enabled:
            self.enableBtn.setText('O')
            self.label.setEnabled(1)
            self.stackedValue.setEnabled(1)
            self.valueTypeBtn.setEnabled(1)
        else:
            self.enableBtn.setText('X')
            self.label.setEnabled(0)
            self.stackedValue.setEnabled(0)
            self.valueTypeBtn.setEnabled(0)
 

# Option Attribute
class OptionAttribute(QWidget):
    valueChanged = pyqtSignal()

    def __init__(self,prop,options=None):
        super().__init__()
        self.prop = prop
        self.label = QLabel(self.prop.vname)
        self.value = QComboBox()

        self.setToolTip(self.prop.desc)

        match = False

        if options is not None: 
            for item in options:
                self.value.addItem(item)
                if self.prop.value[0] == item:
                    self.value.setCurrentText(item)
                    match = True
            # set the default to the first item in the list
            if match is not True:
                self.prop.value[0] = self.value.currentText()
        else:
            if self.prop.ntype == 'materials' or self.prop.ntype == 'textures' or self.prop.ntype == 'volumes':
                for item in self.prop.types:
                    self.value.addItem(item)

        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(self.label)
        hbox.addWidget(self.value)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        self.value.setCurrentText(self.prop.value[0])        
        self.value.currentIndexChanged.connect(self.changed)

        #self.prop.value[0] = self.value.currentText()
        self.value.setCurrentText(self.prop.value[0]) 
  
    def enabled(self):
        return self.label.isEnabled()

    def changed(self,index):
        self.prop.value[0] = self.value.currentText()
        self.valueChanged.emit()

    def getValue(self):
        return self.value.currentText()

    def setValue(self,val):
        self.prop.setValue(val)
        return self.value.setCurrentText(val)

    def getIndex(self):
        return self.value.currentIndex()       

    def setProperty(self,prop):
        self.prop = prop
        self.value.setCurrentText(self.prop.value[0])


# Int Attribute
class IntAttribute(QWidget):
    valueChanged = pyqtSignal()

    def __init__(self,prop):
        super().__init__()
        self.prop = prop
        self.label = QLabel(self.prop.vname)
        self.value = QLineEdit()
        self.value.setFixedWidth(80)
        if self.prop.min is not None and self.prop.max is not None:
            self.validator = QIntValidator(self.prop.min,self.prop.max)
            self.value.setValidator(self.validator)
        self.value.setText("%d"%self.prop.value)

        self.setToolTip(self.prop.desc)
       
        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(self.label)
        hbox.addWidget(self.value)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        # connections
        self.value.editingFinished.connect(self.changed)


    def enabled(self):
        return self.label.isEnabled()

    def changed(self):
        self.prop.value = int(self.value.text())
        self.valueChanged.emit()

    def getValue(self):
        return int(self.prop.value)

    def setValue(self,val):
        self.prop.value = val
        self.value.setText("%d"%val)

    def setProperty(self,prop):
        self.prop = prop
        self.value.setText(self.prop.value[0])


# Float Attribute
class FloatAttribute(QWidget):
    valueChanged = pyqtSignal()


    def __init__(self,prop):
        super().__init__()
        self.prop = prop
        self.label = QLabel(self.prop.vname)
        self.value = QLineEdit()
        self.value.setFixedWidth(80)
        self.validator = QDoubleValidator()
        if self.prop.min is not None and self.prop.max is not None:
            self.validator.setRange(self.prop.min,self.prop.max,4)
        else:
            self.validator.setDecimals(4)
        self.value.setValidator(self.validator)
 
        self.value.setText("%.4f"%self.prop.value)

        self.setToolTip(self.prop.desc)
       
        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(self.label)
        hbox.addWidget(self.value)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        # connections
        self.value.editingFinished.connect(self.changed)

    def enabled(self):
        return self.label.isEnabled()

    def changed(self):
        self.prop.value = float(self.value.text())
        self.valueChanged.emit()

    def getValue(self):
        return float(self.prop.value)

    def setValue(self,val):
        self.prop.value = val
        self.value.setText("%.4f"%val)

    def loadProperty(self):
        self.value.setText(self.prop.value[0])

    def setProperty(self,prop):
        self.prop = prop
        self.value.setText(self.prop.value[0])


# Point Attribute
class UVAttribute(QWidget):
    valueChanged = pyqtSignal()

    def __init__(self,prop):
        super().__init__()
        self.prop = prop
        self.label = QLabel(self.prop.vname)
        self.uvalue = QLineEdit()
        self.vvalue = QLineEdit()
        self.uvalue.setFixedWidth(60)
        self.vvalue.setFixedWidth(60)

        self.validator = QDoubleValidator()
        if self.prop.min is not None and self.prop.max is not None:
            self.validator.setRange(self.prop.min,self.prop.max,4)
        else:
            self.validator.setDecimals(4)
        self.uvalue.setValidator(self.validator)
        self.vvalue.setValidator(self.validator)
 
        self.uvalue.setText("%.4f"%self.prop.value[0])
        self.vvalue.setText("%.4f"%self.prop.value[1])

        self.setToolTip(self.prop.desc)
       
        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(self.label)
        hbox.addWidget(self.uvalue)
        hbox.addWidget(self.vvalue)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        # connections
        self.uvalue.editingFinished.connect(self.changed)
        self.vvalue.editingFinished.connect(self.changed)

    def enabled(self):
        return self.label.isEnabled()

    def changed(self):
        self.prop.value[0] = float(self.uvalue.text())
        self.prop.value[1] = float(self.vvalue.text())
        self.valueChanged.emit()

    def getValue(self):
        return [float(self.prop.value[0]), float(self.prop.value[1])]

    def setValue(self,val):
        self.prop.value = val
        self.uvalue.setText("%.4f"%val[0])
        self.vvalue.setText("%.4f"%val[1])

    def loadProperty(self):
        self.uvalue.setText(self.prop.value[0])
        self.vvalue.setText(self.prop.value[1])

    def setProperty(self,prop):
        self.prop = prop
        self.uvalue.setText(self.prop.value[0])
        self.vvalue.setText(self.prop.value[1])


# Point Attribute
class PointAttribute(QWidget):
    valueChanged = pyqtSignal()


    def __init__(self,prop):
        super().__init__()
        self.prop = prop
        self.label = QLabel(self.prop.vname)
        self.xvalue = QLineEdit()
        self.yvalue = QLineEdit()
        self.zvalue = QLineEdit()
        self.xvalue.setFixedWidth(60)
        self.yvalue.setFixedWidth(60)
        self.zvalue.setFixedWidth(60)

        self.validator = QDoubleValidator()
        if self.prop.min is not None and self.prop.max is not None:
            self.validator.setRange(self.prop.min,self.prop.max,4)
        else:
            self.validator.setDecimals(4)
        self.xvalue.setValidator(self.validator)
        self.yvalue.setValidator(self.validator)
        self.zvalue.setValidator(self.validator)
 
        self.xvalue.setText("%.4f"%self.prop.value[0])
        self.yvalue.setText("%.4f"%self.prop.value[1])
        self.zvalue.setText("%.4f"%self.prop.value[2])

        self.setToolTip(self.prop.desc)
       
        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(self.label)
        hbox.addWidget(self.xvalue)
        hbox.addWidget(self.yvalue)
        hbox.addWidget(self.zvalue)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        # connections
        self.xvalue.editingFinished.connect(self.changed)
        self.yvalue.editingFinished.connect(self.changed)
        self.zvalue.editingFinished.connect(self.changed)

    def enabled(self):
        return self.label.isEnabled()

    def changed(self):
        self.prop.value[0] = float(self.xvalue.text())
        self.prop.value[1] = float(self.yvalue.text())
        self.prop.value[2] = float(self.zvalue.text())
        self.valueChanged.emit()

    def getValue(self):
        return [float(self.prop.value[0]), float(self.prop.value[1]), float(self.prop.value[2])]

    def setValue(self,val):
        self.prop.value = val
        self.xvalue.setText("%.4f"%val[0])
        self.yvalue.setText("%.4f"%val[1])
        self.zvalue.setText("%.4f"%val[2])

    def loadProperty(self):
        self.xvalue.setText(self.prop.value[0])
        self.yvalue.setText(self.prop.value[1])
        self.zvalue.setText(self.prop.value[2])

    def setProperty(self,prop):
        self.prop = prop
        self.xvalue.setText(self.prop.value[0])
        self.yvalue.setText(self.prop.value[1])
        self.zvalue.setText(self.prop.value[2])


# String Attribute
class StringAttribute(QWidget):
    valueChanged = pyqtSignal()

    def __init__(self,prop):
        super().__init__()
        self.prop = prop
        self.label = QLabel(self.prop.vname)
        self.value = QLineEdit()
        self.value.setFixedWidth(80)
        self.value.setText(self.prop.value[0])

        self.setToolTip(self.prop.desc)
       
        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(self.label)
        hbox.addWidget(self.value)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        # connections
        self.value.editingFinished.connect(self.changed)

    def enabled(self):
        return self.label.isEnabled()

    def changed(self):
        self.prop.value = self.value.text()
        self.valueChanged.emit()

    def getValue(self):
        return self.prop.value

    def setValue(self,val):
        self.prop.value = val
        self.value.setText(val)

    def setProperty(self,prop):
        self.prop = prop
        self.value.setText(self.prop.value[0])


# Link Attribute
class LinkAttribute(QWidget):
    valueChanged = pyqtSignal()

    def __init__(self,prop,lux):
        super().__init__()
        self.prop = prop
        self.lux = lux
        self.label = QLabel(self.prop.vname)
        self.value = QPushButton()
        self.value.setFixedWidth(180)
        self.value.setText(self.prop.value[0])

        self.link = None

        if prop.ntype == 'materials':
            if 'vol' in prop.vname:
                self.link = LinkDialog(self.lux,'volumes')
            else:
                self.link = LinkDialog(self.lux,'textures')
        if prop.ntype == 'textures':
            self.link = LinkDialog(self.lux,'textures')
        if prop.ntype == 'objects':
            if 'material' in prop.vname:
                self.link = LinkDialog(self.lux,'materials')
            else:
                self.link = LinkDialog(self.lux,'shapes')

        self.setToolTip(self.prop.desc)
       
        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(self.label)
        hbox.addWidget(self.value)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        # connections
        self.value.clicked.connect(self.showLinkDialog)

        if self.link:
            self.link.linkSelected.connect(self.setLink)
            self.link.hide()

    def showLinkDialog(self):
        self.link.show()

    def setLink(self,link):
        self.setValue(link)
        self.changed()

    def enabled(self):
        return self.label.isEnabled()

    def changed(self):
        #self.prop.value = self.value.text()
        self.valueChanged.emit()

    def getValue(self):
        return self.prop.value

    def setValue(self,val):
        self.prop.value[0] = val
        self.value.setText(val)

    def setProperty(self,prop):
        self.prop = prop
        self.value.setText(self.prop.value[0])


# File Attribute
class FileAttribute(QWidget):
    valueChanged = pyqtSignal()

    def __init__(self,prop):
        super().__init__()
        self.prop = prop
        label = QLabel(self.prop.vname)
        self.value = QPushButton("browse")
        if len(self.prop.value) > 0:
            self.value.setText(self.prop.value[0])
        self.value.setFixedWidth(150)
        #self.value.setText(self.prop.value[0])
 
        self.setToolTip(self.prop.desc)
              
        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(label)
        hbox.addWidget(self.value)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        # connections
        self.value.clicked.connect(self.getFile)

    def getFile(self):
        if self.prop.vname == 'ply':
            filename = QFileDialog.getOpenFileName(self,"Open Mesh",".","Mesh Files (*.ply *.stl)")
        elif self.prop.vname == 'mapfile':
            filename = QFileDialog.getOpenFileName(self,"Open Light Map",".","Map Files (*.map)")
        elif self.prop.vname == 'iesfile':
            filename = QFileDialog.getOpenFileName(self,"Open IES Profile",".","IES Files (*.ies)")
        elif self.prop.ntype == 'textures' and self.prop.vname == 'file':
            filename = QFileDialog.getOpenFileName(self,"Open Image File",".","Image Files (*.png)")
        self.value.setText(filename[0])
        self.prop.value[0] = self.value.text()
        self.valueChanged.emit()

    def getValue(self):
        return self.prop.value

    def setValue(self,val):
        self.prop.value = val
        self.value.setText(val)

    def setProperty(self,prop):
        self.prop = prop
        self.value.setText(self.prop.value[0])

# DOCKS

# ATTRIBUTE EDITOR DOCK
     
# NODE ATTRIBUTE LOADER
class NodeAttributeLoader(QWidget):
    attributeChanged = pyqtSignal()

    def __init__(self,lux,node):
        super().__init__()
        self.vbox = QVBoxLayout(self)
        self.vbox.setContentsMargins(0,0,0,0)
        self.vbox.setSpacing(0)
        self.lux = lux
        self.setLayout(self.vbox)
        self.node = None

    def clearPanel(self):
        for i in reversed(range(self.vbox.count())):
            item = self.vbox.itemAt(i)
            widget = self.vbox.itemAt(i).widget()
            self.vbox.removeItem(item)
            self.vbox.removeWidget(widget)
            widget.hide()
            self.vbox.update()
        self.vbox.invalidate()

    def load(self,node):
        self.node = node 

        print("LOADING NODE %s"%node.name)
        for prop in node.props:
            print("prop name %s"%prop.vname)

        self.clearPanel()

        props = self.node.getProperties()
        for prop in props:
            if prop.vtype is 'file':
                attribute = FileAttribute(prop)
                attribute.valueChanged.connect(self.updateNode)
                self.vbox.addWidget(attribute)
            if prop.vtype is 'option':
                attribute = OptionAttribute(prop)
                if prop.vname == 'type':
                    attribute.valueChanged.connect(self.setType)
                else: 
                    attribute.valueChanged.connect(self.updateNode)
                self.vbox.addWidget(attribute)
            if prop.vtype is 'link':
                attribute = LinkAttribute(prop,self.lux)
                attribute.valueChanged.connect(self.updateNode)
                self.vbox.addWidget(attribute)
            if prop.vtype is 'string':
                # is it a type option?
                if 'type' in prop.vname:
                    attribute = OptionAttribute(prop)
                    attribute.valueChanged.connect(self.setType)
                    self.subtype = prop.value[0]
                    self.vbox.addWidget(attribute)
                elif 'material' in prop.vname:
                    matlist = self.lux.sg.getNames('materials')
                    attribute = OptionAttribute(prop,matlist)
                    attribute.valueChanged.connect(self.updateNode)
                    self.vbox.addWidget(attribute)
                elif prop.vname is 'ply':
                    attribute = FileAttribute(prop)
                    attribute.valueChanged.connect(self.updateNode)
                    self.subtype = 'ply'
                    self.vbox.addWidget(attribute)
                elif prop.vname is 'file' or prop.vname is 'iesfile' or prop.vname is 'mapfile':
                    attribute = FileAttribute(prop)
                    attribute.valueChanged.connect(self.updateNode)
                    self.vbox.addWidget(attribute)
                else:
                    attribute = StringAttribute(prop)
                    attribute.valueChanged.connect(self.updateNode)
                    self.vbox.addWidget(attribute)
            elif prop.vtype is 'int':
                attribute = IntAttribute(prop)
                attribute.valueChanged.connect(self.updateNode)
                self.vbox.addWidget(attribute)        
            elif prop.vtype is 'float':
                attribute = FloatAttribute(prop)
                attribute.valueChanged.connect(self.updateNode)
                self.vbox.addWidget(attribute)        
            elif prop.vtype is 'uv':
                attribute = UVAttribute(prop)
                attribute.valueChanged.connect(self.updateNode)
                self.vbox.addWidget(attribute)        
            elif prop.vtype is 'point':
                attribute = PointAttribute(prop)
                attribute.valueChanged.connect(self.updateNode)
                self.vbox.addWidget(attribute)        
            elif prop.vtype is 'vector':
                attribute = PointAttribute(prop)
                attribute.valueChanged.connect(self.updateNode)
                self.vbox.addWidget(attribute)        
            elif prop.vtype is 'texture':
                attribute = TextureAttribute(prop,self.lux)
                attribute.valueChanged.connect(self.updateNode)
                self.vbox.addWidget(attribute)        
            elif prop.vtype is 'spectrum':
                attribute = FloatAttribute(prop)
                attribute.valueChanged.connect(self.updateNode)
                self.vbox.addWidget(attribute)        
 
    def updateNode(self):
        name = self.node.name
        ntype = self.node.ntype
        self.lux.sg.updateNode(self.node)
        #self.node = self.lux.sg.addSceneNode(name,ntype,self.subtype)
        #self.load(self.node)

    def setType(self):
        self.clearPanel()
        props = self.node.getProperties()
        for prop in props:
            if prop.vname == 'type':
                self.subtype = prop.value[0]
        self.node = self.lux.sg.addSceneNode(self.node.name,self.node.ntype,self.subtype)
        self.updateNode()
        self.load(self.node)

# NODE EDITOR DOCK

class NodeEditor(QDockWidget):
    nodeChanged = pyqtSignal()

    def __init__(self,lux):
        super().__init__()
        self.setFeatures(QDockWidget.DockWidgetFloatable | QDockWidget.DockWidgetMovable)
        self.lux = lux
        self.setWindowTitle("Node Editor")
        self.label = QLabel("----")
        self.label.setFont(QFont("Sans",12))
        self.label.setAlignment(Qt.AlignCenter)
        self.label.setFrameStyle(QFrame.Panel | QFrame.Raised)
        palette = QPalette()
        palette.setColor(QPalette.Base,QColor(1,0,0))
        self.label.setPalette(palette)
        self.attributes = NodeAttributeLoader(self.lux,None)
        self.node = None

        frame = QFrame()

        self.vbox = QVBoxLayout()
        self.vbox.addWidget(self.label)
        self.vbox.addWidget(self.attributes)
        self.vbox.addStretch()
        self.vbox.setContentsMargins(0,0,0,0)
        self.vbox.setSpacing(0)

        frame.setLayout(self.vbox)
        self.setWidget(frame)
        
        self.attributes.attributeChanged.connect(self.nodeUpdate)
        #self.attributes.typeChanged.connect(self.nodeUpdate)


    def load(self):
        print("load()")
        self.node = self.lux.sg.getNode(name)
        self.attributes.load(self.node)

    def setEditor(self,name):
        print("setEditor()")
        self.label.setText(name)
        self.node = self.lux.sg.getNode(name)
        self.attributes.load(self.node)

    def clear(self):
        self.attributes.clearPanel()
        self.attributes.node = None
        self.label.setText('----')

    def nodeUpdate(self):
        pass
        #self.node = self.attributes.node
        #self.attributes.load(self.node)
        #self.lux.sg.lux.setProperties(self.node.getPropertyString())
        #self.nodeChanged.emit()
 

# RENAM DIALOG
class RenameNodeDialog(QDialog):
    nodeRenamed = pyqtSignal(['QString','QString'])

    def __init__(self):
        super().__init__()
        #self.setFixedWidth(400)
        #self.setFixedHeight(400)
        self.setWindowTitle("Rename Node")
    
        self.name = QLabel()
        self.newname = QLineEdit()

        self.renameBtn = QPushButton("Rename")
        self.cancelBtn = QPushButton("Cancel")
        
        gbox = QGridLayout()
        gbox.addWidget(QLabel("old:"),0,0)
        gbox.addWidget(QLabel("new:"),1,0)
        gbox.addWidget(self.name,0,1)
        gbox.addWidget(self.newname,1,1)
        vbox = QVBoxLayout()
        vbox.addLayout(gbox)
        vbox.addWidget(self.renameBtn)
        vbox.addWidget(self.cancelBtn)
        self.setLayout(vbox)

        self.renameBtn.clicked.connect(self.renameNode)
        self.cancelBtn.clicked.connect(self.reject)
        self.hide()
    
    def setCurrentName(self,name):
        self.name.setText(name)

    def renameNode(self):
        self.nodeRenamed.emit(self.name.text(),self.newname.text())
        self.hide()


# ADD DIALOG
class AddNodeDialog(QDialog):
    nodeAdded = pyqtSignal(['QString','QString','QString'])

    def __init__(self,ntype):
        super().__init__()
        #self.setFixedWidth(400)
        #self.setFixedHeight(400)
        self.setWindowTitle("Add Node")
        self.name = QLineEdit()
        self.vtype = QComboBox()

        self.addBtn = QPushButton("Add")
        self.cancelBtn = QPushButton("Cancel")
        self.ntype = ntype
        
        gbox = QGridLayout()
        gbox.addWidget(QLabel("name:"),0,0)
        gbox.addWidget(QLabel("type:"),1,0)
        gbox.addWidget(self.name,0,1)
        gbox.addWidget(self.vtype,1,1)
        vbox = QVBoxLayout()
        vbox.addLayout(gbox)
        vbox.addWidget(self.addBtn)
        vbox.addWidget(self.cancelBtn)
        self.setLayout(vbox)

        self.setType(self.ntype)
        self.addBtn.clicked.connect(self.setNode)
        self.cancelBtn.clicked.connect(self.reject)
        self.hide()

    def setType(self,ntype):
        self.ntype = ntype
        self.vtype.clear() 
        if self.ntype == 'camera':
            pass
        if self.ntype == 'shapes':
            self.vtype.show()
            for s in ShapesType:
                self.vtype.addItem(s)
        if self.ntype == 'objects':
            self.vtype.hide()
        if self.ntype == 'materials':
            self.vtype.show()
            for m in MaterialsType:
                self.vtype.addItem(m)
        if self.ntype == 'textures':
            self.vtype.show()
            for t in TexturesType:
                self.vtype.addItem(t)
        if self.ntype == 'volumes':
            self.vtype.show()
            for v in VolumesType:
                self.vtype.addItem(v)


    def setNode(self):
        self.nodeAdded.emit(self.name.text(),self.ntype,self.vtype.currentText())
        self.hide()


# SCENE LAYOUT DOCK

class SceneLayout(QDockWidget):
    nodeSelected = pyqtSignal(['QString'])
    nodeRemoved = pyqtSignal()
 
    def __init__(self,lux):
        super().__init__()
        self.setFeatures(QDockWidget.DockWidgetFloatable | QDockWidget.DockWidgetMovable)
        self.lux = lux
        self.setWindowTitle("Scene Layout")
        self.selectedName = None
        
        frame = QFrame(self)
        self.tabs = QTabWidget()
        self.cameras = QListWidget()
        self.objects = QListWidget()
        self.shapes= QListWidget()
        self.materials = QListWidget()
        self.textures = QListWidget()
        self.lights = QListWidget()
        self.volumes= QListWidget()
        self.addBtn = QPushButton("+")
        self.removeBtn = QPushButton("-")
        self.renameBtn = QPushButton("rename")

        self.tabs.addTab(self.cameras,"C")
        self.tabs.addTab(self.objects,"O")
        self.tabs.addTab(self.shapes,"S")
        self.tabs.addTab(self.materials,"M")
        self.tabs.addTab(self.textures, "T")
        self.tabs.addTab(self.lights, "L")
        self.tabs.addTab(self.volumes, "V")
        self.tabs.setTabPosition(QTabWidget.North)

        hbox = QHBoxLayout()
        hbox.addWidget(self.renameBtn)
        hbox.addWidget(self.addBtn)
        hbox.addWidget(self.removeBtn)

        vbox = QVBoxLayout(self) 
        frame.setLayout(vbox)
        vbox.addWidget(self.tabs)
        vbox.addLayout(hbox)

        self.setWidget(frame)

        self.addNodeDialog = AddNodeDialog(self.getTabName(self.tabs.currentIndex()))
        self.renameNodeDialog = RenameNodeDialog()

        self.cameras.itemClicked.connect(self.nodeChanged)
        self.objects.itemClicked.connect(self.nodeChanged)
        self.shapes.itemClicked.connect(self.nodeChanged)
        self.materials.itemClicked.connect(self.nodeChanged)
        self.textures.itemClicked.connect(self.nodeChanged)
        self.lights.itemClicked.connect(self.nodeChanged)
        self.volumes.itemClicked.connect(self.nodeChanged)
        
        self.renameBtn.clicked.connect(self.rename)
        self.addBtn.clicked.connect(self.add)
        self.removeBtn.clicked.connect(self.remove)
        self.addNodeDialog.nodeAdded.connect(self.addNode)
        self.renameNodeDialog.nodeRenamed.connect(self.renameNode)
        
        self.updateTabs()

    def addNode(self,name,ntype,vtype):
        print("%s, %s, %s node to add"%(name,ntype,vtype))
        self.lux.sg.addSceneNode(name,ntype,vtype)
        self.updateTabs()

    def getTabName(self,i):
        name = None
        if self.tabs.currentIndex() == 0:
            name = 'camera'
        elif self.tabs.currentIndex() == 1:
            name = 'objects'
        elif self.tabs.currentIndex() == 2:
            name = 'shapes'
        elif self.tabs.currentIndex() == 3:
            name = 'materials'
        elif self.tabs.currentIndex() == 4:
            name = 'textures'
        elif self.tabs.currentIndex() == 5:
            name = 'lights'
        elif self.tabs.currentIndex() == 6:
            name = 'volumes'
        return name

    def add(self):
        self.addNodeDialog.setType(self.getTabName(self.tabs.currentIndex()))
        self.addNodeDialog.exec()
        self.updateTabs()

    def remove(self):
        self.lux.sg.removeNode(self.selectedName)
        self.selectedName = None
        self.updateTabs()
        self.nodeRemoved.emit()

    def rename(self):
        self.renameNodeDialog.setCurrentName(self.selectedName)
        self.renameNodeDialog.exec()
 
    def renameNode(self,cname,nname):
        self.lux.sg.renameNode(cname,nname)
        self.selectedName = nname
        self.updateTabs()
        self.nodeRemoved.emit() 

    def updateTabs(self):
        # Objects
        print("updateTabs")

        # Cameras
        self.cameras.clear()
        for c in self.lux.sg.getNames('camera'):
            self.cameras.addItem(c)

        # Objects
        self.objects.clear()
        for o in self.lux.sg.getNames('objects'):
            self.objects.addItem(o)

        # Shapes
        self.shapes.clear()
        for s in self.lux.sg.getNames('shapes'):
            self.shapes.addItem(s)

        # Materials
        self.materials.clear()
        for m in self.lux.sg.getNames('materials'):
            self.materials.addItem(m)

        # Textures 
        self.textures.clear()
        for t in self.lux.sg.getNames('textures'):
            self.textures.addItem(t)

        # Lights 
        self.lights.clear()
        for l in self.lux.sg.getNames('lights'):
            self.lights.addItem(l)

        # Volumes 
        self.volumes.clear()
        for v in self.lux.sg.getNames('volumes'):
            self.volumes.addItem(v)

    def nodeChanged(self,item):
        self.selectedName = item.text()
        self.nodeSelected.emit(item.text())


# FILM EDITOR 

class FilmEditor(QDockWidget):

    def __init__(self,lux):
        super().__init__()
        self.setFeatures(QDockWidget.DockWidgetFloatable | QDockWidget.DockWidgetMovable)
        self.lux = lux
        self.setWindowTitle("Film")


# RENDER SETTINGS

class RenderSettings(QDockWidget):
    objectSelected = pyqtSignal(['QString'])

    def __init__(self,lux):
        super().__init__()
        self.setFeatures(QDockWidget.DockWidgetFloatable | QDockWidget.DockWidgetMovable)
        self.lux = lux
        self.setWindowTitle("Render Settings")
        #self.setFixedWidth(420)

        self.props = self.lux.sg.lux.getRenderSettings()

        self.preset = QComboBox()
        self.preset.addItem("custom")
        self.preset.addItem("4:3 low res")
        self.preset.addItem("1:79 low res")
        self.preset.addItem("2.39 low res")
        self.preset.addItem("4:3 med res")
        self.preset.addItem("1:79 med res")
        self.preset.addItem("2.39 med res")
        self.preset.addItem("4:3 hd")
        self.preset.addItem("1:79 hd")
        self.preset.addItem("2.39 hd")
        self.preset.addItem("4:3 4k")
        self.preset.addItem("1:79 4k")
        self.preset.addItem("2.39 4k")

        self.scrollarea = QScrollArea(self)
        self.scrollarea.setWidgetResizable(1)
        self.scrollarea.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.scrollarea.setSizeAdjustPolicy(QAbstractScrollArea.AdjustToContents)

        self.frame = QFrame()

        self.renderWidth = IntAttribute(self.lux.sg.getRenderProperty('film','width'))
        self.renderHeight = IntAttribute(self.lux.sg.getRenderProperty('film','height'))

        # Engine 
        self.engine = QGroupBox('engine')
        self.enginevbox = QVBoxLayout()
        self.enginevbox.setContentsMargins(0,0,0,0)
        self.enginevbox.setSpacing(0)
        self.engine.setLayout(self.enginevbox)
 
        # Sampler
        self.sampler = QGroupBox('sampler')
        self.samplervbox = QVBoxLayout()
        self.samplervbox.setContentsMargins(0,0,0,0)
        self.samplervbox.setSpacing(0)
        self.sampler.setLayout(self.samplervbox)
  
        # Filter 
        self.filter = QGroupBox('filter')
        self.filtervbox = QVBoxLayout()
        self.filtervbox.setContentsMargins(0,0,0,0)
        self.filtervbox.setSpacing(0)
        self.filter.setLayout(self.filtervbox)
 
        vbox = QVBoxLayout()
        vbox.addWidget(QLabel("Presets"))
        vbox.addWidget(self.preset)
        vbox.addWidget(self.renderWidth)
        vbox.addWidget(self.renderHeight)
        vbox.addWidget(self.engine)
        vbox.addWidget(self.sampler)
        vbox.addWidget(self.filter)
        vbox.addStretch()
        vbox.setSpacing(0)

        self.frame.setLayout(vbox)
        self.scrollarea.setWidget(self.frame)
        self.setWidget(self.scrollarea)

        self.renderWidth.valueChanged.connect(self.updateSettings)
        self.renderHeight.valueChanged.connect(self.updateSettings)

        self.updateEngine()
        self.updateSampler()
        self.updateFilter()


    def clearRenderEnginePanel(self):
        for i in reversed(range(self.enginevbox.count())):
            item = self.enginevbox.itemAt(i)
            widget = self.enginevbox.itemAt(i).widget()
            self.enginevbox.removeItem(item)
            self.enginevbox.removeWidget(widget)
            widget.hide()
            self.enginevbox.update()
        self.enginevbox.invalidate()
 
    def clearRenderSamplerPanel(self):
        for i in reversed(range(self.samplervbox.count())):
            item = self.samplervbox.itemAt(i)
            widget = self.samplervbox.itemAt(i).widget()
            self.samplervbox.removeItem(item)
            self.samplervbox.removeWidget(widget)
            widget.hide()
            self.samplervbox.update()
        self.samplervbox.invalidate()
 
    def clearRenderFilterPanel(self):
        for i in reversed(range(self.filtervbox.count())):
            item = self.filtervbox.itemAt(i)
            widget = self.filtervbox.itemAt(i).widget()
            self.filtervbox.removeItem(item)
            self.filtervbox.removeWidget(widget)
            widget.hide()
            self.filtervbox.update()
        self.filtervbox.invalidate()
         
    def updateEngine(self):
        self.clearRenderEnginePanel()

        engineType = OptionAttribute(self.lux.sg.getRenderProperty('renderengine','type'),['PATHCPU','BIASPATHCPU','BIDIRCPU','PATHOCL','RTPATHOCL','BIASPATHOCL','RTBIASPATHOCL'])
        engineType.valueChanged.connect(self.updateEngine)
        self.enginevbox.addWidget(engineType)

        node = None

        if engineType.getValue() == 'PATHCPU':
            node = self.lux.sg.getRenderNode('path')
        elif engineType.getValue() == 'BIASPATHCPU':
            node = self.lux.sg.getRenderNode('biaspath')
        elif engineType.getValue() == 'BIDIRCPU':
            node = self.lux.sg.getRenderNode('bidir')
        elif engineType.getValue() == 'PATHOCL':
            node = self.lux.sg.getRenderNode('pathocl')
        elif engineType.getValue() == 'RTPATHOCL':
            node = self.lux.sg.getRenderNode('rtpath')
        elif engineType.getValue() == 'BIASPATHOCL':
            node = self.lux.sg.getRenderNode('biaspathocl')
        elif engineType.getValue() == 'RTBIASPATHOCL':
            node = self.lux.sg.getRenderNode('rtbiaspathocl')

        if node is None:
            return 

        for prop in node.props:
            if prop.vtype is 'string':
                # is it a type option?
                if prop.vname is 'type':
                    attribute = OptionAttribute(prop)
                    attribute.valueChanged.connect(self.updateSettings)
                    self.subtype = prop.value[0]
                    self.enginevbox.addWidget(attribute)
                else:
                    attribute = StringAttribute(prop)
                    attribute.valueChanged.connect(self.updateSettings)
                    self.enginevbox.addWidget(attribute)
            if prop.vtype is 'int':
                attribute = IntAttribute(prop)
                attribute.valueChanged.connect(self.updateSettings)
                self.enginevbox.addWidget(attribute)        
            if prop.vtype is 'float':
                attribute = FloatAttribute(prop)
                attribute.valueChanged.connect(self.updateSettings)
                self.enginevbox.addWidget(attribute)        
            '''
            if prop.vtype is 'texture':
                attribute = TextureAttribute(prop,self.lux)
                attribute.valueChanged.connect(self.updateNode)
                self.enginevbox.addWidget(attribute)        
            if prop.vtype is 'spectrum':
                attribute = FloatAttribute(prop)
                attribute.valueChanged.connect(self.updateNode)
                self.enginevbox.addWidget(attribute)        
            '''
        self.updateSettings()

    def updateSampler(self):
        self.clearRenderSamplerPanel()

        samplerType = OptionAttribute(self.lux.sg.getRenderProperty('sampler','type'),['SOBOL','METROPOLIS','RANDOM'])
        samplerType.valueChanged.connect(self.updateSampler)
        self.samplervbox.addWidget(samplerType)

        node = None

        if samplerType.getValue() == 'METROPOLIS':
            node = self.lux.sg.getRenderNode('sampler.metropolis')

        if node is None:
            return 

        for prop in node.props:
            if prop.vtype is 'string':
                # is it a type option?
                if prop.vname is 'type':
                    attribute = OptionAttribute(prop)
                    attribute.valueChanged.connect(self.updateSettings)
                    self.subtype = prop.value[0]
                    self.samplervbox.addWidget(attribute)
                else:
                    attribute = StringAttribute(prop)
                    attribute.valueChanged.connect(self.updateSettings)
                    self.samplervbox.addWidget(attribute)
            if prop.vtype is 'int':
                attribute = IntAttribute(prop)
                attribute.valueChanged.connect(self.updateSettings)
                self.samplervbox.addWidget(attribute)        
            if prop.vtype is 'float':
                attribute = FloatAttribute(prop)
                attribute.valueChanged.connect(self.updateSettings)
                self.samplervbox.addWidget(attribute)        
  
    def updateFilter(self):
        self.clearRenderFilterPanel()

        filterType = OptionAttribute(self.lux.sg.getRenderProperty('filter','type'),['NONE','BOX','GAUSSIAN','MITCHELL','MITCHELL_SS','BLACKMANHARRIS'])
        filterType.valueChanged.connect(self.updateFilter)
        self.filtervbox.addWidget(filterType)

        node = None

        if filterType.getValue() == 'BOX':
            node = self.lux.sg.getRenderNode('filterbox')
        elif filterType.getValue() == 'GAUSSIAN':
            node = self.lux.sg.getRenderNode('filtergaussian')
        elif filterType.getValue() == 'MITCHELL':
            node = self.lux.sg.getRenderNode('filtermitchell')
        elif filterType.getValue() == 'MITCHELL_SS':
            node = self.lux.sg.getRenderNode('filtermitchellss')
        elif filterType.getValue() == 'BLACKMANHARRIS':
            node = self.lux.sg.getRenderNode('filterblackmanharris')

        if node is None:
            return 

        for prop in node.props:
            if prop.vtype is 'string':
                # is it a type option?
                if prop.vname is 'type':
                    attribute = OptionAttribute(prop)
                    attribute.valueChanged.connect(self.updateSettings)
                    self.subtype = prop.value[0]
                    self.filtervbox.addWidget(attribute)
                else:
                    attribute = StringAttribute(prop)
                    attribute.valueChanged.connect(self.updateSettings)
                    self.filtervbox.addWidget(attribute)
            if prop.vtype is 'int':
                attribute = IntAttribute(prop)
                attribute.valueChanged.connect(self.updateSettings)
                self.filtervbox.addWidget(attribute)        
            if prop.vtype is 'float':
                attribute = FloatAttribute(prop)
                attribute.valueChanged.connect(self.updateSettings)
                self.filtervbox.addWidget(attribute)        

    def updateSettings(self):
        print("Updating Render Settings")
        self.lux.setRenderSettings()

class TimeEditor(QWidget):
    frameChanged = pyqtSignal(['int'])

    def __init__(self,lux):
        super().__init__()
        self.sframe = QLineEdit()
        self.eframe = QLineEdit()
        self.cframe = QLabel()
        self.slider = QSlider(Qt.Horizontal)

        self.sframe.setFixedWidth(50)
        self.eframe.setFixedWidth(50)

        self.framevalidator = QIntValidator(-10000,10000)
        self.sframe.setValidator(self.framevalidator)
        self.eframe.setValidator(self.framevalidator)
 
        self.sframe.setText('1')
        self.eframe.setText('24')
        self.cframe.setText('1')

        self.cframe.setFont(QFont("Sans",12))
        self.cframe.setAlignment(Qt.AlignCenter)
        self.cframe.setFrameStyle(QFrame.Panel | QFrame.Raised)
 
        vbox = QVBoxLayout(self)
        vbox.addWidget(self.cframe)
        hbox = QHBoxLayout()
        hbox.addWidget(self.sframe)
        hbox.addWidget(self.slider)
        hbox.addWidget(self.eframe)
        vbox.addLayout(hbox) 

        self.slider.setMinimum(int(self.sframe.text()))
        self.slider.setMaximum(int(self.eframe.text()))
        self.slider.valueChanged.connect(self.setCurrentFrame)

    def setCurrentFrame(self,val):
        self.cframe.setText("%d"%val)
        self.frameChanged.emit(val)


# MAIN MENU

# FILE ACTIONS
class FileNewAction(QAction):

    def __init__(self,lux,parent):
        super().__init__("New",parent)
        self.triggered.connect(self.doit)
        self.lux = lux

    def doit(self):
        self.lux.sg.clearScene()
        self.lux.updateScene.emit()

        
class FileExitAction(QAction):

    def __init__(self,lux,parent):
        super().__init__("Exit",parent)
        self.triggered.connect(self.doit)
        self.lux = lux

    def doit(self):
        self.lux.stopRendering()
        app.quit()

 
class ImportMenu(QMenu):

    def __init__(self,lux,parent):
        super().__init__("Import",parent)
        self.addAction(ImportSceneAction(lux,self))
        #self.addAction(ImportPlyAction(lux,self))

class ExportMenu(QMenu):

    def __init__(self,lux,parent):
        super().__init__("Export",parent)
        self.addAction(ExportRenderAction(lux,self))
        self.addAction(ExportSceneAction(lux,self))


# IMPORT ACTIONS
class ImportSceneAction(QAction):

    def __init__(self,lux,parent):
        super().__init__("Scene",parent)
        self.triggered.connect(self.doit)
        self.lux = lux

    def doit(self):
        filename = QFileDialog.getOpenFileName(None,"Import Scene File",".","Scene Files (*.scn)")
        file = open(filename[0],'r')
        self.lux.sg.parseSceneFile(file.readlines())
        file.close()
        self.lux.updateScene.emit()

class ImportPlyAction(QAction):

    def __init__(self,lux,parent):
        super().__init__("Ply",parent)
        self.triggered.connect(self.doit)
        self.lux = lux

    def doit(self):
        print("Ply")


# EXPORT ACTIONS 
class ExportRenderAction(QAction):

    def __init__(self,lux,parent):
        super().__init__("Render",parent)
        self.triggered.connect(self.doit)
        self.lux = lux

    def doit(self):
        filename = QFileDialog.getSaveFileName(None,"Export Render Configuration",".","Config Files (*.cfg)")
        out = self.lux.sg.getRenderSettings()
        file = open(filename[0],'w')
        file.write(out)
        file.close()

class ExportSceneAction(QAction):

    def __init__(self,lux,parent):
        super().__init__("Scene",parent)
        self.triggered.connect(self.doit)
        self.lux = lux

    def doit(self):
        filename = QFileDialog.getSaveFileName(None,"Export Scene File",".","Scene Files (*.scn)")
        out = self.lux.sg.getSceneString()
        file = open(filename[0],'w')
        file.write(out)
        file.close()


class FileMenu(QMenu):

    def __init__(self,lux,name):
        super().__init__(name)
        self.addAction(FileNewAction(lux,self))
        self.addSeparator()
        self.addMenu(ImportMenu(lux,self))
        self.addMenu(ExportMenu(lux,self))
        self.addSeparator()
        self.addAction(FileExitAction(lux,self))
 

class MainMenu(QMenuBar):

    def __init__(self,lux):
        super().__init__()
        self.fileMenu = FileMenu(lux,"File")

        self.addMenu(self.fileMenu)

 
# MAIN WINDOW

class RenderingAction(QAction):

    def __init__(self,lux,parent):
        super().__init__('Paused',parent)
        self.lux = lux
        self.triggered.connect(self.doit)
        self.lux.sg.stop()

    def doit(self):
        if self.text() == 'Paused':
            self.setText('Rendering')
            #self.lux.sg.paused(0)
        else:
            #self.lux.sg.paused(1)
            self.setText('Paused')

 
class MainWindow(QMainWindow):
    
    def __init__(self):
        super().__init__()
        self.thread = QThread()
        self.lux = LuxWidget(1200,800)        

        # Create UI widgets 
        self.sceneLayout = SceneLayout(self.lux)
        self.attributeEditor = NodeEditor(self.lux)
        self.renderSettings = RenderSettings(self.lux)
        self.filmEditor = FilmEditor(self.lux)
        self.toolbar = self.addToolBar("tools")
        self.renderAct = RenderingAction(self.lux,self) 
        self.status = QStatusBar()
        frame = QFrame()
        luxframe = QFrame()
        luxframe.setFrameStyle(QFrame.StyledPanel | QFrame.Plain)
        luxvbox = QHBoxLayout()
        timeeditor = TimeEditor(self.lux)

        self.toolbar.addAction(self.renderAct)
        luxframe.setLayout(luxvbox)
        luxframe.setAutoFillBackground(1)
        palette = QPalette()
        palette.setColor(QPalette.Background,QColor(0,0,0))
        luxframe.setPalette(palette)

        luxvbox.addWidget(self.lux,Qt.AlignCenter)

        self.menu = MainMenu(self.lux)
        self.setMenuBar(self.menu)

        # Layout UI widgets
        vbox = QVBoxLayout()
        vbox.addWidget(luxframe,Qt.AlignCenter)
        vbox.addWidget(timeeditor)
        self.setCentralWidget(frame)
        self.addDockWidget(Qt.RightDockWidgetArea, self.sceneLayout);
        self.addDockWidget(Qt.RightDockWidgetArea, self.attributeEditor);
        self.addDockWidget(Qt.LeftDockWidgetArea, self.renderSettings);
        self.addDockWidget(Qt.LeftDockWidgetArea, self.filmEditor);
        self.tabifyDockWidget(self.sceneLayout, self.attributeEditor);
        self.tabifyDockWidget(self.renderSettings, self.filmEditor);
        self.setTabPosition(Qt.LeftDockWidgetArea,QTabWidget.North);
        self.setTabPosition(Qt.RightDockWidgetArea,QTabWidget.North);

        self.setStatusBar(self.status)

        # Setup UI widgets
        self.status.showMessage("Starting...")
        frame.setLayout(vbox)
        self.setWindowTitle('LuxEd')


        # Connections setup
        self.sceneLayout.nodeSelected.connect(self.nodeSelected)
        self.sceneLayout.nodeRemoved.connect(self.nodeRemoved)

        self.show()

        self.sceneLayout.updateTabs()

        t = QTimer(self)
        t.timeout.connect(self.updateLux)
        t.start(1000)

        # Start the render
        self.lux.startRendering()

        # Create a default material
        #matstring = "scene.materials.luxed_default_mat.type = \"matte\"\n"
        #matstring += "scene.materials.luxed_default_mat.kd = 1 1 1\n"
        #self.lux.sg.lux.setProperties(matstring)

        self.attributeEditor.nodeChanged.connect(self.updateSceneLayout)
        self.lux.updateScene.connect(self.updateScene)

    def updateLux(self):
        self.lux.sg.write()
        self.lux.repaint()
        self.status.clearMessage()
        self.status.showMessage(("[Elapsed time: %3d/5sec][Samples %4d][Avg. samples/sec %3.2fM on %.1fK tris]" % (
                self.lux.getTime(),
                self.lux.getPass(),
                (self.lux.getSpp() / 1000000.0),
                (self.lux.getTriCount() / 1000.0))))


    def keyPressEvent(self, e):
        if e.key() == Qt.Key_Escape:
            self.lux.stopRendering()
            self.close()

    def nodeSelected(self,item):
        print("Node Selected %s"%item)
        self.attributeEditor.setEditor(item)

    def nodeRemoved(self):
        print("Node Removed")
        self.attributeEditor.clear()

    def updateSceneLayout(self):
        self.sceneLayout.updateTabs()

    def updateScene(self):
        self.sceneLayout.updateTabs()
        #self.attributeEditor.clear()

if __name__ == '__main__':
    
    app = QApplication(sys.argv)
    ex = MainWindow()
    sys.exit(app.exec_())
