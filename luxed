#!/bin/python

###########################################################################
# Filename: luxed 
#
# Description: Editor for LuxRender.
#
# Copyright (C) 2016 Richard Layman, rlayman2000@yahoo.com 
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###########################################################################

import time
import sys
from array import *
sys.path.append("./lib")

import pyluxcore

from PyQt5.QtCore import pyqtSignal, Qt, QRect, QThread, QTimer
from PyQt5.QtWidgets import QMainWindow, QSlider, QMenuBar, QMenu, QAction, QDialog, QGroupBox, QStackedWidget, QGridLayout, QComboBox, QListWidget, QTabWidget, QLineEdit, QStatusBar, QFrame, QWidget, QPushButton, QLabel, QHBoxLayout, QVBoxLayout, QDockWidget, QFileDialog, QColorDialog, QApplication
from PyQt5.QtGui import QImage, QPalette, QIcon, QPainter, QFont, QColor, QPen, QIntValidator, QDoubleValidator


# PROPERTIES CONTAINERS

MaterialsType = ["matte","glossy2","glass","metal2"]
TexturesType = ["imagemap"]

class Property:
    
    def __init__(self, ntype, nname, vname, vtype, luxprop, vmin, vmax, vdefault, desc=""):
        self.ntype = ntype
        self.nname = nname
        self.vname = vname
        self.vtype = vtype # bool, int, u_int, float, double, u_longlong, string, texture, uv, vector, normal, point, matrix4x4, spectrum
        self.value = vdefault 
        self.default = vdefault 
        self.min = vmin 
        self.max = vmax 
        self.enabled = 1
        self.desc = desc
        self.luxprop = luxprop
 
    def setType(self, vtype):
        self.vtype = vtype

    def getType(self):
        return self.vtype
    
    def setName(self, name):
        self.name = name
    
    def getName(self):
        return self.name

    def setValue(self, val):
        self.value = val

    def getValue(self):
        return self.value

    def getPropertyString(self):
        out=""
        if self.vtype is 'string':
            out = "%s = \"%s\"" % (self.getCallString(), self.value[0])
        if self.vtype is 'bool' or self.vtype is'int' or self.vtype is'u_int':
            out = "%s = %d" % (self.getCallString(), int(self.value))
        if self.vtype is 'float' or self.vtype is 'double' or self.vtype is 'u_longlong' or self.vtype is 'spectrum':
            out = "%s = %f" % (self.getCallString(), float(self.value))
        if self.vtype is 'uv':
            out = "%s = %f %f" % (self.getCallString(), float(self.value[0]), float(self.value[1]))
        if self.vtype is 'texture':
            out = "%s = %f %f %f" % (self.getCallString(), float(self.value[0]), float(self.value[1]), float(self.value[2]))
        return out

    def getCallString(self):
        if self.nname is None or self.ntype is None:
            return ''
        elif self.ntype is 'objects':
            return "scene.objects.%s.%s"%(self.nname,self.vname)
        elif self.ntype is 'materials':
            return "scene.materials.%s.%s"%(self.nname,self.vname)
        return "%s.%s"%(self.nname,self.vname)

# NODE
class Node:

    def __init__(self,name=None,ntype=None):
        self.name = name
        self.ntype = ntype # 'camera','light','texture','material','object' 
        self.props = []

    def clear(self):
        self.name = None
        self.ntype = None
        self.props = []

    def addProperty(self,prop):
        self.props.append(prop)

    def getPropertyString(self):
        out = ""
        for prop in self.props:
            out += prop.getPropertyString() + "\n"
        return out


'''

# RENDER PROPERTIES

class RenderProps:
    
    def __init__(self):
        self.width = Property('width', 'u_int', 100, 100000, 720)
        self.height = Property('height', 'u_int', 100, 100000, 305)

        # RENDER ENGINE
        self.enginetype = Property('type', 'string', None, None, 'PATHCPU', 'engine type') #"PATHCPU"

        # CPU

        self.cputhreads = Property('threads', 'int', 1, 100, 3, 'The number of threads will be used for the rendering')

        # PATHCPU
        self.pathmaxdepth = Property('maxdepth', 'int', 1, 16, 5, 'Maximum recursion depth of a path')
        # TODO - the max value can not be more then maxdepth
        self.pathrussianroulettedepth = Property('russianroulette.depth', 'int', 1, 16, 3, 'The path depth where Russian Roulette stars to be used')
        self.pathrussianroulettecap = Property('russianroulette.cap', 'float', 0.0, 1.0, 0.5, 'The threshold over which Russian Roulette is used')
        self.pathclampingvariancemaxvalue = Property('clamping.variance.maxvalue', 'float', 0.0, 10000.0, 0.0, 'Samples brighter than this value are clamped, helps to reduce fireflies. 0.0 = disabled')
        self.pathclampingpdfvalue = Property('clamping.pdf.value', 'float', 0.0, 1.0, 0.0, '0.0 = disabled')
        self.pathfastpixelfilterenable = Property('fastpixelfilter.enable', 'bool', 0, 1, 1, 'Enable fast pixel filtering, when disabled, PBRT-like pixel filtering will be used')

        # BIASPATHCPU
        self.biaspathpathdepthtotal = Property('pathdepth.total', 'int', 0, 16, 10, 'Maximum total recursion depth of a path')
        self.biaspathpathdepthdiffuse = Property('pathdepth.diffuse', 'int', 0, 16, 4, 'Maximum recursion depth of a diffuse path')
        self.biaspathpathdepthglossy = Property('pathdepth.glossy', 'int', 0, 16, 3, 'Maximum recursion depth of a glossy path')
        self.biaspathpathdepthspecular = Property('pathdepth.specular', 'int', 0, 16, 3, 'Maximum recursion depth of a specular path')
        self.biaspathsamplingaasize = Property('sampling.aa.size', 'int', 1, 13, 3, 'All diffuse/glossy/specular samples are multiplied with the squared aa size: final_samples = aa^2 * (diffuse^2 + glossy^2 + specular^2)')
        self.biaspathsamplingdiffusesize = Property('sampling.diffuse.size', 'int', 1, 13, 3, 'Diffuse samples (e.g. on matte, mattetranslucent materials)')
        self.biaspathsamplingglossysize = Property('sampling.glossy.size', 'int', 1, 13, 2, 'Glossy samples (e.g. on glossy, glossytranslucent materials)')
        self.biaspathsamplingspecularsize = Property('sampling.specular.size', 'int', 1, 13, 2, 'Specular samples (e.g. on glass, mirror materials)')
        self.biaspathsamplingdirectlightsize = Property('sampling.directlight.size', 'int', 1, 13, 1, 'Direct light samples')
        self.biaspathlightslowthreshold = Property('lights.lowthreshold', 'float', 0.0, 1000000000.0, 0.0, 'Light low intensity threshold')
        self.biaspathlightsnearstart = Property('lights.nearstart', 'float', 0.0, 1000000000.0, 0.001, 'Light distance threshold')
        self.biaspathlightsfirstvertexsamples = Property('lights.firstvertexsamples', 'int', 1, 16, 4, 'First hit direct light samples')
        self.biaspathclampingvariancemaxvalue = Property('clamping.variance.max.value', 'float', 0.0, 1000000000.0, 0.0, 'Samples brighter than this value are clamped, helps to reduce fireflies. 0.0 = disabled')
        self.biaspathclampingpdfvalue = Property('clamping.pdf.value', 'float', 0.0, 1.0, 0.0, '0.0 = disabled')
        self.tilesize = Property('tile.size', 'int', 8, 256, 32, 'Tile size in pixels')
        self.tilesizex = Property('tile.size.x', 'int', 8, 256, 32, 'Tile width in pixels for no-square tile rendering')
        self.tilesizey = Property('tile.size.y', 'int', 8, 256, 32, 'Tile height in pixels for no-square tile rendering')
        self.tilemultipassenable = Property('tile.multipass.enable', 'bool', 0, 1, 1, 'Re-render the image until a halt threshold is met or indefinitely')
        self.tilemultipassconvergencetestthreshold = Property('tile.multipass.convergencetest.threshold', 'float', 0.0, 256.0, 6.0, 'Target noise level')
        self.tilemultipassconvergencetestthreshold256 = Property('tile.multipass.convergencetest.threshold256', 'float', 0, 256.0, 6.0, 'Target noise level')
        self.tilemultipassconvergencetestthresholdreduction = Property('tile.multipass.convergencetest.threshold.reduction', 'float', 0.0, 1.0, 0.0, 'Multiply noise level with this number when all tiles have met the previous noise level. Set to 0 to disable (so rendering will stop at the noise level)')
        self.tilemultipassconvergencetestwarmupcount = Property('tile.multipass.convergencetest.warmup.count', 'int', 0, 100000000, 32, 'Warm up period for the convergence test expressed in samples per pixel')

        # OPENCL

        self.openclplatformindex = Property('platform.index', 'int', -1000, 1000, -1, 'Select the OpenCL platform to use. All devices available on all platforms will be used with -1')
        self.openclcpuuse = Property('cpu.use', 'bool', 0, 1, 0, 'If to use all OpenCL CPU devices available')
        self.openclgpuuse = Property('gpu.use', 'bool', 0, 1, 1, 'If to use all OpenCL GPU devices available')
        self.openclcpuworkgroupsize = Property('cpu.workgroup.size', 'int', 0, 64, 0, 'Set the OpenCL workgroup size, 0 means to use the driver suggested value')
        self.openclgpuworkgroupsize = Property('gpu.workgroup.size', 'int', 0, 64, 0, 'Set the OpenCL workgroup size, 0 means to use the driver suggested value')
        self.opencldevicesselect = Property('devices.select', 'string', None, None, "", 'Select each OpenCL device to use. It is a string of "0" and "1". "1" means use the device, "0" do not')

        # SAMPLER
        self.samplertype = Property('type','string',None,None,'SOBOL', 'sampler type')
        # metropolis
        self.metropolislargesteprate = Property('metropolis.largesteprate','float',0.0,1.0,0.4, 'Probability of generating a large sample mutation')
        self.metropolismaxconsecutivereject = Property('metropolis.maxconsecutivereject','int',0,32768,512, 'Number of consecutive rejects before a next mutation is forced. Low values can cause bias')
        self.metropolisimagemutationrate = Property('metropolis.imagemutationrate','float',0.0,1.0,0.1, 'Maximum distance over the image plane for a small mutation')

        # FILTER
        self.filtertype = Property('type','string',None,None,'BLACKMANHARRIS', 'Type of pixel filter')


    def getPropertyString(self):
        props = ""
        props += "film.width = %d\n"%self.width.value
        props += "film.height = %d\n"%self.height.value
        props += "renderengine.type = \"%s\"\n"%self.enginetype.value
        if(self.enginetype.value == 'PATHCPU'):
            props += "native.threads.count = %d\n"%self.cputhreads.value
            props += "path.maxdepth = %d\n"%self.pathmaxdepth.value
            props += "path.russianroulette.depth = %d\n"%self.pathrussianroulettedepth.value
            props += "path.russianroulette.cap = %d\n"%self.pathrussianroulettecap.value
            props += "path.clamping.variance.maxvalue = %f\n"%self.pathclampingvariancemaxvalue.value
            props += "path.clamping.pdf.value = %f\n"%self.pathclampingpdfvalue.value
            props += "path.fastpixelfilter.enable = %d\n"%self.pathfastpixelfilterenable.value
        if(self.enginetype.value == 'BIASPATHCPU'):
            props += "native.threads.count = %d\n"%self.cputhreads.value
            props += "biaspath.pathdepth.total = %d\n"%self.biaspathpathdepthtotal.value 
            props += "biaspath.pathdepth.diffuse = %d\n"%self.biaspathpathdepthdiffuse.value 
            props += "biaspath.pathdepth.glossy = %d\n"%self.biaspathpathdepthglossy.value 
            props += "biaspath.pathdepth.specular = %d\n"%self.biaspathpathdepthspecular.value 
            props += "biaspath.sampling.aa.size = %d\n"%self.biaspathsamplingaasize.value 
            props += "biaspath.sampling.diffuse.size = %d\n"%self.biaspathsamplingdiffusesize.value 
            props += "biaspath.sampling.glossy.size = %d\n"%self.biaspathsamplingglossysize.value 
            props += "biaspath.sampling.specular.size = %d\n"%self.biaspathsamplingspecularsize.value 
            props += "biaspath.sampling.directlight.size = %d\n"%self.biaspathsamplingdirectlightsize.value 
            props += "biaspath.lights.lowthreshold = %f\n"%self.biaspathlightslowthreshold.value 
            props += "biaspath.lights.nearstart = %f\n"%self.biaspathlightsnearstart.value 
            props += "biaspath.lights.firstvertexsamples = %d\n"%self.biaspathlightsfirstvertexsamples.value 
            props += "biaspath.clamping.variance.max.value = %f\n"%self.biaspathclampingvariancemaxvalue.value 
            props += "biaspath.clamping.pdf.value = %f\n"%self.biaspathclampingpdfvalue.value 
            props += "tile.size = %d\n"%self.tilesize.value 
            props += "tile.size.x = %d\n"%self.tilesizex.value 
            props += "tile.size.y = %d\n"%self.tilesizey.value 
            props += "tile.multipass.enable = %d\n"%self.tilemultipassenable.value 
            props += "tile.multipass.convergencetest.threshold = %f\n"%self.tilemultipassconvergencetestthreshold.value 
            props += "tile.multipass.convergencetest.threshold256 = %f\n"%self.tilemultipassconvergencetestthreshold256.value 
            props += "tile.multipass.convergencetest.threshold.reduction = %f\n"%self.tilemultipassconvergencetestthresholdreduction.value 
            props += "tile.multipass.convergencetest.warmup.count = %d\n"%self.tilemultipassconvergencetestwarmupcount.value 
        if(self.enginetype.value == 'PATHOCL'):
            props += "opencl.platform.index = %d\n"%self.openclplatformindex.value 
            props += "opencl.cpu.use = %d\n"%self.openclcpuuse.value
            props += "opencl.gpu.use = %d\n"%self.openclgpuuse.value 
            props += "opencl.cpu.workgroup.size = %d\n"%self.openclcpuworkgroupsize.value 
            props += "opencl.gpu.workgroup.size = %d\n"%self.openclgpuworkgroupsize.value
            props += "opencl.devices.select = \"%s\"\n"%self.opencldevicesselect.value 
        if(self.enginetype.value == 'RTPATHOCL'):
            props += "opencl.platform.index = %d\n"%self.openclplatformindex.value 
            props += "opencl.cpu.use = %d\n"%self.openclcpuuse.value
            props += "opencl.gpu.use = %d\n"%self.openclgpuuse.value 
            props += "opencl.cpu.workgroup.size = %d\n"%self.openclcpuworkgroupsize.value 
            props += "opencl.gpu.workgroup.size = %d\n"%self.openclgpuworkgroupsize.value
            props += "opencl.devices.select = \"%s\"\n"%self.opencldevicesselect.value 
        if(self.enginetype.value == 'BIASPATHOCL'):
            props += "opencl.platform.index = %d\n"%self.openclplatformindex.value 
            props += "opencl.cpu.use = %d\n"%self.openclcpuuse.value
            props += "opencl.gpu.use = %d\n"%self.openclgpuuse.value 
            props += "opencl.cpu.workgroup.size = %d\n"%self.openclcpuworkgroupsize.value 
            props += "opencl.gpu.workgroup.size = %d\n"%self.openclgpuworkgroupsize.value
            props += "opencl.devices.select = \"%s\"\n"%self.opencldevicesselect.value 
        if(self.enginetype.value == 'RTBIASPATHOCL'):
            props += "opencl.platform.index = %d\n"%self.openclplatformindex.value 
            props += "opencl.cpu.use = %d\n"%self.openclcpuuse.value
            props += "opencl.gpu.use = %d\n"%self.openclgpuuse.value 
            props += "opencl.cpu.workgroup.size = %d\n"%self.openclcpuworkgroupsize.value 
            props += "opencl.gpu.workgroup.size = %d\n"%self.openclgpuworkgroupsize.value
            props += "opencl.devices.select = \"%s\"\n"%self.opencldevicesselect.value 

        props += "sampler.type = \"%s\"\n"%self.samplertype.value
        if(self.samplertype.value == 'METROPOLIS'):
            props += "sampler.metropolis.largesteprate = %f\n"%self.metropolislargesteprate.value
            props += "sampler.metropolis.maxconsecutivereject = %d\n"%self.metropolismaxconsecutivereject.value
            props += "sampler.metropolis.imagemutationrate = %f\n"%self.metropolisimagemutationrate.value
        props += "filter.type = \"%s\"\n"%self.filtertype.value

        return props
'''
 
# LUX SCENE
class Lux(QThread):

    def __init__(self):
        super().__init__()
        pyluxcore.Init()

        # Load the configuration from files
        #self.props = pyluxcore.Properties("render.cfg")
        #self.scene = pyluxcore.Scene("scene.scn")
        #self.scnprops = pyluxcore.Properties("scene.scn")
        #self.config = pyluxcore.RenderConfig(self.props, self.scene)
        #self.session = pyluxcore.RenderSession(self.config)

        self.props = pyluxcore.Properties()
        self.props.Set(pyluxcore.Property("renderengine.type", ["PATHCPU"]))
        self.props.Set(pyluxcore.Property("opencl.platform.index", [-1]))
        self.props.Set(pyluxcore.Property("opencl.cpu.use", [0]))
        self.props.Set(pyluxcore.Property("opencl.gpu.use", [1]))
        self.props.Set(pyluxcore.Property("opencl.gpu.workgroup.size", [64]))
        self.props.Set(pyluxcore.Property("film.width", [1024]))
        self.props.Set(pyluxcore.Property("film.height", [576]))
        # camera
        self.sceneprops = pyluxcore.Properties()
        self.sceneprops.Set(pyluxcore.Property("scene.camera.lookat.orig", [0.64, 0.27, 0.14]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.lookat.target", [0.10, 1.04, -0.18]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.up", [0, 0, 1]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.cliphither", [0.001]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.clipyon", [1.00]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.lensradius", [0.00]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.focaldistance", [0.28]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.fieldofview", [49]))

        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain", [0, 0, 0]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.transformation", [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.samples", [-1]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.visibility.indirect.diffuse.enable", [1]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.visibility.indirect.glossy.enable", [1]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.visibility.indirect.specular.enable", [1]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.dir", [-0.51, -3.38, 0.76]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.turbidity", [2.20]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.relsize", [1]))

        self.scene = pyluxcore.Scene()
        self.scene.Parse(self.sceneprops) 
       
        self.config = pyluxcore.RenderConfig(self.props, self.scene)
        self.session = pyluxcore.RenderSession(self.config)
      
        # PROPERTIES
        self.fov = 65

    def load(self):
        val = 0
        print("Object Count:%d"%(self.scene.GetObjectCount()))
        print("Light Count:%d"%(self.scene.GetObjectCount()))

        #self.textures = self.scnprops.GetAllUniqueSubNames("scene.textures")
        #self.materials = self.scnprops.GetAllUniqueSubNames("scene.materials")
        #self.lights = self.scnprops.GetAllUniqueSubNames("scene.lights")
        #self.objects = self.scnprops.GetAllUniqueSubNames("scene.objects")
        #print("Loaded... Lights:%d, Textures%d, Materials%d, Objects%d"%(len(self.lights), len(self.textures), len(self.materials), len(self.objects))) 
       
    def startRendering(self):
        self.session.Start() 
        
    def paused(self,state):
        if(state):
            self.session.EndSceneEdit()
        else:
            self.session.BeginSceneEdit()

    def writeImage(self):
        self.session.UpdateStats()
        self.session.GetFilm().Save()

    def stopRendering(self):
        self.session.GetFilm().Save()
        self.session.Stop()

    def getTime(self):
        stats = self.session.GetStats();
        return stats.Get("stats.renderengine.time").GetFloat()

    def getPass(self):
        stats = self.session.GetStats();
        return stats.Get("stats.renderengine.pass").GetInt()

    def getSpp(self):
        stats = self.session.GetStats();
        return stats.Get("stats.renderengine.total.samplesec").GetFloat()

    def getTriCount(self):
        stats = self.session.GetStats();
        return stats.Get("stats.dataset.trianglecount").GetFloat()

    def getMaterialType(self,name):
        mtype = ""
        mtype=self.scnprops.Get("scene.materials.%s.type"%name).Get() 
        print("mtype = %s"%mtype)
        return mtype 

    def getTextureType(self,name):
        return self.scnprops.Get("scene.textures.%s.type"%name).Get() 

    def beginEdit(self):
        self.session.BeginSceneEdit()

    def endEdit(self):
        self.session.EndSceneEdit()
        self.writeImage()



    # This is needed since luxcore will crash if you try to set a property that was not set in the file.
    # To fix this we will call this method before we try to set any properties.
    # When the AE is first loaded it will load the properties for lux and then this method will get called
    # for each property.
    # It will ask lux if the property exists and add it if it doesn't.   
    def verifyProperty(self,name,prop):
        if self.scnprops.IsDefined(name) is False:
            print(name + " is missing. Adding it")
            if prop.type is 'string':
                self.scnprops.Set(pyluxcore.Property(name, [prop.value]))
            if prop.type is 'bool' or prop.type is'int' or prop.type is'u_int':
                self.scnprops.Set(pyluxcore.Property(name, [prop.value]))
            if prop.type is 'float' or prop.type is 'double' or prop.type is 'u_longlong' or prop.type is 'spectrum':
                self.scnprops.Set(pyluxcore.Property(name, [prop.value]))
            if prop.type is 'uv':
                self.scnprops.Set(pyluxcore.Property(name, [prop.value[0],prop.value[1]]))
            if prop.type is 'texture':
                self.scnprops.Set(pyluxcore.Property(name, [prop.value[0],prop.value[1],prop.value[2]]))

    def changeSize(self,width,height):
        print("CHANGE SIZE")
        self.setFixedWidth(width)
        self.setFixedHeight(height)

        # Stop the rendering
        self.session.Stop()
        self.session = None

        # Set the new size
        self.scene.Parse(pyluxcore.Properties().
            Set(pyluxcore.Property("film.width", [width])).
            Set(pyluxcore.Property("film.height", [height])))

        # Re-start the rendering
        self.session = pyluxcore.RenderSession(self.config)
        self.session.Start()


    def setProperty(self,propname,propval):
        self.session.BeginSceneEdit()
        self.scene.Parse(pyluxcore.Properties().Set(pyluxcore.Property(propname, [propval])).
            Set(pyluxcore.Property("scene.camera.lookat.orig", [-5.35,7.7,-4.35])).
            Set(pyluxcore.Property("scene.camera.lookat.target", [10,5.69,-9.98])).
            Set(pyluxcore.Property("scene.camera.up", [0,1,0]))
        )
        self.session.EndSceneEdit()
        self.writeImage()

    def setProperties(self,propstring):
        print(propstring)
        self.session.BeginSceneEdit()
        try:
            self.scene.Parse(pyluxcore.Properties().SetFromString(propstring))
        except RuntimeError:
            pass
        self.session.EndSceneEdit()
        self.writeImage()

    def getMaterialProperties(self,mtype,name):
        if mtype is "materialcommmon":
            props = MaterialCommonProps()
            props.id.setValue(self.scnprops.Get("scene.materials.%s.id"%name).Get())
            props.bumptex.setValue(self.scnprops.Get("scene.materials.%s.bumptex"%name).Get())
            props.normaltex.setValue(self.scnprops.Get("scene.materials.%s.normaltex"%name).Get())
 
        if mtype is "materialemission":
            props = MaterialEmissionProps()
            props.emission.setValue(self.scnprops.Get("scene.materials.%s.emission"%name).Get())
            props.emissiongain.setValue(self.scnprops.Get("scene.materials.%s.emission.gain"%name).Get())
            props.emissionpower.setValue(self.scnprops.Get("scene.materials.%s.emission.power"%name).Get())
            props.emissionefficency.setValue(self.scnprops.Get("scene.materials.%s.emission.efficency"%name).Get())
        
        if mtype is "matte":
            props = MatteProps()
            props.kd.setValue(self.scnprops.Get("scene.materials.%s.kd"%name).Get())

        if mtype is "carpaint":
            props = CarPaintProps()
            props.preset.setValue(self.scnprops.Get("scene.materials.%s.preset"%name).Get())
            props.ka.setValue(self.scnprops.Get("scene.materials.%s.ka"%name).Get())
            props.d.setValue(self.scnprops.Get("scene.materials.%s.d"%name).Get())
            props.kd.setValue(self.scnprops.Get("scene.materials.%s.kd"%name).Get())
            props.ks1.setValue(self.scnprops.Get("scene.materials.%s.ks1"%name).Get())
            props.ks2.setValue(self.scnprops.Get("scene.materials.%s.ks2"%name).Get())
            props.ks3.setValue(self.scnprops.Get("scene.materials.%s.ks3"%name).Get())
            props.r1.setValue(self.scnprops.Get("scene.materials.%s.r1"%name).Get())
            props.r2.setValue(self.scnprops.Get("scene.materials.%s.r2"%name).Get())
            props.r3.setValue(self.scnprops.Get("scene.materials.%s.r3"%name).Get())
            props.m1.setValue(self.scnprops.Get("scene.materials.%s.m1"%name).Get())
            props.m2.setValue(self.scnprops.Get("scene.materials.%s.m2"%name).Get())
            props.m3.setValue(self.scnprops.Get("scene.materials.%s.m3"%name).Get())

        if mtype is "glass":
            props = GlassProps()
            props.kr.setValue(self.scnprops.Get("scene.materials.%s.kr"%name).Get())
            props.kt.setValue(self.scnprops.Get("scene.materials.%s.kt"%name).Get())
            props.interior.setValue(self.scnprops.Get("scene.materials.%s.interior"%name).Get())
            props.exterior.setValue(self.scnprops.Get("scene.materials.%s.exterior"%name).Get())

        if mtype is "glossy2":
            props = Glossy2Props()
            #stats = self.session.GetStats();
            #props.kd.setValue(self.session.Parse(self.scnprops.Get("scene.materials.%s.kd"%name).Get()))
            #val = None
            #val = stats.Get("stats.scene.materials.%s.kd"%name).GetString()
            #self.config.GetProperty(self.scnprops.Get("scene.materials.%s.ks"%name).Get())
            #self.scene.Parse(self.scnprops.Get("scene.materials.%s.kd"%name).Get())
            print("GLOSSY NAME")
            #print(self.scnprops.Get("scene.materials.%s.ks"%name).Get())
            props.kd.setValue(self.scnprops.Get("scene.materials.%s.kd"%name).Get())
            props.ks.setValue(self.scnprops.Get("scene.materials.%s.ks"%name).Get())
            #print(self.scnprops.Get("scene.materials.%s.ks"%name).Get())
            #self.config.GetProperty(self.scnprops.Get("scene.materials.%s.ks"%name).GetName())
            #print(self.scene.ToProperties().Get(self.scnprops.Get("scene.materials.%s.ks"%name)).Get())



            props.uroughness.setValue(self.scnprops.Get("scene.materials.%s.uroughness"%name).Get())
            props.vroughness.setValue(self.scnprops.Get("scene.materials.%s.vroughness"%name).Get())

        if mtype is "mix":
            props = MaterialMixProps()
            props.material1.setValue(self.scnprops.Get("scene.materials.%s.material1"%name).Get())
            props.material2.setValue(self.scnprops.Get("scene.materials.%s.material2"%name).Get())
            props.amount.setValue(self.scnprops.Get("scene.materials.%s.amount"%name).Get())
 
        return props 
 
    def getTextureProperties(self,mtype,name):
        props = None
        if mtype is "imagemap":
            props = ImageMapProps()
            props.file.setValue(self.scnprops.Get("scene.textures.%s.file"%name).Get())
            props.gamma.setValue(self.scnprops.Get("scene.textures.%s.gamma"%name).Get())
            props.gain.setValue(self.scnprops.Get("scene.textures.%s.gain"%name).Get())
        return props 
     
    
    def setRenderSettings(self,propstring):
        # Stop the rendering
        self.session.Stop()
        self.session = None

        print("NEW RENDER SETTINGS")
        print(propstring)
        self.config.Parse(pyluxcore.Properties().SetFromString(propstring))

        # Re-start the rendering
        self.session = pyluxcore.RenderSession(self.config)
        self.session.Start()

    def getRenderSettings(self):
        self.session.UpdateStats()
        #props = RenderProps()
        #props.width.value = self.session.GetFilm().GetWidth()
        #props.height.value = self.session.GetFilm().GetHeight()
        #return props


    def getWidth(self):
        self.session.UpdateStats()
        return self.session.GetFilm().GetWidth()

    def getHeight(self):
        self.session.UpdateStats()
        return self.session.GetFilm().GetHeight()

    def getNode(self, node):
        for prop in node.props:
            print("PROP NAME")
            #name = prop.luxprop.GetName() #self.sceneprops.Get(prop.getCallString()).Get()
            print(prop.luxprop)
            print(self.sceneprops.GetAllUniqueSubNames(prop.getCallString()))

    # TESTING
    def setColor(self,prop,val):
        prop.Set(val)
        self.scene.Parse(self.sceneprops.Set(prop))

    # TESTING
    def getColor(self,prop):
        print(prop.Get())

    def addNode(self,node):

        print("ADD NODE %s"%node.name)
        for prop in node.props:
            luxprop = pyluxcore.Property(prop.getCallString(), prop.value)
            self.sceneprops.Set(luxprop)
            prop.luxprop = luxprop

        self.scene.Parse(self.sceneprops)

        return node
 
    def addObject(self):
        self.session.BeginSceneEdit()

        #self.scene.Parse(pyluxcore.Properties().

        mattekd = pyluxcore.Property("scene.materials.mat.kd", [1,1,1])
        mattename = mattekd.GetName()
        print("NEW PROP NAME: " + mattename)
 
        #self.scene.Parse(self.sceneprops.Set(pyluxcore.Property("scene.materials.light_mat.type", ["matte"]))
 
        self.scene.Parse(pyluxcore.Properties().
            Set(pyluxcore.Property("scene.materials.light_mat.type", ["matte"])).
            Set(pyluxcore.Property("scene.materials.light_mat.kd", [1, 1, 1])). 
            Set(pyluxcore.Property("scene.materials.light_mat.emission", [1, 1, 1])).
            Set(pyluxcore.Property("scene.materials.light_mat.emission.gain", [1, 1, 1])).
            Set(pyluxcore.Property("scene.materials.light_mat.emission.power", [1000])).
            Set(pyluxcore.Property("scene.materials.light_mat.emission.efficency", [1])).
            Set(pyluxcore.Property("scene.materials.mat.type", ["matte"])).
            Set(mattekd).
            Set(pyluxcore.Property("scene.objects.ball.material", ["mat"])).
            Set(pyluxcore.Property("scene.objects.ball.ply", ["mesh/outer_ball.ply"])).
            Set(pyluxcore.Property("scene.objects.light_obj.material", ["light_mat"])).
            Set(pyluxcore.Property("scene.objects.light_obj.ply", ["mesh/light_left.ply"]))
        )

        self.session.EndSceneEdit()
        self.writeImage()
        return mattekd

    def getName(self,prop):
        print("PASSED PROP NAME " + prop.GetName())

        self.session.BeginSceneEdit()
        self.scene.Parse(pyluxcore.Properties().
            Set(pyluxcore.Property(prop.GetName(), [1,0,0]))
        ) 
        self.session.EndSceneEdit()
        self.writeImage()
 
        names = self.scene.ToProperties().GetAllUniqueSubNames("scene.materials")
        for n in names:
            print(n)
        return("DONE")

# SCENEGRAPH

class SceneGraph():

    def __init__(self):
        self.lux = Lux()

        # Property containers
        #self.render = RenderProps()
        self.rendernodes = []
        self.nodes = []

        self.initRenderNodes()
        #self.lux.setRenderSettings(self.render.getPropertyString)

    def initRenderNodes(self):
        # render engine
        renderengine = Node('renderengine','renderengine')
        renderengine.addProperty(Property('renderengine','renderengine','type','string',None,None,None,['PATHCPU'],""))
        # PATHCPU
        path = Node('path','path')
        path.addProperty(Property('path','path','maxdepth','int',None,1,16,5,""))
        path.addProperty(Property('path','path','russianroulette.depth','int',None,1,16,3,""))
        path.addProperty(Property('path','path','russianroulette.cap','float',None,0.0,1.0,0.5,""))
        path.addProperty(Property('path','path','clamping.variance.maxvalue','float',None,0.0,None,0.0,""))
        path.addProperty(Property('path','path','clamping.pdf.value','float',None,0.0,1.0,0.0,""))
        path.addProperty(Property('path','path','fastpixelfilter.enable','bool',None,0,1,1,""))
 
        # SAMPLERS

        # METROPOLIS 
        sampler= Node('sampler','sampler')
        sampler.addProperty(Property('sampler','sampler','type','string',None,None,None,['SOBOL'],""))
        samplermetropolis = Node('sampler.metropolis','sampler.metropolis')
        samplermetropolis.addProperty(Property('sampler.metropolis','sampler.metropolis','largesteprate','float',None,0.0,1.0,0.4,""))
        samplermetropolis.addProperty(Property('sampler.metropolis','sampler.metropolis','maxconsecutivereject','int',None,0,32768,512,""))
        samplermetropolis.addProperty(Property('sampler.metropolis','sampler.metropolis','imagemutationrate','float',None,0.0,1.0,0.1,""))
 
        # film 
        film = Node('film','film')
        film.addProperty(Property('film','film','width','int',None,10,None,720,""))
        film.addProperty(Property('film','film','height','int',None,10,None,480,""))

        self.rendernodes.append(renderengine)
        self.rendernodes.append(sampler)
        self.rendernodes.append(samplermetropolis)
        self.rendernodes.append(path)
        self.rendernodes.append(film)
 
    def start(self):
        self.lux.startRendering() 
        
    def stop(self):
        self.lux.stopRendering()

    def paused(self,state):
        self.lux.paused(state)

    def write(self):
        self.lux.writeImage()

    def loadConfig(self, path):
        if(path == None):
            pass            

    def loadScene(self, path):
        if(path == None):
            pass

    def beginEdit(self):
        self.lux.beginEdit()
 
    def endEdit(self):
        self.lux.endEdit()
    
    def getRenderProperty(self,ntype,pname):
        for node in self.rendernodes:
            if node.ntype == ntype:
                for prop in node.props:
                    if prop.vname == pname:
                        return prop 
        return None 
 
    def getNames(self, ntype):
        nodelist = []
       
        for node in self.nodes:
            print("looking at node")
            if node.ntype == ntype:
                print("adding node " + node.name)
                nodelist.append(node.name)

        return nodelist 

    def setRenderSettings(self):
        propstring = ''

        # ENGINE
        enginenode = None
        for node in self.rendernodes:
            if node.ntype == 'renderengine':
                enginenode = node

        propstring += enginenode.getPropertyString()         

        for node in self.rendernodes:
            if node.ntype == 'path' and enginenode.props[0].value[0] == 'PATHCPU':
                 propstring += node.getPropertyString()

        # SAMPLER
        samplernode = None
        # get sampler type
        for node in self.rendernodes:
            if node.ntype == 'sampler':
                 samplernode = node

        # build sampler string
        propstring += samplernode.getPropertyString()
        for node in self.rendernodes:
            print("sampler type = %s"%samplernode.props[0].value[0])
            if node.ntype == 'sampler.metropolis' and samplernode.props[0].value[0] == 'METROPOLIS':
                propstring += node.getPropertyString()

        # FILM
        for node in self.rendernodes:
            if node.ntype == 'film':
                propstring += node.getPropertyString()

        self.lux.setRenderSettings(propstring)

    def getNode(self, name):
        for node in self.nodes:
            if node.name == name:
                return node

    def addNode(self, node):
        self.nodes.append(self.lux.addNode(node))

    def addNode(self,name,ntype,subtype):
        node = Node(name,ntype)
        if subtype == 'ply':
            node.addProperty(Property('objects',name,'material','string',None,None,None,['mat'],"type of material"))
            node.addProperty(Property('objects',name,'ply','string',None,None,None,[''],"mesh path (e.g scenes/luxball/luxball-shell.ply)"))
        if subtype == 'matte':
            node.addProperty(Property('materials',name,'type','string',None,None,None,['matte'],"type of material"))
            node.addProperty(Property('materials',name,'kd','texture',None,None,None,[1,1,1],"texture or constant color of the matte material"))
        if subtype == 'glossy2':
            node.addProperty(Property('materials',name,'type','string',None,None,None,['glossy2'],"type of material"))
            node.addProperty(Property('materials',name,'kd','texture',None,None,None,[1,1,1],"texture or constant diffuse color of the material"))
            node.addProperty(Property('materials',name,'ks','texture',None,None,None,[1,1,1],"texture or constant specular color of the material"))
            node.addProperty(Property('materials',name,'uroughness','texture',None,None,None,[0.1,0.1,0.1],"texture or constant roughness value along u coordinate of the material"))
            node.addProperty(Property('materials',name,'vroughness','texture',None,None,None,[0.1,0.1,0.1],"texture or constant roughness value along v coordinate of the material"))
            node.addProperty(Property('materials',name,'ka','texture',None,None,None,[0.0,0.0,0.0],"texture or constant value of coefficient of absorption of the coating layer"))
            node.addProperty(Property('materials',name,'d','texture',None,None,None,[0.0,0.0,0.0],"texture or constant value of the depth (thickness) of the coating layer for absorption effects. (0 = disables)"))
            node.addProperty(Property('materials',name,'index','texture',None,None,None,[0.0,0.0,0.0],"IOR of the coating. IOR overrides color Ks if both are specified"))
        if ntype == 'materials':
            node.addProperty(Property('materials',name,'emission','texture',None,None,None,[0,0,0],"color of the emitted light"))
            node.addProperty(Property('materials',name,'emission.gain','texture',None,None,None,[0,0,0],""))
            node.addProperty(Property('materials',name,'emission.power','spectrum',None,None,None,0.0,"lamp output power in watts. Setting 0 for both power and efficacy bypasses this feature and uses only the lamp gain"))
            node.addProperty(Property('materials',name,'emission.efficency','float',None,None,None,0.0,"luminous efficacy in lumens/watt. Setting 0 for both power and efficacy bypasses this feature and uses only the lamp gain"))
            node.addProperty(Property('materials',name,'emission.samples','int',None,-1,1000,-1,"the number of shadow ray to trace to compute direct light from this material. This property is an hint and the render engine can ignore this information. -1 means use the default global value."))
 
        self.nodes.append(node)
        print("nodes size = %d"%len(self.nodes))
        self.lux.setProperties(node.getPropertyString())
        return node

    def addObject(self):
        node = Node('mat_test','materials')
        #node.addProperty(Property(ntype,name, attribute, luxprop, vtype, vmin, vmax, vdefault, desc=""))
        node.addProperty(Property(node.ntype,'mat_test', 'type', None, 'string', None, None, ["matte"], desc="Test"))
        node.addProperty(Property(node.ntype,'mat_test', 'kd', None, 'texture', None, None, [1,0,0], desc="Test"))

        node = self.lux.addNode(node)
        for prop in node.props:
            print(prop.luxprop)
            print(prop.getCallString())
            print(prop.value)
        #prop = self.lux.addObject()
        #print(self.lux.getName(prop))

 
class LuxWidget(QWidget):
    nodeAdded = pyqtSignal()


    def __init__(self,width,height):
        super().__init__()
        self.sg = SceneGraph()
        self.fov = 65
        self.setFixedWidth(self.sg.lux.getWidth())
        self.setFixedHeight(self.sg.lux.getHeight())
        
    def paintEvent(self,e):
        qp = QPainter()
        qp.begin(self)
        self.drawWidget(qp)
        qp.end()

    def drawWidget(self,qp):
        rect = QRect(0,0,self.width(),self.height())
        image = QImage("image.png")
        qp.drawImage(rect,image)

    def changeSize(self,width,height):
        self.setFixedWidth(width)
        self.setFixedHeight(height)
        self.lux.changeSize(width,height)

    def startRendering(self):
        self.sg.start() 

    def writeImage(self):
        self.sg.write()

    def stopRendering(self):
        self.sg.stop()

    def getTime(self):
        return self.sg.lux.getTime()

    def getPass(self):
        return self.sg.lux.getPass() 

    def getSpp(self):
        return self.sg.lux.getSpp()

    def getTriCount(self):
        return self.sg.lux.getTriCount()

    def setRenderSettings(self):
        self.sg.setRenderSettings()
        self.setFixedWidth(self.sg.lux.getWidth())
        self.setFixedHeight(self.sg.lux.getHeight())

    def wheelEvent(self,e):
        self.fov = self.fov + (e.angleDelta().y() * 0.1)
        if self.fov > 1000.0:
            self.fov = 1000.0
        if self.fov < 5.0:
            self.fov = 5.0
        print("fov = %.1f, x = %d" % (self.fov,e.angleDelta().y()))
        self.lux.setProperty("scene.camera.fieldofview",self.fov)
        self.repaint()


# EDITOR WIDGETS


# Color Widget 
class ColorWidget(QFrame):
    colorChanged = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.colorValue = QFrame()
        self.setFixedWidth(32)
        self.setFrameStyle(QFrame.StyledPanel | QFrame.Plain)
        self.setAutoFillBackground(1)
        self.palette = QPalette()
        self.palette.setColor(QPalette.Window,QColor(255,255,255))
        self.setPalette(self.palette)

    def mousePressEvent(self,e):
        color = QColorDialog(self.palette.color(QPalette.Window)).getColor()
        self.palette.setColor(QPalette.Window,color)
        self.setPalette(self.palette)
        self.colorChanged.emit()

    def getColor(self):
        return self.palette.color(QPalette.Window)
 
    def setColor(self,color):
        self.palette.setColor(QPalette.Window,color)
        self.setPalette(self.palette)


# Link Dialog
class LinkDialog(QDialog):
    linkSelected = pyqtSignal(['QString'])

    def __init__(self,lux,ltype):
        super().__init__()
        self.lux = lux
        self.list = QListWidget() 
        self.link = ""

        vbox = QVBoxLayout()
        vbox.addWidget(self.list)
        self.setLayout(vbox)

        if(ltype == 'materials'):
            self.list.clear()
            for t in self.lux.sg.getNames('materials'):
                self.list.addItem(t)

        if(ltype == 'textures'):
            self.list.clear()
            for t in self.lux.sg.getNames('textures'):
                self.list.addItem(t)


        self.show()
        self.list.itemClicked.connect(self.setCurrentLink)

    def setCurrentLink(self,item):
        self.link = item.text()
        self.linkSelected.emit(self.link)
        self.hide()

 
# Texture Attribute
class TextureAttribute(QWidget):
    valueChanged = pyqtSignal()

    def __init__(self,prop,lux):
        super().__init__()
        self.lux = lux
        self.prop = prop
        self.label = QLabel(self.prop.vname)
        self.colorValue = ColorWidget()
        self.colorValue.setColor(QColor(255.0*prop.value[0],255.0*prop.value[1],255.0*prop.value[2]))
        self.disableBtn = QPushButton("X")
        self.disableBtn.setFixedWidth(30)
        self.linkValue = QPushButton("select")
        self.linkEnabled = 0 # use a color value or a texture link
        self.valueTypeBtn = QPushButton("T")
        self.valueTypeBtn.setFixedWidth(30)
        self.link = None
        if prop.nname == 'materials':
            self.link = LinkDialog(self.lux,'textures')
        if prop.nname == 'objects':
            self.link = LinkDialog(self.lux,'materials')

        self.setToolTip(self.prop.desc)
 
        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(self.label)
        hbox.addWidget(self.colorValue)
        hbox.addWidget(self.linkValue)
        hbox.addWidget(self.valueTypeBtn)
        hbox.addWidget(self.disableBtn)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        self.setValueWidget()
     
        self.colorValue.colorChanged.connect(self.changed) 
        self.disableBtn.clicked.connect(self.toggleEnabled)
        self.valueTypeBtn.clicked.connect(self.toggleValueType)
        self.linkValue.clicked.connect(self.showLinkDialog)
        if self.link:
            self.link.linkSelected.connect(self.setLink)
            self.link.hide()

    def enabled(self):
        return self.label.isEnabled()

    def toggleValueType(self):
        if(self.linkEnabled):
            self.linkEnabled = 0 
        else:
            self.linkEnabled = 1 
        self.setValueWidget()

    def setValueWidget(self):
        if(self.linkEnabled):
            self.colorValue.setVisible(0)
            self.linkValue.setVisible(1)
        else:
            self.colorValue.setVisible(1)
            self.linkValue.setVisible(0)

    def showLinkDialog(self):
        self.link.show()

    def setLink(self,link):
        self.linkValue.setText(link)
        self.changed()

    def hideDisableButton(self,hide):
        if(hide):
            self.disableBtn.setVisible(0)
        else:
            self.disableBtn.setVisible(1)
    
    def toggleEnabled(self):
        if(self.label.isEnabled()):
            self.prop.enabled = 0
            self.label.setEnabled(0)
            self.colorValue.setEnabled(0)
            self.disableBtn.setFlat(1)
            self.disableBtn.setText("O")
        else:
            self.prop.enabled = 1
            self.label.setEnabled(1)
            self.colorValue.setEnabled(1)
            self.disableBtn.setFlat(0)
            self.disableBtn.setText("X")
 
    def changed(self):
        self.getColorValue() 
        self.valueChanged.emit()

    def changeColorValue(self,e):
        pass

    def getColorValue(self):
        if(self.linkEnabled):
            self.prop.type = 'string'
            self.prop.value = self.linkValue.text()
        else:
            color = self.colorValue.getColor()
            self.prop.type = 'texture'
            self.prop.value = [color.red()/255.0, color.green()/255.0, color.blue()/255.0]
        return self.prop.value

    def setProperty(self,prop):
        self.prop = prop
        if(len(prop.value) == 1):
            self.colorValue.setColor(QColor(255.0 * float(self.prop.value[0]), 255.0 * float(self.prop.value[0]), 255.0 * float(self.prop.value[0])))
        else:
            self.colorValue.setColor(QColor(255.0 * float(self.prop.value[0]), 255.0 * float(self.prop.value[1]), 255.0 * float(self.prop.value[2])))


# Option Attribute
class OptionAttribute(QWidget):
    valueChanged = pyqtSignal()

    def __init__(self,prop,options=None):
        super().__init__()
        self.prop = prop
        self.label = QLabel(self.prop.vname)
        self.value = QComboBox()
        self.disableBtn = QPushButton("X")
        self.disableBtn.setFixedWidth(30)

        self.setToolTip(self.prop.desc)

        if options is not None: 
            for item in options:
                self.value.addItem(item)
        else:
            if self.prop.ntype == 'materials':
                for item in MaterialsType:
                    self.value.addItem(item)

        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(self.label)
        hbox.addWidget(self.value)
        hbox.addWidget(self.disableBtn)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        self.value.setCurrentText(self.prop.value[0])        
        self.value.currentIndexChanged.connect(self.changed)
        self.disableBtn.clicked.connect(self.toggleEnabled)

        self.prop.value[0] = self.value.currentText()

    def enabled(self):
        return self.label.isEnabled()

    def hideDisableButton(self,hide):
        if(hide):
            self.disableBtn.setVisible(0)
        else:
            self.disableBtn.setVisible(1)

    def toggleEnabled(self):
        if(self.label.isEnabled()):
            self.prop.enabled = 0
            self.label.setEnabled(0)
            self.value.setEnabled(0)
            self.disableBtn.setFlat(1)
            self.disableBtn.setText("O")
        else:
            self.prop.enabled = 1
            self.label.setEnabled(1)
            self.value.setEnabled(1)
            self.disableBtn.setFlat(0)
            self.disableBtn.setText("X")
 
    def changed(self,index):
        #self.prop.setValue(self.value.currentText())
        self.prop.value[0] = self.value.currentText()
        self.valueChanged.emit()

    def getValue(self):
        return self.value.currentText()

    def setValue(self,val):
        self.prop.setValue(val)
        return self.value.setCurrentText(val)

    def getIndex(self):
        return self.value.currentIndex()       

    def setProperty(self,prop):
        self.prop = prop
        self.value.setCurrentText(self.prop.value[0])


# Int Attribute
class IntAttribute(QWidget):
    valueChanged = pyqtSignal()


    def __init__(self,prop):
        super().__init__()
        self.prop = prop
        self.label = QLabel(self.prop.vname)
        self.value = QLineEdit()
        self.value.setFixedWidth(80)
        if self.prop.min is not None and self.prop.max is not None:
            self.validator = QIntValidator(self.prop.min,self.prop.max)
            self.value.setValidator(self.validator)
        self.value.setText("%d"%self.prop.value)
        self.disableBtn = QPushButton("X")
        self.disableBtn.setFixedWidth(30)

        self.setToolTip(self.prop.desc)
       
        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(self.label)
        hbox.addWidget(self.value)
        hbox.addWidget(self.disableBtn)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        # connections
        self.value.editingFinished.connect(self.changed)
        self.disableBtn.clicked.connect(self.toggleEnabled)

    def enabled(self):
        return self.label.isEnabled()


    def hideDisableButton(self,hide):
        if(hide):
            self.disableBtn.setVisible(0)
        else:
            self.disableBtn.setVisible(1)

    def toggleEnabled(self):
        if(self.label.isEnabled()):
            self.prop.enabled = 0
            self.label.setEnabled(0)
            self.value.setEnabled(0)
            self.disableBtn.setFlat(1)
            self.disableBtn.setText("O")
        else:
            self.prop.enabled = 1
            self.label.setEnabled(1)
            self.value.setEnabled(1)
            self.disableBtn.setFlat(0)
            self.disableBtn.setText("X")
 
    def changed(self):
        self.prop.value = int(self.value.text())
        self.valueChanged.emit()

    def getValue(self):
        return int(self.prop.value)

    def setValue(self,val):
        self.prop.value = val
        self.value.setText("%d"%val)

    def setProperty(self,prop):
        self.prop = prop
        self.value.setText(self.prop.value[0])


# Float Attribute
class FloatAttribute(QWidget):
    valueChanged = pyqtSignal()


    def __init__(self,prop):
        super().__init__()
        self.prop = prop
        self.label = QLabel(self.prop.vname)
        self.value = QLineEdit()
        self.value.setFixedWidth(80)
        if self.prop.min is not None and self.prop.max is not None:
            self.validator = QDoubleValidator(self.prop.min,self.prop.max,4)
            self.value.setValidator(self.validator)
        self.value.setText("%f"%self.prop.value)
        self.disableBtn = QPushButton("X")
        self.disableBtn.setFixedWidth(30)

        self.setToolTip(self.prop.desc)
       
        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(self.label)
        hbox.addWidget(self.value)
        hbox.addWidget(self.disableBtn)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        # connections
        self.value.editingFinished.connect(self.changed)
        self.disableBtn.clicked.connect(self.toggleEnabled)

    def enabled(self):
        return self.label.isEnabled()


    def hideDisableButton(self,hide):
        if(hide):
            self.disableBtn.setVisible(0)
        else:
            self.disableBtn.setVisible(1)

    def toggleEnabled(self):
        if(self.label.isEnabled()):
            self.prop.enabled = 0
            self.label.setEnabled(0)
            self.value.setEnabled(0)
            self.disableBtn.setFlat(1)
            self.disableBtn.setText("O")
        else:
            self.prop.enabled = 1
            self.label.setEnabled(1)
            self.value.setEnabled(1)
            self.disableBtn.setFlat(0)
            self.disableBtn.setText("X")
 
    def changed(self):
        self.prop.value = float(self.value.text())
        self.valueChanged.emit()

    def getValue(self):
        return float(self.prop.value)

    def setValue(self,val):
        self.prop.value = val
        self.value.setText("%f"%val)

    def loadProperty(self):
        self.value.setText(self.prop.value[0])

    def setProperty(self,prop):
        self.prop = prop
        self.value.setText(self.prop.value[0])


# String Attribute
class StringAttribute(QWidget):
    valueChanged = pyqtSignal()

    def __init__(self,prop):
        super().__init__()
        self.prop = prop
        self.label = QLabel(self.prop.vname)
        self.value = QLineEdit()
        self.value.setFixedWidth(80)
        self.value.setText(self.prop.value[0])
        self.disableBtn = QPushButton("X")
        self.disableBtn.setFixedWidth(30)

        self.setToolTip(self.prop.desc)
       
        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(self.label)
        hbox.addWidget(self.value)
        hbox.addWidget(self.disableBtn)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        # connections
        self.value.editingFinished.connect(self.changed)
        self.disableBtn.clicked.connect(self.toggleEnabled)

    def enabled(self):
        return self.label.isEnabled()


    def hideDisableButton(self,hide):
        if(hide):
            self.disableBtn.setVisible(0)
        else:
            self.disableBtn.setVisible(1)

    def toggleEnabled(self):
        if(self.label.isEnabled()):
            self.prop.enabled = 0
            self.label.setEnabled(0)
            self.value.setEnabled(0)
            self.disableBtn.setFlat(1)
            self.disableBtn.setText("O")
        else:
            self.prop.enabled = 1
            self.label.setEnabled(1)
            self.value.setEnabled(1)
            self.disableBtn.setFlat(0)
            self.disableBtn.setText("X")
 
    def changed(self):
        self.prop.value = self.value.text()
        self.valueChanged.emit()

    def getValue(self):
        return self.prop.value

    def setValue(self,val):
        self.prop.value = val
        self.value.setText(val)

    def setProperty(self,prop):
        self.prop = prop
        self.value.setText(self.prop.value[0])

# File Attribute
class FileAttribute(QWidget):
    valueChanged = pyqtSignal()

    def __init__(self,prop):
        super().__init__()
        self.prop = prop
        label = QLabel(self.prop.vname)
        self.value = QPushButton("browse")
        if len(self.prop.value) > 0:
            self.value.setText(self.prop.value[0])
        self.value.setFixedWidth(150)
        #self.value.setText(self.prop.value)
 
        self.setToolTip(self.prop.desc)
              
        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(label)
        hbox.addWidget(self.value)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        # connections
        self.value.clicked.connect(self.getFile)

    def getFile(self):
        filename = QFileDialog.getOpenFileName(self,"Open Ply Mesh",".","Ply Files (*.ply)")
        self.value.setText(filename[0])
        self.prop.value[0] = self.value.text()
        self.valueChanged.emit()

    def getValue(self):
        return self.prop.value

    def setValue(self,val):
        self.prop.value = val
        self.value.setText(val)

    def setProperty(self,prop):
        self.prop = prop
        self.value.setText(self.prop.value[0])

'''
# EDITOR ATTRIBUTES

# MATERIAL EDITORS

# MATERIAL COMMON BOX 
class MaterialCommonBox(QGroupBox):
    valuesChanged = pyqtSignal()

    def __init__(self,name,lux):
        super().__init__("common")
        self.name = name
        self.lux = lux
        self.props = MaterialCommonProps() 

        self.id = IntAttribute(self.props.id) 
        self.bumpTex = TextureAttribute(self.props.bumptex,self.lux) 
        self.normalTex = TextureAttribute(self.props.normaltex,self.lux) 
 
        vbox = QVBoxLayout()
        vbox.addWidget(self.id)
        vbox.addWidget(self.bumpTex)
        vbox.addWidget(self.normalTex)
        vbox.setContentsMargins(0,0,0,0)
        vbox.setSpacing(0)

        self.setLayout(vbox)

        self.id.valueChanged.connect(self.valueChanged)
        self.bumpTex.valueChanged.connect(self.valueChanged)
        self.normalTex.valueChanged.connect(self.valueChanged)

    def valueChanged(self):
        self.props.id.setValue(self.id.getColorValue())
        self.props.bumptex.setValue(self.bumpTex.getColorValue())
        self.props.normaltex.setValue(self.normalTex.getColorValue())
        self.valuesChanged.emit() 

    def loadProps(self):
        self.props = self.lux.core().getMaterialProperties("materialcommon",self.name)
        self.id.setProperty(self.props.id)
        self.bumpTex.setProperty(self.props.bumptex)
        self.normalTex.setProperty(self.props.normaltex)

    def verify(self):
        self.lux.core().verifyProperty("scene.materials." + self.name + ".id", self.props.id)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".bumptex", self.props.bumptex)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".normaltex", self.props.normaltex)


# MATERIAL EMISSION BOX 
class MaterialEmissionBox(QGroupBox):
    valuesChanged = pyqtSignal()

    def __init__(self,name,lux):
        super().__init__("emission")
        self.name = name
        self.lux = lux
        self.props = MaterialEmissionProps() 

        self.emission = TextureAttribute(self.props.emission,self.lux) 
        self.emissiongain = TextureAttribute(self.props.emissiongain,self.lux) 
        self.emissionpower = IntAttribute(self.props.emissionpower) 
        self.emissionefficency = IntAttribute(self.props.emissionefficency) 
 
        vbox = QVBoxLayout()
        vbox.addWidget(self.emission)
        vbox.addWidget(self.emissiongain)
        vbox.addWidget(self.emissionpower)
        vbox.addWidget(self.emissionefficency)
        vbox.setContentsMargins(0,0,0,0)
        vbox.setSpacing(0)

        self.setLayout(vbox)

        self.emission.valueChanged.connect(self.valueChanged)
        self.emissiongain.valueChanged.connect(self.valueChanged)
        self.emissionpower.valueChanged.connect(self.valueChanged)
        self.emissionefficency.valueChanged.connect(self.valueChanged)


    def valueChanged(self):
        self.props.emission.setValue(self.emission.getColorValue())
        self.props.emissiongain.setValue(self.emissiongain.getColorValue())
        self.props.emissionpower.setValue(self.emissionpower.getValue())
        self.props.emissionefficency.setValue(self.emissionefficency.getValue())
        self.valuesChanged.emit() 

    def loadProps(self):
        self.props = self.lux.core().getMaterialProperties("materialemission",self.name)
        self.emission.setProperty(self.props.emission)
        self.emissiongain.setProperty(self.props.emissiongain)
        self.emissionpower.setProperty(self.props.emissionpower)
        self.emissionefficency.setProperty(self.props.emissionefficency)

    def verify(self):
        self.lux.core().verifyProperty("scene.materials." + self.name + ".emission", self.props.emission)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".emission.gain", self.props.emissiongain)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".emission.power", self.props.emissionpower)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".emission.efficency", self.props.emissionefficency)


# matte
class MatteEditor(QWidget):

    def __init__(self,name,lux):
        super().__init__()
        self.name = name
        self.lux = lux
        self.props = MatteProps()
        self.kd = TextureAttribute(self.props.kd,self.lux)
        self.common = MaterialCommonBox(self.name,self.lux)
        self.emission = MaterialEmissionBox(self.name,self.lux)


        vbox = QVBoxLayout()
        vbox.addWidget(self.kd)
        vbox.setContentsMargins(0,0,0,0)
        vbox.setSpacing(0)

        gbox = QGroupBox("matte")
        gbox.setLayout(vbox)
    
        mvbox = QVBoxLayout(self)
        mvbox.addWidget(gbox)
        mvbox.addWidget(self.common)
        mvbox.addWidget(self.emission)
        mvbox.addStretch()
        mvbox.setContentsMargins(0,0,0,0)
        mvbox.setSpacing(0)

        self.kd.valueChanged.connect(self.valueChanged)
        self.common.valuesChanged.connect(self.valueChanged)
        self.emission.valuesChanged.connect(self.valueChanged)

    def setName(self,name):
        self.name = name
        self.common.name = name
        self.emission.name = name

    def valueChanged(self):
        self.props.kd.setValue(self.kd.getColorValue())
        props = "scene.materials." + self.name + ".type = \"matte\"\n"
        props += self.props.getPropertyString(self.name)
        props += self.emission.props.getPropertyString(self.name)
        self.lux.core().setProperties(props)

    def loadProps(self):
        self.verify()
        self.props = self.lux.core().getMaterialProperties("matte",self.name)
        self.kd.setProperty(self.props.kd)

    def verify(self):
        self.lux.core().verifyProperty("scene.materials." + self.name + ".kd", self.props.kd)
        self.common.verify()
        self.emission.verify()


# carpaint 
class CarPaintEditor(QWidget):

    def __init__(self,name,lux):
        super().__init__()
        self.name = name
        self.lux = lux
        self.props = CarPaintProps()
        self.preset = OptionAttribute(self.props.preset,["ford f8","polaris sliber","opei titan","bmw339","2k acrylack","white","blue","blue matte"])
        self.ka = TextureAttribute(self.props.ka,self.lux)
        self.d = TextureAttribute(self.props.d,self.lux)
        self.kd = TextureAttribute(self.props.kd,self.lux)
        self.ks1 = TextureAttribute(self.props.ks1,self.lux)
        self.ks2 = TextureAttribute(self.props.ks2,self.lux)
        self.ks3 = TextureAttribute(self.props.ks3,self.lux)
        self.r1 = TextureAttribute(self.props.r1,self.lux)
        self.r2 = TextureAttribute(self.props.r2,self.lux)
        self.r3 = TextureAttribute(self.props.r3,self.lux)
        self.m1 = TextureAttribute(self.props.m1,self.lux)
        self.m2 = TextureAttribute(self.props.m2,self.lux)
        self.m3 = TextureAttribute(self.props.m3,self.lux)

        self.common = MaterialCommonBox(self.name,self.lux)
        self.emission = MaterialEmissionBox(self.name,self.lux)


        self.ka.toggleEnabled()
        self.d.toggleEnabled()
        self.kd.toggleEnabled()
        self.ks1.toggleEnabled()
        self.ks2.toggleEnabled()
        self.ks3.toggleEnabled()
        self.r1.toggleEnabled()
        self.r2.toggleEnabled()
        self.r3.toggleEnabled()
        self.m1.toggleEnabled()
        self.m2.toggleEnabled()
        self.m3.toggleEnabled()

        vbox = QVBoxLayout()
        vbox.addWidget(self.preset)
        vbox.addWidget(self.ka)
        vbox.addWidget(self.d)
        vbox.addWidget(self.kd)
        vbox.addWidget(self.ks1)
        vbox.addWidget(self.ks2)
        vbox.addWidget(self.ks3)
        vbox.addWidget(self.r1)
        vbox.addWidget(self.r2)
        vbox.addWidget(self.r3)
        vbox.addWidget(self.m1)
        vbox.addWidget(self.m2)
        vbox.addWidget(self.m3)

        vbox.setContentsMargins(0,0,0,0)
        vbox.setSpacing(0)

        gbox = QGroupBox("carpaint")
        gbox.setLayout(vbox)
    
        mvbox = QVBoxLayout(self)
        mvbox.addWidget(gbox)
        mvbox.addWidget(self.common)
        mvbox.addWidget(self.emission)
        mvbox.addStretch()
        mvbox.setContentsMargins(0,0,0,0)
        mvbox.setSpacing(0)

        self.preset.valueChanged.connect(self.valueChanged)
        self.ka.valueChanged.connect(self.valueChanged)
        self.d.valueChanged.connect(self.valueChanged)
        self.kd.valueChanged.connect(self.valueChanged)
        self.ks1.valueChanged.connect(self.valueChanged)
        self.ks2.valueChanged.connect(self.valueChanged)
        self.ks3.valueChanged.connect(self.valueChanged)
        self.r1.valueChanged.connect(self.valueChanged)
        self.r2.valueChanged.connect(self.valueChanged)
        self.r3.valueChanged.connect(self.valueChanged)
        self.m1.valueChanged.connect(self.valueChanged)
        self.m2.valueChanged.connect(self.valueChanged)
        self.m3.valueChanged.connect(self.valueChanged)
        self.common.valuesChanged.connect(self.valueChanged)
        self.emission.valuesChanged.connect(self.valueChanged)

    def setName(self,name):
        self.name = name
        self.common.name = name
        self.emission.name = name

    def valueChanged(self):
        self.props.preset.setValue(self.preset.getValue())
        self.props.ka.setValue(self.ka.getColorValue())
        self.props.d.setValue(self.d.getColorValue())
        self.props.kd.setValue(self.kd.getColorValue())
        self.props.ks1.setValue(self.ks1.getColorValue())
        self.props.ks2.setValue(self.ks2.getColorValue())
        self.props.ks3.setValue(self.ks3.getColorValue())
        self.props.r1.setValue(self.r1.getColorValue())
        self.props.r2.setValue(self.r2.getColorValue())
        self.props.r3.setValue(self.r3.getColorValue())
        self.props.m1.setValue(self.m1.getColorValue())
        self.props.m2.setValue(self.m2.getColorValue())
        self.props.m3.setValue(self.m3.getColorValue())

        props = "scene.materials." + self.name + ".type = \"carpaint\"\n"
        props += self.props.getPropertyString(self.name)
        props += self.common.props.getPropertyString(self.name)
        props += self.emission.props.getPropertyString(self.name)
        self.lux.core().setProperties(props)

    def loadProps(self):
        self.verify()
        self.props = self.lux.core().getMaterialProperties("carpaint",self.name)
        self.ka.setProperty(self.props.ka)
        self.d.setProperty(self.props.d)
        self.kd.setProperty(self.props.kd)
        self.ks1.setProperty(self.props.ks1)
        self.ks2.setProperty(self.props.ks2)
        self.ks3.setProperty(self.props.ks3)
        self.r1.setProperty(self.props.r1)
        self.r2.setProperty(self.props.r2)
        self.r3.setProperty(self.props.r3)
        self.m1.setProperty(self.props.m1)
        self.m2.setProperty(self.props.m2)
        self.m3.setProperty(self.props.m3)

    def verify(self):
        self.lux.core().verifyProperty("scene.materials." + self.name + ".preset", self.props.preset)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".ka", self.props.ka)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".d", self.props.d)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".kd", self.props.kd)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".ks1", self.props.ks1)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".ks2", self.props.ks2)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".ks3", self.props.ks3)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".r1", self.props.r1)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".r2", self.props.r2)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".r3", self.props.r3)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".m1", self.props.m1)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".m2", self.props.m2)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".m3", self.props.m3)
        self.common.verify()
        self.emission.verify()
 

# glass
class GlassEditor(QWidget):

    def __init__(self,name,lux):
        super().__init__()
        self.name = name
        self.lux = lux
        self.props = GlassProps()
        self.kr = TextureAttribute(self.props.kr,self.lux)
        self.kt = TextureAttribute(self.props.kt,self.lux)
        self.interior = TextureAttribute(self.props.interior,self.lux)
        self.exterior = TextureAttribute(self.props.exterior,self.lux)
        self.common = MaterialCommonBox(self.name,self.lux)
        self.emission = MaterialEmissionBox(self.name,self.lux)

        vbox = QVBoxLayout()
        vbox.addWidget(self.kr)
        vbox.addWidget(self.kt)
        vbox.addWidget(self.interior)
        vbox.addWidget(self.exterior)
        vbox.setContentsMargins(0,0,0,0)
        vbox.setSpacing(0)

        gbox = QGroupBox("glass")
        gbox.setLayout(vbox)
    
        mvbox = QVBoxLayout(self)
        mvbox.addWidget(gbox)
        mvbox.addWidget(self.common)
        mvbox.addWidget(self.emission)
        mvbox.addStretch()
        mvbox.setContentsMargins(0,0,0,0)
        mvbox.setSpacing(0)

        self.kr.valueChanged.connect(self.valueChanged)
        self.kt.valueChanged.connect(self.valueChanged)
        self.interior.valueChanged.connect(self.valueChanged)
        self.exterior.valueChanged.connect(self.valueChanged)
        self.common.valuesChanged.connect(self.valueChanged)
        self.emission.valuesChanged.connect(self.valueChanged)

    def setName(self,name):
        self.name = name
        self.common.name = name
        self.emission.name = name

    def valueChanged(self):
        self.props.kr.setValue(self.kr.getColorValue())
        self.props.kt.setValue(self.kt.getColorValue())
        self.props.interior.setValue(self.interior.getColorValue())
        self.props.exterior.setValue(self.exterior.getColorValue())
        props = "scene.materials." + self.name + ".type = \"glass\"\n"
        props += self.props.getPropertyString(self.name)
        props += self.common.props.getPropertyString(self.name)
        props += self.emission.props.getPropertyString(self.name)
        self.lux.core().setProperties(props)

    def loadProps(self):
        self.verify()
        self.props = self.lux.core().getMaterialProperties("glass",self.name)
        self.kr.setProperty(self.props.kr)
        self.kt.setProperty(self.props.kt)
        self.interior.setProperty(self.props.interior)
        self.exterior.setProperty(self.props.exterior)
 
    def verify(self):
        self.lux.core().verifyProperty("scene.materials." + self.name + ".kr", self.props.kr)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".kt", self.props.kt)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".interior", self.props.interior)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".exterior", self.props.exterior)
        self.common.verify()
        self.emission.verify()


# glossy2 
class Glossy2Editor(QWidget):

    def __init__(self,name,lux):
        super().__init__()
        self.name = name
        self.lux = lux
        self.props = Glossy2Props()
        self.kd = TextureAttribute(self.props.kd,self.lux)
        self.ks = TextureAttribute(self.props.ks,self.lux)
        self.uroughness = TextureAttribute(self.props.uroughness,self.lux)
        self.vroughness = TextureAttribute(self.props.vroughness,self.lux)
        self.common = MaterialCommonBox(self.name,self.lux)
        self.emission = MaterialEmissionBox(self.name,self.lux)

        vbox = QVBoxLayout()
        vbox.addWidget(self.kd)
        vbox.addWidget(self.ks)
        vbox.addWidget(self.uroughness)
        vbox.addWidget(self.vroughness)
        vbox.setContentsMargins(0,0,0,0)
        vbox.setSpacing(0)

        gbox = QGroupBox("glossy2")
        gbox.setLayout(vbox)
    
        mvbox = QVBoxLayout(self)
        mvbox.addWidget(gbox)
        mvbox.addWidget(self.common)
        mvbox.addWidget(self.emission)
        mvbox.addStretch()
        mvbox.setContentsMargins(0,0,0,0)
        mvbox.setSpacing(0)

        self.kd.valueChanged.connect(self.valueChanged)
        self.ks.valueChanged.connect(self.valueChanged)
        self.uroughness.valueChanged.connect(self.valueChanged)
        self.vroughness.valueChanged.connect(self.valueChanged)
        self.common.valuesChanged.connect(self.valueChanged)
        self.emission.valuesChanged.connect(self.valueChanged)

    def setName(self,name):
        self.name = name
        self.common.name = name
        self.emission.name = name

    def valueChanged(self):
        self.props.kd.setValue(self.kd.getColorValue())
        self.props.ks.setValue(self.ks.getColorValue())
        self.props.uroughness.setValue(self.uroughness.getColorValue())
        self.props.vroughness.setValue(self.vroughness.getColorValue())
        props = "scene.materials." + self.name + ".type = \"glossy2\"\n"
        props += self.props.getPropertyString(self.name)
        props += self.common.props.getPropertyString(self.name)
        props += self.emission.props.getPropertyString(self.name)
        #print("SETTING GLOSSY2")
        #print(props)
        self.lux.core().setProperties(props)

    def loadProps(self):
        self.verify()
        self.props = self.lux.core().getMaterialProperties("glossy2",self.name)
        self.kd.setProperty(self.props.kd)
        self.ks.setProperty(self.props.ks)
        self.uroughness.setProperty(self.props.uroughness)
        self.vroughness.setProperty(self.props.vroughness)

    def verify(self):
        self.lux.core().verifyProperty("scene.materials." + self.name + ".kd", self.props.kd)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".ks", self.props.ks)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".uroughness", self.props.uroughness)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".vroughness", self.props.vroughness)
        self.common.verify()
        self.emission.verify()


# Mix 
class MaterialMixEditor(QWidget):

    def __init__(self,name,lux):
        super().__init__()
        self.name = name
        self.lux = lux
        self.props = MaterialMixProps()
        self.material1 = StringAttribute(self.props.material1)
        self.material2 = StringAttribute(self.props.material2)
        self.amount = TextureAttribute(self.props.amount,self.lux)
        #self.common = MaterialCommonBox(self.name,self.lux)
        #self.emission = MaterialEmissionBox(self.name,self.lux)


        vbox = QVBoxLayout()
        vbox.addWidget(self.material1)
        vbox.addWidget(self.material2)
        vbox.addWidget(self.amount)
        vbox.setContentsMargins(0,0,0,0)
        vbox.setSpacing(0)

        gbox = QGroupBox("mix")
        gbox.setLayout(vbox)
    
        mvbox = QVBoxLayout(self)
        mvbox.addWidget(gbox)
        #mvbox.addWidget(self.common)
        #mvbox.addWidget(self.emission)
        mvbox.addStretch()
        mvbox.setContentsMargins(0,0,0,0)
        mvbox.setSpacing(0)

        self.material1.valueChanged.connect(self.valueChanged)
        self.material2.valueChanged.connect(self.valueChanged)
        self.amount.valueChanged.connect(self.valueChanged)
        #self.common.valuesChanged.connect(self.valueChanged)
        #self.emission.valuesChanged.connect(self.valueChanged)

    def setName(self,name):
        self.name = name
        #self.common.name = name
        #self.emission.name = name

    def valueChanged(self):
        self.props.material1.setValue(self.material1.getValue())
        self.props.material2.setValue(self.material2.getValue())
        self.props.amount.setValue(self.amount.getColorValue())
        props = "scene.materials." + self.name + ".type = \"mix\"\n"
        props += self.props.getPropertyString(self.name)
        #props += self.common.props.getPropertyString(self.name)
        #props += self.emission.props.getPropertyString(self.name)
        self.lux.core().setProperties(props)

    def loadProps(self):
        self.verify()
        self.props = self.lux.core().getMaterialProperties("mix",self.name)
        self.material1.setProperty(self.props.material1)
        self.material2.setProperty(self.props.material2)
        self.amount.setProperty(self.props.amount)

    def verify(self):
        self.lux.core().verifyProperty("scene.materials." + self.name + ".material1", self.props.material1)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".material2", self.props.material2)
        self.lux.core().verifyProperty("scene.materials." + self.name + ".amount", self.props.amount)
        #self.common.verify()
        #self.emission.verify()
'''


'''
# template 
class MaterialTemplateEditor(QWidget):

    def __init__(self,name,lux):
        super().__init__()
        self.name = name
        self.lux = lux
        self.props = MatteProps()
        #self.kd = TextureAttribute(self.props.kd,self.lux)
        self.common = MaterialCommonBox(self.name,self.lux)
        self.emission = MaterialEmissionBox(self.name,self.lux)


        vbox = QVBoxLayout()
        #vbox.addWidget(self.kd)
        vbox.setContentsMargins(0,0,0,0)
        vbox.setSpacing(0)

        gbox = QGroupBox("template")
        gbox.setLayout(vbox)
    
        mvbox = QVBoxLayout(self)
        mvbox.addWidget(gbox)
        mvbox.addWidget(self.common)
        mvbox.addWidget(self.emission)
        mvbox.addStretch()
        mvbox.setContentsMargins(0,0,0,0)
        mvbox.setSpacing(0)

        #self.kd.valueChanged.connect(self.valueChanged)
        self.common.valuesChanged.connect(self.valueChanged)
        self.emission.valuesChanged.connect(self.valueChanged)

    def setName(self,name):
        self.name = name
        self.common.name = name
        self.emission.name = name

    def valueChanged(self):
        self.props.kd.setValue(self.kd.getColorValue())
        #props = "scene.materials." + self.name + ".type = \"matte\"\n"
        props += self.props.getPropertyString(self.name)
        props += self.emission.props.getPropertyString(self.name)
        self.lux.core().setProperties(props)

    def loadProps(self):
        self.verify()
        #self.props = self.lux.core().getMaterialProperties("matte",self.name)
        #self.kd.setProperty(self.props.kd)

    def verify(self):
        #self.lux.core().verifyProperty("scene.materials." + self.name + ".kd", self.props.kd)
        self.common.verify()
        self.emission.verify()
'''

'''
# TEXTURE EDITORS 

class ImageMapEditor(QWidget):

    def __init__(self,name,lux):
        super().__init__()
        self.name = name
        self.lux = lux
        self.props = ImageMapProps()
        self.setFixedWidth(250)
        self.file = FileAttribute(self.props.file)
        self.gamma = FloatAttribute(self.props.gamma) 
        self.gain = FloatAttribute(self.props.gain) 

        vbox = QVBoxLayout(self)
        vbox.addWidget(self.file)
        vbox.addWidget(self.gamma)
        vbox.addWidget(self.gain)
        vbox.addStretch()

        self.file.valueChanged.connect(self.valueChanged)
        self.gamma.valueChanged.connect(self.valueChanged)
        self.gain.valueChanged.connect(self.valueChanged)


    def setName(self,name):
        self.name = name

    def valueChanged(self):
        self.props.file.setValue(self.file.getValue())
        self.props.gamma.setValue(self.gamma.getValue())
        self.props.gain.setValue(self.gain.getValue())
        self.lux.core().setProperties(self.props.getPropertyString(self.name))


    def loadProps(self):
        self.verify()
        self.props = self.lux.core().getTextureProperties("imagemap",self.name)
        self.file.setProperty(self.props.file)
        self.gamma.setProperty(self.props.gamma)
        self.gain.setProperty(self.props.gain)

    def verify(self):
        self.lux.core().verifyProperty("scene.textures." + self.name + ".file", self.props.file)
        self.lux.core().verifyProperty("scene.textures." + self.name + ".gamma", self.props.gamma)
        self.lux.core().verifyProperty("scene.textures." + self.name + ".gain", self.props.gain)


class MaterialEditor(QWidget):

    def __init__(self,mtype,lux):
        super().__init__()
        self.lux = lux
        self.name = ""
        self.mtype = Property('type', 'string', None, None, "matte")
        self.materialtype = OptionAttribute(self.mtype,["matte","carpaint","glass","glossy2","mix"])
        self.materialtype.hideDisableButton(1)

        self.stack = QStackedWidget()
        self.stack.addWidget(QFrame()) # base
        # Materials
        self.stack.addWidget(MatteEditor("",self.lux))
        self.stack.addWidget(CarPaintEditor("",self.lux))
        self.stack.addWidget(GlassEditor("",self.lux))
        self.stack.addWidget(Glossy2Editor("",self.lux))
        self.stack.addWidget(MaterialMixEditor("",self.lux))

        self.vbox = QVBoxLayout(self)
        self.vbox.addWidget(self.materialtype)
        self.vbox.addWidget(self.stack)
        self.vbox.addStretch()
        self.vbox.setContentsMargins(0,0,0,0)
        self.vbox.setSpacing(0)

        self.materialtype.valueChanged.connect(self.materialChanged)

    def materialChanged(self):
        #mtype = self.materialtype.getValue()
        #call = "scene.materials.%s.type = \"%s\"\n"%(self.name,mtype)
        #if(mtype == 'mix'):
        #    call += "scene.materials.%s.material1 = \"luxed_default_mat\"\n"%self.name
        #    call += "scene.materials.%s.material2 = \"luxed_default_mat\"\n"%self.name

        #print("CALL = " + call)
        #self.lux.core().setProperties(call)
        self.setEditor(self.name,self.materialtype.getValue())

    def setEditor(self,name,luxtype):
        self.name = name
        self.stack.setCurrentIndex(0)

        # Materials
        if luxtype == 'matte':
            self.stack.widget(1).setName(name)
            self.stack.widget(1).loadProps()
            self.stack.setCurrentIndex(1)
            self.stack.widget(1).valueChanged()
            self.materialtype.setValue('matte')
        if luxtype == 'carpaint':
            self.stack.widget(2).setName(name)
            self.stack.widget(2).loadProps()
            self.stack.setCurrentIndex(2)
            self.stack.widget(2).valueChanged()
            self.materialtype.setValue('carpaint')
        if luxtype == 'glass':
            self.stack.widget(3).setName(name)
            self.stack.widget(3).loadProps()
            self.stack.setCurrentIndex(3)
            self.stack.widget(3).valueChanged()
            self.materialtype.setValue('glass')
        if luxtype == 'glossy2':
            self.stack.widget(4).setName(name)
            self.stack.widget(4).loadProps()
            self.stack.setCurrentIndex(4)
            self.stack.widget(4).valueChanged()
            self.materialtype.setValue('glossy2')
        if luxtype == 'mix':
            self.stack.widget(5).setName(name)
            self.stack.widget(5).loadProps()
            self.stack.setCurrentIndex(5)
            self.stack.widget(5).valueChanged()
            self.materialtype.setValue('mix')
''' 
# DOCKS

# ATTRIBUTE EDITOR DOCK

class AttributeEditor(QDockWidget):

    def __init__(self,lux):
        super().__init__()
        self.lux = lux
        self.setWindowTitle("Attribute Editor")
        self.label = QLabel("----")
        self.label.setFont(QFont("Sans",12))
        self.label.setAlignment(Qt.AlignCenter)
        self.label.setFrameStyle(QFrame.Panel | QFrame.Raised)
        palette = QPalette()
        palette.setColor(QPalette.Base,QColor(1,0,0))
        self.label.setPalette(palette)

        frame = QFrame()

        self.stack = QStackedWidget()
        self.stack.addWidget(QFrame()) # base
        # Materials
        #self.stack.addWidget(MaterialEditor("",self.lux)) # matte material
        # ...
        # Textures
        #self.stack.addWidget(ImageMapEditor("",self.lux)) # imagemap texture
        # ...

        self.vbox = QVBoxLayout()
        self.vbox.addWidget(self.label)
        self.vbox.addWidget(self.stack)
        self.vbox.addStretch()
        self.vbox.setContentsMargins(0,0,0,0)
        self.vbox.setSpacing(0)

        frame.setLayout(self.vbox)
        self.setWidget(frame)

    def setEditor(self,luxtype,subtype,name):
        self.label.setText(name)
        self.stack.setCurrentIndex(0)

        # Materials
        if luxtype == 'material':
            self.stack.widget(1).setEditor(name,self.lux.core().getMaterialType(name)[0])
            self.stack.setCurrentIndex(1)

        # Textures
        if luxtype == 'texture':
            self.stack.widget(2).setName(name)
            self.stack.setCurrentIndex(2)


# NODE ATTRIBUTE LOADER
class NodeAttributeLoader(QWidget):
    nodeChanged = pyqtSignal()

    def __init__(self,lux,node):
        super().__init__()
        self.vbox = QVBoxLayout()
        self.lux = lux
        self.label = QLabel("name:")
        self.vbox.addWidget(self.label)
        self.setLayout(self.vbox)
        self.node = None

    def load(self,node):
        self.node = node

        for i in reversed(range(self.vbox.count())):
            self.vbox.itemAt(i).widget().setParent(None)
        self.vbox.addWidget(self.label)

        for prop in self.node.props:
            if prop.vtype is 'string':
                # is it a type option?
                if prop.vname is 'type':
                    attribute = OptionAttribute(prop)
                    attribute.valueChanged.connect(self.updateNode)
                    self.vbox.addWidget(attribute)
                elif prop.vname is 'material':
                    matlist = self.lux.sg.getNames('materials')
                    attribute = OptionAttribute(prop,matlist)
                    attribute.valueChanged.connect(self.updateNode)
                    self.vbox.addWidget(attribute)
                elif prop.vname is 'ply':
                    attribute = FileAttribute(prop)
                    attribute.valueChanged.connect(self.updateNode)
                    self.vbox.addWidget(attribute)
                else:
                    attribute = StringAttribute(prop)
                    attribute.valueChanged.connect(self.updateNode)
                    self.vbox.addWidget(attribute)
            if prop.vtype is 'int':
                attribute = IntAttribute(prop)
                attribute.valueChanged.connect(self.updateNode)
                self.vbox.addWidget(attribute)        
            if prop.vtype is 'float':
                attribute = FloatAttribute(prop)
                attribute.valueChanged.connect(self.updateNode)
                self.vbox.addWidget(attribute)        
            if prop.vtype is 'texture':
                attribute = TextureAttribute(prop,self.lux)
                attribute.valueChanged.connect(self.updateNode)
                self.vbox.addWidget(attribute)        
            if prop.vtype is 'spectrum':
                attribute = FloatAttribute(prop)
                attribute.valueChanged.connect(self.updateNode)
                self.vbox.addWidget(attribute)        

    def updateNode(self):
        self.nodeChanged.emit()

# NODE EDITOR DOCK

class NodeEditor(QDockWidget):

    def __init__(self,lux):
        super().__init__()
        self.lux = lux
        self.setWindowTitle("Node Editor")
        self.label = QLabel("----")
        self.label.setFont(QFont("Sans",12))
        self.label.setAlignment(Qt.AlignCenter)
        self.label.setFrameStyle(QFrame.Panel | QFrame.Raised)
        palette = QPalette()
        palette.setColor(QPalette.Base,QColor(1,0,0))
        self.label.setPalette(palette)
        self.attributes = NodeAttributeLoader(self.lux,None)
        self.node = None

        frame = QFrame()

        self.vbox = QVBoxLayout()
        self.vbox.addWidget(self.label)
        self.vbox.addWidget(self.attributes)
        self.vbox.addStretch()
        self.vbox.setContentsMargins(0,0,0,0)
        self.vbox.setSpacing(0)

        frame.setLayout(self.vbox)
        self.setWidget(frame)
        
        self.attributes.nodeChanged.connect(self.nodeUpdate)

    def load(self):
        self.node = self.lux.sg.getNode(name)
        self.attributes.load(self.node)

    def setEditor(self,name):
        self.label.setText(name)
        self.node = self.lux.sg.getNode(name)
        self.attributes.load(self.node)

    def nodeUpdate(self):
        self.lux.sg.lux.setProperties(self.node.getPropertyString())

# ADD DIALOG
class AddNodeDialog(QDialog):
    nodeAdded = pyqtSignal(['QString','QString','QString'])

    def __init__(self,ntype):
        super().__init__()
        #self.setFixedWidth(400)
        #self.setFixedHeight(400)
        self.setWindowTitle("Add Node")
        self.name = QLineEdit()
        self.vtype = QComboBox()

        self.addBtn = QPushButton("Add")
        self.cancelBtn = QPushButton("Cancel")
        self.ntype = ntype
        
        gbox = QGridLayout()
        gbox.addWidget(QLabel("name:"),0,0)
        gbox.addWidget(QLabel("type:"),1,0)
        gbox.addWidget(self.name,0,1)
        gbox.addWidget(self.vtype,1,1)
        vbox = QVBoxLayout()
        vbox.addLayout(gbox)
        vbox.addWidget(self.addBtn)
        vbox.addWidget(self.cancelBtn)
        self.setLayout(vbox)

        self.setType(self.ntype)
        self.addBtn.clicked.connect(self.setNode)
        self.cancelBtn.clicked.connect(self.reject)
        self.hide()

    def setType(self,ntype):
        self.ntype = ntype
        self.vtype.clear() 
        if self.ntype == 'objects':
            self.vtype.addItem('ply')
            self.vtype.addItem('stl')
        if self.ntype == 'materials':
            self.vtype.addItem('matte')
            self.vtype.addItem('glossy2')
        if self.ntype == 'textures':
            self.vtype.addItem('imagemap')


    def setNode(self):
        self.nodeAdded.emit(self.name.text(),self.ntype,self.vtype.currentText())
        self.hide()


# SCENE LAYOUT DOCK

class SceneLayout(QDockWidget):
    objectSelected = pyqtSignal(['QString'])
    materialSelected = pyqtSignal(['QString'])
    textureSelected = pyqtSignal(['QString'])
    lightSelected = pyqtSignal(['QString'])

    def __init__(self,lux):
        super().__init__()
        self.lux = lux
        self.setWindowTitle("Scene Layout")
        frame = QFrame(self)
        self.tabs = QTabWidget()
        self.objects = QListWidget()
        self.materials = QListWidget()
        self.textures = QListWidget()
        self.lights = QListWidget()
        self.addBtn = QPushButton("+")
        self.removeBtn = QPushButton("-")
        self.renameBtn = QPushButton("rename")

        self.tabs.addTab(self.objects,"objects")
        self.tabs.addTab(self.materials,"materials")
        self.tabs.addTab(self.textures, "textures")
        self.tabs.addTab(self.lights, "lights")
        self.tabs.setTabPosition(QTabWidget.North)

        hbox = QHBoxLayout()
        hbox.addWidget(self.renameBtn)
        hbox.addWidget(self.addBtn)
        hbox.addWidget(self.removeBtn)

        vbox = QVBoxLayout(self) 
        frame.setLayout(vbox)
        vbox.addWidget(self.tabs)
        vbox.addLayout(hbox)

        self.setWidget(frame)

        self.addNodeDialog = AddNodeDialog(self.tabs.tabText(self.tabs.currentIndex()))

        self.objects.itemClicked.connect(self.objectChanged)
        self.materials.itemClicked.connect(self.materialChanged)
        self.textures.itemClicked.connect(self.textureChanged)
        self.lights.itemClicked.connect(self.lightChanged)
        self.renameBtn.clicked.connect(self.rename)
        self.addBtn.clicked.connect(self.add)
        self.removeBtn.clicked.connect(self.remove)
        self.addNodeDialog.nodeAdded.connect(self.addNode)

    def addNode(self,name,ntype,vtype):
        print("%s, %s, %s node to add"%(name,ntype,vtype))
        self.lux.sg.addNode(name,ntype,vtype)
        self.updateTabs()

    def add(self):
        #self.lux.sg.addObject()
        #node = Node(name,ntype)
        #node.addProperty(Property(ntype,name, attribute, luxprop, vtype, vmin, vmax, vdefault, desc=""))
        #if ntype is 'objects':
        #    node.addProperty(Property(node.ntype,'mat_test', 'type', None, 'string', None, None, ["matte"], desc="Test"))
        #    node.addProperty(Property(node.ntype,'mat_test', 'kd', None, 'texture', None, None, [1,0,0], desc="Test"))

        # Open AddDialog
        self.addNodeDialog.setType(self.tabs.tabText(self.tabs.currentIndex()))
        self.addNodeDialog.exec()
        self.updateTabs()

        # THIS WAS ALL TESTING CODE
        '''
        ballmat = Node('ballmat','materials')
        ballmat.addProperty(Property(ballmat.ntype, ballmat.name, 'type', None, 'string', None, None, ["matte"], desc="Test"))
        ballmat.addProperty(Property(ballmat.ntype, ballmat.name, 'kd', None, 'texture', None, None, [1,0,0], desc="Test"))
        # light
        lightmat = Node('lightmat','materials') 
        lightmat.addProperty(Property(lightmat.ntype, lightmat.name, 'type', None, 'string', None, None, ["matte"], desc="Test"))
        lightmat.addProperty(Property(lightmat.ntype, lightmat.name, 'kd', None, 'texture', None, None, [1,1,1], desc="Test"))
        lightmat.addProperty(Property(lightmat.ntype, lightmat.name, 'emission', None, 'texture', None, None, [1,1,1], desc="Test"))
        lightmat.addProperty(Property(lightmat.ntype, lightmat.name, 'emission.gain', None, 'texture', None, None, [1,1,1], desc="Test"))
        lightmat.addProperty(Property(lightmat.ntype, lightmat.name, 'emission.power', None, 'int', None, None, [1000], desc="Test"))
        lightmat.addProperty(Property(lightmat.ntype, lightmat.name, 'emission.efficency', None, 'int', None, None, [1], desc="Test"))
        # ball object
        ballobj = Node('ballobj','objects') 
        ballobj.addProperty(Property(ballobj.ntype, ballobj.name, 'material', None, 'string', None, None, [ballmat.name], desc="Test"))
        ballobj.addProperty(Property(ballobj.ntype, ballobj.name, 'ply', None, 'string', None, None, ["mesh/outer_ball.ply"], desc="Test"))
        # light object 
        lightobj = Node('lightobj','objects') 
        lightobj.addProperty(Property(lightobj.ntype, lightobj.name, 'material', None, 'string', None, None, [lightmat.name], desc="Test"))
        lightobj.addProperty(Property(lightobj.ntype, lightobj.name, 'ply', None, 'string', None, None, ["mesh/light_left.ply"], desc="Test"))

        self.lux.sg.beginEdit()
        self.lux.sg.addNode(ballmat)
        self.lux.sg.addNode(ballobj)
        self.lux.sg.addNode(lightmat)
        self.lux.sg.addNode(lightobj)
        self.lux.sg.endEdit()
        self.lux.sg.getNode(ballmat)

        # TESTING
        self.lux.sg.beginEdit()
        self.lux.sg.lux.setColor(ballmat.props[1].luxprop,[0,1,0])
        self.lux.sg.endEdit()
 
        self.lux.sg.lux.getColor(ballmat.props[1].luxprop)
        '''
        self.updateTabs() 

    def remove(self):
        pass

    def rename(self):
        pass
 
    def updateTabs(self):
        # Objects
        print("updateTabs")
        self.objects.clear()
        objects = self.lux.sg.getNames('objects')
        materials = self.lux.sg.getNames('materials')


        for o in objects:
            self.objects.addItem(o)

        # Materials
        self.materials.clear()
        for m in materials:
            self.materials.addItem(m)

        # Materials
        self.textures.clear()
        for t in self.lux.sg.getNames('textures'):
            self.textures.addItem(t)

        # Materials
        self.lights.clear()
        for l in self.lux.sg.getNames('lights'):
            self.lights.addItem(l)

    def objectChanged(self,item):
        self.objectSelected.emit(item.text())

    def materialChanged(self,item):
        self.materialSelected.emit(item.text())

    def textureChanged(self,item):
        self.textureSelected.emit(item.text())

    def lightChanged(self,item):
        self.lightSelected.emit(item.text())


# RENDER SETTINGS

'''
# RENDER ENGINE BOX 
class RenderEngineBox(QGroupBox):
    valueChanged = pyqtSignal()

    def __init__(self,props):
        super().__init__("render engine")
        self.props = props
        self.engineType = OptionAttribute(self.props.enginetype,["PATHCPU","BIASPATHCPU","BIDIRCPU","PATHOCL","RTPATHOCL","BIASPATHOCL","RTBIASPATHOCL"])
        self.engineType.hideDisableButton(1)
        self.cpuThreads = IntAttribute(self.props.cputhreads)
        self.cpuThreads.hideDisableButton(1)

        # CPU

        # PATHCPU attributes
        # path.maxdepth
        self.pathMaxDepth = IntAttribute(self.props.pathmaxdepth)
        self.pathMaxDepth.hideDisableButton(1)
        # path.russianroulette.depth
        self.pathRussianRouletteDepth = IntAttribute(self.props.pathrussianroulettedepth)
        self.pathRussianRouletteDepth.hideDisableButton(1)
        # path.russianroulette.cap
        self.pathRussianRouletteCap = FloatAttribute(self.props.pathrussianroulettecap)
        self.pathRussianRouletteCap.hideDisableButton(1)
        # path.clamping.variance.maxvalue
        self.pathClampingVarianceMaxValue = FloatAttribute(self.props.pathclampingvariancemaxvalue)
        self.pathClampingVarianceMaxValue.hideDisableButton(1)
        #path.clamping.pdf.value
        self.pathClampingPdfValue = FloatAttribute(self.props.pathclampingpdfvalue)
        self.pathClampingPdfValue.hideDisableButton(1)
        #path.fastpixelfilter.enable 
        self.pathFastPixelFilterEnable = IntAttribute(self.props.pathfastpixelfilterenable)
        self.pathFastPixelFilterEnable.hideDisableButton(1)
        # BIASPATHCPU
        self.biaspathPathDepthTotal = IntAttribute(self.props.biaspathpathdepthtotal)
        self.biaspathPathDepthTotal.hideDisableButton(1)
        self.biaspathPathDepthDiffuse = IntAttribute(self.props.biaspathpathdepthdiffuse) 
        self.biaspathPathDepthDiffuse.hideDisableButton(1)
        self.biaspathPathDepthGlossy = IntAttribute(self.props.biaspathpathdepthglossy) 
        self.biaspathPathDepthGlossy.hideDisableButton(1)
        self.biaspathPathDepthSpecular = IntAttribute(self.props.biaspathpathdepthspecular) 
        self.biaspathPathDepthSpecular.hideDisableButton(1)
        self.biaspathSamplingAASize = IntAttribute(self.props.biaspathsamplingaasize) 
        self.biaspathSamplingAASize.hideDisableButton(1)
        self.biaspathSamplingDiffuseSize = IntAttribute(self.props.biaspathsamplingdiffusesize) 
        self.biaspathSamplingDiffuseSize.hideDisableButton(1)
        self.biaspathSamplingGlossySize = IntAttribute(self.props.biaspathsamplingglossysize) 
        self.biaspathSamplingGlossySize.hideDisableButton(1)
        self.biaspathSamplingSpecularSize = IntAttribute(self.props.biaspathsamplingspecularsize) 
        self.biaspathSamplingSpecularSize.hideDisableButton(1)
        self.biaspathSamplingDirectLightSize = IntAttribute(self.props.biaspathsamplingdirectlightsize) 
        self.biaspathSamplingDirectLightSize.hideDisableButton(1)
        self.biaspathLightsLowThreshold = FloatAttribute(self.props.biaspathlightslowthreshold) 
        self.biaspathLightsLowThreshold.hideDisableButton(1)
        self.biaspathLightsNearStart = FloatAttribute(self.props.biaspathlightsnearstart) 
        self.biaspathLightsNearStart.hideDisableButton(1)
        self.biaspathLightsFirstVertexSamples = IntAttribute(self.props.biaspathlightsfirstvertexsamples) 
        self.biaspathLightsFirstVertexSamples.hideDisableButton(1)
        self.biaspathClampingVarianceMaxValue = FloatAttribute(self.props.biaspathclampingvariancemaxvalue) 
        self.biaspathClampingVarianceMaxValue.hideDisableButton(1)
        self.biaspathClampingPdfValue = FloatAttribute(self.props.biaspathclampingpdfvalue) 
        self.biaspathClampingPdfValue.hideDisableButton(1)
        self.tileSize = IntAttribute(self.props.tilesize) 
        self.tileSize.hideDisableButton(1)
        self.tileSizeX = IntAttribute(self.props.tilesizex) 
        self.tileSizeX.hideDisableButton(1)
        self.tileSizeY = IntAttribute(self.props.tilesizey) 
        self.tileSizeY.hideDisableButton(1)
        self.tileMultipassEnable = IntAttribute(self.props.tilemultipassenable) 
        self.tileMultipassEnable.hideDisableButton(1)
        self.tileMultipassConvergenceTestThreshold = FloatAttribute(self.props.tilemultipassconvergencetestthreshold) 
        self.tileMultipassConvergenceTestThreshold.hideDisableButton(1)
        self.tileMultipassConvergenceTestThreshold256 = FloatAttribute(self.props.tilemultipassconvergencetestthreshold256) 
        self.tileMultipassConvergenceTestThreshold256.hideDisableButton(1)
        self.tileMultipassConvergenceTestThresholdReduction = FloatAttribute(self.props.tilemultipassconvergencetestthresholdreduction) 
        self.tileMultipassConvergenceTestThresholdReduction.hideDisableButton(1)
        self.tileMultipassConvergenceTestWarmupCount = IntAttribute(self.props.tilemultipassconvergencetestwarmupcount) 
        self.tileMultipassConvergenceTestWarmupCount.hideDisableButton(1)

        # OPENCL

        # common
        self.openclPlatformIndex = IntAttribute(self.props.openclplatformindex)
        self.openclPlatformIndex.hideDisableButton(1)
        self.openclCpuUse = IntAttribute(self.props.openclcpuuse)
        self.openclCpuUse.hideDisableButton(1)
        self.openclGpuUse = IntAttribute(self.props.openclgpuuse)
        self.openclGpuUse.hideDisableButton(1)
        self.openclCpuWorkGroupSize = IntAttribute(self.props.openclcpuworkgroupsize)
        self.openclCpuWorkGroupSize.hideDisableButton(1)
        self.openclGpuWorkGroupSize = IntAttribute(self.props.openclgpuworkgroupsize)
        self.openclGpuWorkGroupSize.hideDisableButton(1)
        self.openclDevicesSelect = StringAttribute(self.props.opencldevicesselect)
        self.openclDevicesSelect.hideDisableButton(1)


        vbox = QVBoxLayout()
        vbox.addWidget(self.engineType)
        vbox.addWidget(self.cpuThreads)
        # PATHCPU
        vbox.addWidget(self.pathMaxDepth)
        vbox.addWidget(self.pathRussianRouletteDepth)
        vbox.addWidget(self.pathRussianRouletteCap)
        vbox.addWidget(self.pathClampingVarianceMaxValue)
        vbox.addWidget(self.pathClampingPdfValue)
        vbox.addWidget(self.pathFastPixelFilterEnable)
        # BIASPATHCPU
        vbox.addWidget(self.biaspathPathDepthTotal)
        vbox.addWidget(self.biaspathPathDepthDiffuse)
        vbox.addWidget(self.biaspathPathDepthGlossy)
        vbox.addWidget(self.biaspathPathDepthSpecular)
        vbox.addWidget(self.biaspathSamplingAASize)
        vbox.addWidget(self.biaspathSamplingDiffuseSize)
        vbox.addWidget(self.biaspathSamplingGlossySize)
        vbox.addWidget(self.biaspathSamplingSpecularSize)
        vbox.addWidget(self.biaspathSamplingDirectLightSize)
        vbox.addWidget(self.biaspathLightsLowThreshold)
        vbox.addWidget(self.biaspathLightsNearStart)
        vbox.addWidget(self.biaspathLightsFirstVertexSamples)
        vbox.addWidget(self.biaspathClampingVarianceMaxValue)
        vbox.addWidget(self.biaspathClampingPdfValue)
        vbox.addWidget(self.tileSize)
        vbox.addWidget(self.tileSizeX)
        vbox.addWidget(self.tileSizeY)
        vbox.addWidget(self.tileMultipassEnable)
        vbox.addWidget(self.tileMultipassConvergenceTestThreshold)
        vbox.addWidget(self.tileMultipassConvergenceTestThreshold256)
        vbox.addWidget(self.tileMultipassConvergenceTestThresholdReduction)
        vbox.addWidget(self.tileMultipassConvergenceTestWarmupCount)
    
        # OPENCL
    
        # common
        vbox.addWidget(self.openclPlatformIndex)
        vbox.addWidget(self.openclCpuUse)
        vbox.addWidget(self.openclGpuUse)
        vbox.addWidget(self.openclCpuWorkGroupSize)
        vbox.addWidget(self.openclGpuWorkGroupSize)
        vbox.addWidget(self.openclDevicesSelect)

        vbox.setContentsMargins(0,0,0,0)
        vbox.setSpacing(0)

        self.setLayout(vbox)

        self.engineType.valueChanged.connect(self.updateSettings)
        self.cpuThreads.valueChanged.connect(self.updateSettings)
        self.pathMaxDepth.valueChanged.connect(self.updateSettings)
        self.pathRussianRouletteDepth.valueChanged.connect(self.updateSettings)
        self.pathRussianRouletteCap.valueChanged.connect(self.updateSettings)
        self.pathClampingVarianceMaxValue.valueChanged.connect(self.updateSettings)
        self.pathClampingPdfValue.valueChanged.connect(self.updateSettings)
        self.pathFastPixelFilterEnable.valueChanged.connect(self.updateSettings)
        # BIASPATHCPU
        self.biaspathPathDepthTotal.valueChanged.connect(self.updateSettings)
        self.biaspathPathDepthDiffuse.valueChanged.connect(self.updateSettings)
        self.biaspathPathDepthGlossy.valueChanged.connect(self.updateSettings)
        self.biaspathPathDepthSpecular.valueChanged.connect(self.updateSettings)
        self.biaspathSamplingAASize.valueChanged.connect(self.updateSettings)
        self.biaspathSamplingDiffuseSize.valueChanged.connect(self.updateSettings)
        self.biaspathSamplingGlossySize.valueChanged.connect(self.updateSettings)
        self.biaspathSamplingSpecularSize.valueChanged.connect(self.updateSettings)
        self.biaspathSamplingDirectLightSize.valueChanged.connect(self.updateSettings)
        self.biaspathLightsLowThreshold.valueChanged.connect(self.updateSettings)
        self.biaspathLightsNearStart.valueChanged.connect(self.updateSettings)
        self.biaspathLightsFirstVertexSamples.valueChanged.connect(self.updateSettings)
        self.biaspathClampingVarianceMaxValue.valueChanged.connect(self.updateSettings)
        self.biaspathClampingPdfValue.valueChanged.connect(self.updateSettings)
        self.tileSize.valueChanged.connect(self.updateSettings)
        self.tileSizeX.valueChanged.connect(self.updateSettings)
        self.tileSizeY.valueChanged.connect(self.updateSettings)
        self.tileMultipassEnable.valueChanged.connect(self.updateSettings)
        self.tileMultipassConvergenceTestThreshold.valueChanged.connect(self.updateSettings)
        self.tileMultipassConvergenceTestThreshold256.valueChanged.connect(self.updateSettings)
        self.tileMultipassConvergenceTestThresholdReduction.valueChanged.connect(self.updateSettings)
        self.tileMultipassConvergenceTestWarmupCount.valueChanged.connect(self.updateSettings)

        # OPENCL

        # common
        self.openclPlatformIndex.valueChanged.connect(self.updateSettings)
        self.openclCpuUse.valueChanged.connect(self.updateSettings)
        self.openclGpuUse.valueChanged.connect(self.updateSettings)
        self.openclCpuWorkGroupSize.valueChanged.connect(self.updateSettings)
        self.openclGpuWorkGroupSize.valueChanged.connect(self.updateSettings)
        self.openclDevicesSelect.valueChanged.connect(self.updateSettings)

        self.hideAll()
        self.updateSettings()

    def hideAll(self):
        self.cpuThreads.hide()
        # PATHCPU
        self.pathMaxDepth.hide()
        self.pathRussianRouletteDepth.hide()
        self.pathRussianRouletteCap.hide()
        self.pathClampingVarianceMaxValue.hide()
        self.pathClampingPdfValue.hide()
        self.pathFastPixelFilterEnable.hide()
        # BIASPATHCPU
        self.biaspathPathDepthTotal.hide()
        self.biaspathPathDepthDiffuse.hide()
        self.biaspathPathDepthGlossy.hide()
        self.biaspathPathDepthSpecular.hide()
        self.biaspathSamplingAASize.hide()
        self.biaspathSamplingDiffuseSize.hide()
        self.biaspathSamplingGlossySize.hide()
        self.biaspathSamplingSpecularSize.hide()
        self.biaspathSamplingDirectLightSize.hide()
        self.biaspathLightsLowThreshold.hide()
        self.biaspathLightsNearStart.hide()
        self.biaspathLightsFirstVertexSamples.hide()
        self.biaspathClampingVarianceMaxValue.hide()
        self.biaspathClampingPdfValue.hide()
        self.tileSize.hide()
        self.tileSizeX.hide()
        self.tileSizeY.hide()
        self.tileMultipassEnable.hide()
        self.tileMultipassConvergenceTestThreshold.hide()
        self.tileMultipassConvergenceTestThreshold256.hide()
        self.tileMultipassConvergenceTestThresholdReduction.hide()
        self.tileMultipassConvergenceTestWarmupCount.hide()

        # OPENCL

        # common
        #self.openclPlatformIndex.hide()
        #self.openclCpuUse.hide()
        #self.openclGpuUse.hide()
        #self.openclCpuWorkGroupSize.hide()
        #self.openclGpuWorkGroupSize.hide()
        #self.openclDevicesSelect.hide()



    def updateSettings(self):
        self.hideAll()
        self.props.enginetype.setValue(self.engineType.getValue())

        if(self.engineType.getValue() == 'PATHCPU'):
            self.props.cputhreads.setValue(self.cpuThreads.getValue())
            self.props.pathmaxdepth.setValue(self.pathMaxDepth.getValue())
            self.props.pathrussianroulettedepth.setValue(self.pathRussianRouletteDepth.getValue())
            self.props.pathrussianroulettecap.setValue(self.pathRussianRouletteCap.getValue())
            self.props.pathclampingvariancemaxvalue.setValue(self.pathClampingVarianceMaxValue.getValue())
            self.props.pathclampingpdfvalue.setValue(self.pathClampingPdfValue.getValue())
            self.props.pathfastpixelfilterenable.setValue(self.pathFastPixelFilterEnable.getValue())
            self.cpuThreads.show()
            self.pathMaxDepth.show()
            self.pathRussianRouletteDepth.show()
            self.pathRussianRouletteCap.show()
            self.pathClampingVarianceMaxValue.show()
            self.pathClampingPdfValue.show()
            self.pathFastPixelFilterEnable.show()
 
        if(self.engineType.getValue() == 'BIASPATHCPU'):
            self.props.cputhreads.setValue(self.cpuThreads.getValue())
            self.props.biaspathpathdepthtotal.setValue(self.biaspathPathDepthTotal.getValue()) 
            self.props.biaspathpathdepthdiffuse.setValue(self.biaspathPathDepthDiffuse.getValue()) 
            self.props.biaspathpathdepthglossy.setValue(self.biaspathPathDepthGlossy.getValue()) 
            self.props.biaspathpathdepthspecular.setValue(self.biaspathPathDepthSpecular.getValue()) 
            self.props.biaspathsamplingaasize.setValue(self.biaspathSamplingAASize.getValue()) 
            self.props.biaspathsamplingdiffusesize.setValue(self.biaspathSamplingDiffuseSize.getValue()) 
            self.props.biaspathsamplingglossysize.setValue(self.biaspathSamplingGlossySize.getValue()) 
            self.props.biaspathsamplingspecularsize.setValue(self.biaspathSamplingSpecularSize.getValue()) 
            self.props.biaspathsamplingdirectlightsize.setValue(self.biaspathSamplingDirectLightSize.getValue()) 
            self.props.biaspathlightslowthreshold.setValue(self.biaspathLightsLowThreshold.getValue()) 
            self.props.biaspathlightsnearstart.setValue(self.biaspathLightsNearStart.getValue()) 
            self.props.biaspathlightsfirstvertexsamples.setValue(self.biaspathLightsFirstVertexSamples.getValue()) 
            self.props.biaspathclampingvariancemaxvalue.setValue(self.biaspathClampingVarianceMaxValue.getValue()) 
            self.props.biaspathclampingpdfvalue.setValue(self.biaspathClampingPdfValue.getValue()) 
            self.props.tilesize.setValue(self.tileSize.getValue()) 
            self.props.tilesizex.setValue(self.tileSizeX.getValue()) 
            self.props.tilesizey.setValue(self.tileSizeY.getValue()) 
            self.props.tilemultipassenable.setValue(self.tileMultipassEnable.getValue()) 
            self.props.tilemultipassconvergencetestthreshold.setValue(self.tileMultipassConvergenceTestThreshold.getValue()) 
            self.props.tilemultipassconvergencetestthreshold256.setValue(self.tileMultipassConvergenceTestThreshold256.getValue()) 
            self.props.tilemultipassconvergencetestthresholdreduction.setValue(self.tileMultipassConvergenceTestThresholdReduction.getValue()) 
            self.props.tilemultipassconvergencetestwarmupcount.setValue(self.tileMultipassConvergenceTestWarmupCount.getValue()) 
            # show 
            self.cpuThreads.show()
            self.biaspathPathDepthTotal.show()
            self.biaspathPathDepthDiffuse.show()
            self.biaspathPathDepthGlossy.show()
            self.biaspathPathDepthSpecular.show()
            self.biaspathSamplingAASize.show()
            self.biaspathSamplingDiffuseSize.show()
            self.biaspathSamplingGlossySize.show()
            self.biaspathSamplingSpecularSize.show()
            self.biaspathSamplingDirectLightSize.show()
            self.biaspathLightsLowThreshold.show()
            self.biaspathLightsNearStart.show()
            self.biaspathLightsFirstVertexSamples.show()
            self.biaspathClampingVarianceMaxValue.show()
            self.biaspathClampingPdfValue.show()
            self.tileSize.show()
            self.tileSizeX.show()
            self.tileSizeY.show()
            self.tileMultipassEnable.show()
            self.tileMultipassConvergenceTestThreshold.show()
            self.tileMultipassConvergenceTestThreshold256.show()
            self.tileMultipassConvergenceTestThresholdReduction.show()
            self.tileMultipassConvergenceTestWarmupCount.show()

        if(self.engineType.getValue() == 'PATHOCL'):
            # common
            self.props.openclplatformindex.setValue(self.openclPlatformIndex.getValue())
            self.props.openclcpuuse.setValue(self.openclCpuUse.getValue())
            self.props.openclgpuuse.setValue(self.openclGpuUse.getValue())
            self.props.openclcpuworkgroupsize.setValue(self.openclCpuWorkGroupSize.getValue())
            self.props.openclgpuworkgroupsize.setValue(self.openclGpuWorkGroupSize.getValue())
            self.props.opencldevicesselect.setValue(self.openclDevicesSelect.getValue())
            self.openclPlatformIndex.show()
            self.openclCpuUse.show()
            self.openclGpuUse.show()
            self.openclCpuWorkGroupSize.show()
            self.openclGpuWorkGroupSize.show()
            self.openclDevicesSelect.show()

        if(self.engineType.getValue() == 'RTPATHOCL'):
            # common
            self.props.openclplatformindex.setValue(self.openclPlatformIndex.getValue())
            self.props.openclcpuuse.setValue(self.openclCpuUse.getValue())
            self.props.openclgpuuse.setValue(self.openclGpuUse.getValue())
            self.props.openclcpuworkgroupsize.setValue(self.openclCpuWorkGroupSize.getValue())
            self.props.openclgpuworkgroupsize.setValue(self.openclGpuWorkGroupSize.getValue())
            self.props.opencldevicesselect.setValue(self.openclDevicesSelect.getValue())
            self.openclPlatformIndex.show()
            self.openclCpuUse.show()
            self.openclGpuUse.show()
            self.openclCpuWorkGroupSize.show()
            self.openclGpuWorkGroupSize.show()
            self.openclDevicesSelect.show()

        if(self.engineType.getValue() == 'BIASPATHOCL'):
            # common
            self.props.openclplatformindex.setValue(self.openclPlatformIndex.getValue())
            self.props.openclcpuuse.setValue(self.openclCpuUse.getValue())
            self.props.openclgpuuse.setValue(self.openclGpuUse.getValue())
            self.props.openclcpuworkgroupsize.setValue(self.openclCpuWorkGroupSize.getValue())
            self.props.openclgpuworkgroupsize.setValue(self.openclGpuWorkGroupSize.getValue())
            self.props.opencldevicesselect.setValue(self.openclDevicesSelect.getValue())
            self.openclPlatformIndex.show()
            self.openclCpuUse.show()
            self.openclGpuUse.show()
            self.openclCpuWorkGroupSize.show()
            self.openclGpuWorkGroupSize.show()
            self.openclDevicesSelect.show()

        if(self.engineType.getValue() == 'RTBIASPATHOCL'):
            # common
            self.props.openclplatformindex.setValue(self.openclPlatformIndex.getValue())
            self.props.openclcpuuse.setValue(self.openclCpuUse.getValue())
            self.props.openclgpuuse.setValue(self.openclGpuUse.getValue())
            self.props.openclcpuworkgroupsize.setValue(self.openclCpuWorkGroupSize.getValue())
            self.props.openclgpuworkgroupsize.setValue(self.openclGpuWorkGroupSize.getValue())
            self.props.opencldevicesselect.setValue(self.openclDevicesSelect.getValue())
            self.openclPlatformIndex.show()
            self.openclCpuUse.show()
            self.openclGpuUse.show()
            self.openclCpuWorkGroupSize.show()
            self.openclGpuWorkGroupSize.show()
            self.openclDevicesSelect.show()

        self.valueChanged.emit() 



# SAMPLER BOX 
class SamplerBox(QGroupBox):
    valueChanged = pyqtSignal()

    def __init__(self,props):
        super().__init__("sampler")
        self.props = props

        self.samplerType = OptionAttribute(self.props.samplertype,["SOBOL","METROPOLIS","RANDOM"])
        self.samplerType.hideDisableButton(1)
        self.metropolisLargestEpRate = FloatAttribute(self.props.metropolislargesteprate)
        self.metropolisLargestEpRate.hideDisableButton(1)
        self.metropolisMaxConsecutiveReject = IntAttribute(self.props.metropolismaxconsecutivereject)
        self.metropolisMaxConsecutiveReject.hideDisableButton(1)
        self.metropolisImageMutationRate = FloatAttribute(self.props.metropolisimagemutationrate)
        self.metropolisImageMutationRate.hideDisableButton(1)
 
        vbox = QVBoxLayout()
        vbox.addWidget(self.samplerType)
        vbox.addWidget(self.metropolisLargestEpRate)
        vbox.addWidget(self.metropolisMaxConsecutiveReject)
        vbox.addWidget(self.metropolisImageMutationRate)
        vbox.setContentsMargins(0,0,0,0)
        vbox.setSpacing(0)

        self.setLayout(vbox)

        self.samplerType.valueChanged.connect(self.updateSettings)
        self.samplerType.setValue(self.props.samplertype.value)
        self.metropolisLargestEpRate.valueChanged.connect(self.updateSettings)
        self.metropolisMaxConsecutiveReject.valueChanged.connect(self.updateSettings)
        self.metropolisImageMutationRate.valueChanged.connect(self.updateSettings)
 
    def updateSettings(self):
        self.props.samplertype.setValue(self.samplerType.getValue())
        self.props.metropolislargesteprate.setValue(self.metropolisLargestEpRate.getValue())
        self.props.metropolismaxconsecutivereject.setValue(self.metropolisMaxConsecutiveReject.getValue())
        self.props.metropolisimagemutationrate.setValue(self.metropolisImageMutationRate.getValue())

        if(self.samplerType.getValue() == 'METROPOLIS'):
            self.metropolisLargestEpRate.show()
            self.metropolisMaxConsecutiveReject.show()
            self.metropolisImageMutationRate.show()
        else:
            self.metropolisLargestEpRate.hide()
            self.metropolisMaxConsecutiveReject.hide()
            self.metropolisImageMutationRate.hide()

        self.valueChanged.emit() 


# FILTER BOX 
class FilterBox(QGroupBox):
    valueChanged = pyqtSignal()

    def __init__(self,props):
        super().__init__("filter")
        self.props = props

        self.filterType = OptionAttribute(self.props.samplertype,["NONE","BOX","GAUSSIAN","MITCHELL","MITCHELL_SS","BLACKMANHARRIS"])
        self.filterType.hideDisableButton(1) 
 
        vbox = QVBoxLayout()
        vbox.addWidget(self.filterType)
        vbox.setContentsMargins(0,0,0,0)
        vbox.setSpacing(0)

        self.setLayout(vbox)

        self.filterType.valueChanged.connect(self.updateSettings)
        self.filterType.setValue(self.props.filtertype.value)

    def updateSettings(self):
        self.props.filtertype.setValue(self.filterType.getValue())
        self.valueChanged.emit() 
'''

class RenderSettings(QDockWidget):
    objectSelected = pyqtSignal(['QString'])

    def __init__(self,lux):
        super().__init__()
        self.lux = lux
        self.setWindowTitle("Render Settings")

        self.props = self.lux.sg.lux.getRenderSettings()

        self.preset = QComboBox()
        self.preset.addItem("custom")
        self.preset.addItem("4:3 low res")
        self.preset.addItem("1:79 low res")
        self.preset.addItem("2.39 low res")
        self.preset.addItem("4:3 med res")
        self.preset.addItem("1:79 med res")
        self.preset.addItem("2.39 med res")
        self.preset.addItem("4:3 hd")
        self.preset.addItem("1:79 hd")
        self.preset.addItem("2.39 hd")
        self.preset.addItem("4:3 4k")
        self.preset.addItem("1:79 4k")
        self.preset.addItem("2.39 4k")

        frame = QFrame()
        self.renderWidth = IntAttribute(self.lux.sg.getRenderProperty('film','width'))
        self.renderWidth.hideDisableButton(1)
        self.renderHeight = IntAttribute(self.lux.sg.getRenderProperty('film','height'))
        self.renderHeight.hideDisableButton(1)
        #self.engine = RenderEngineBox(self.props)
        #self.sampler = SamplerBox(self.props)
        #self.filter = FilterBox(self.props)

        # Engine 
        self.engine = QGroupBox('engine')
        self.engineType = OptionAttribute(self.lux.sg.getRenderProperty('renderengine','type'),['PATHCPU','BIASPATHCPU','BIDIRCPU','PATHOCL','RTPATHOCL','BIASPATHOCL','RTBIASPATHOCL'])
        self.engineType.hideDisableButton(1)
        self.enginevbox = QVBoxLayout()
        self.enginevbox.addWidget(self.engineType)
        self.enginevbox.setContentsMargins(0,0,0,0)
        self.enginevbox.setSpacing(0)
        self.engine.setLayout(self.enginevbox)
 
        # Sampler
        self.sampler = QGroupBox('sampler')
        self.samplerType = OptionAttribute(self.lux.sg.getRenderProperty('sampler','type'),["SOBOL","METROPOLIS","RANDOM"])
        self.samplerType.hideDisableButton(1)
        self.samplervbox = QVBoxLayout()
        self.samplervbox.addWidget(self.samplerType)
        self.samplervbox.setContentsMargins(0,0,0,0)
        self.samplervbox.setSpacing(0)
        self.sampler.setLayout(self.samplervbox)
 
        vbox = QVBoxLayout()
        vbox.addWidget(QLabel("Presets"))
        vbox.addWidget(self.preset)
        vbox.addWidget(self.renderWidth)
        vbox.addWidget(self.renderHeight)
        vbox.addWidget(self.engine)
        vbox.addWidget(self.sampler)
        vbox.addStretch()
        vbox.setSpacing(0)

        frame.setLayout(vbox)
        self.setWidget(frame)

        #self.sampler.updateSettings()
        #self.filter.updateSettings()

        self.renderWidth.valueChanged.connect(self.updateSettings)
        self.renderHeight.valueChanged.connect(self.updateSettings)
        self.engineType.valueChanged.connect(self.updateEngine)
        self.samplerType.valueChanged.connect(self.updateSampler)
        #self.filter.valueChanged.connect(self.updateSettings)

        self.updateEngine()
        self.updateSampler()


    def updateEngine(self):
        for i in reversed(range(self.enginevbox.count())):
            self.enginevbox.itemAt(i).widget().setParent(None)
        self.enginevbox.addWidget(self.engineType)
        if self.engineType.getValue() == 'PATHCPU':
            maxdepth = IntAttribute(self.lux.sg.getRenderProperty('path','maxdepth'))
            russianroulettedepth = IntAttribute(self.lux.sg.getRenderProperty('path','russianroulette.depth'))
            russianroulettecap = FloatAttribute(self.lux.sg.getRenderProperty('path','russianroulette.cap'))
            clampingvariancemaxvalue = FloatAttribute(self.lux.sg.getRenderProperty('path','clamping.variance.maxvalue'))
            clampingpdfvalue = FloatAttribute(self.lux.sg.getRenderProperty('path','clamping.pdf.value'))
            fastpixelfilterenable = IntAttribute(self.lux.sg.getRenderProperty('path','fastpixelfilter.enable'))

            maxdepth.valueChanged.connect(self.updateSettings)
            russianroulettedepth.valueChanged.connect(self.updateSettings)
            russianroulettecap.valueChanged.connect(self.updateSettings)
            clampingvariancemaxvalue.valueChanged.connect(self.updateSettings)
            clampingpdfvalue.valueChanged.connect(self.updateSettings)
            fastpixelfilterenable.valueChanged.connect(self.updateSettings)

            self.enginevbox.addWidget(maxdepth)
            self.enginevbox.addWidget(russianroulettedepth)
            self.enginevbox.addWidget(russianroulettecap)
            self.enginevbox.addWidget(clampingvariancemaxvalue)
            self.enginevbox.addWidget(clampingpdfvalue)
            self.enginevbox.addWidget(fastpixelfilterenable)

 
    def updateSampler(self):
        for i in reversed(range(self.samplervbox.count())):
            self.samplervbox.itemAt(i).widget().setParent(None)
        self.samplervbox.addWidget(self.samplerType)
        if self.samplerType.getValue() == 'METROPOLIS':
            largesteprate = FloatAttribute(self.lux.sg.getRenderProperty('sampler.metropolis','largesteprate'))
            maxconsecutivereject = IntAttribute(self.lux.sg.getRenderProperty('sampler.metropolis','maxconsecutivereject'))
            imagemutationrate = FloatAttribute(self.lux.sg.getRenderProperty('sampler.metropolis','largesteprate'))
 
            largesteprate.valueChanged.connect(self.updateSettings)
            maxconsecutivereject.valueChanged.connect(self.updateSettings)
            imagemutationrate.valueChanged.connect(self.updateSettings)

            self.samplervbox.addWidget(largesteprate)
            self.samplervbox.addWidget(maxconsecutivereject)
            self.samplervbox.addWidget(imagemutationrate)
 
        
    def updateSettings(self):
        print("Updating Render Settings")
        self.lux.setRenderSettings()

class TimeEditor(QWidget):
    frameChanged = pyqtSignal(['int'])

    def __init__(self,lux):
        super().__init__()
        self.sframe = QLineEdit()
        self.eframe = QLineEdit()
        self.cframe = QLabel()
        self.slider = QSlider(Qt.Horizontal)

        self.sframe.setFixedWidth(50)
        self.eframe.setFixedWidth(50)

        self.framevalidator = QIntValidator(-10000,10000)
        self.sframe.setValidator(self.framevalidator)
        self.eframe.setValidator(self.framevalidator)
 
        self.sframe.setText('1')
        self.eframe.setText('24')
        self.cframe.setText('1')

        self.cframe.setFont(QFont("Sans",12))
        self.cframe.setAlignment(Qt.AlignCenter)
        self.cframe.setFrameStyle(QFrame.Panel | QFrame.Raised)
 
        vbox = QVBoxLayout(self)
        vbox.addWidget(self.cframe)
        hbox = QHBoxLayout()
        hbox.addWidget(self.sframe)
        hbox.addWidget(self.slider)
        hbox.addWidget(self.eframe)
        vbox.addLayout(hbox) 

        self.slider.setMinimum(int(self.sframe.text()))
        self.slider.setMaximum(int(self.eframe.text()))
        self.slider.valueChanged.connect(self.setCurrentFrame)

    def setCurrentFrame(self,val):
        self.cframe.setText("%d"%val)
        self.frameChanged.emit(val)


# MAIN MENU

# FILE ACTIONS
class FileNewAction(QAction):

    def __init__(self,parent):
        super().__init__("New",parent)
        self.triggered.connect(self.doit)

    def doit(self):
        print("New")


class FileSaveAction(QAction):

    def __init__(self,parent):
        super().__init__("Save",parent)
        self.triggered.connect(self.doit)

    def doit(self):
        print("Save")

class FileExitAction(QAction):

    def __init__(self,parent):
        super().__init__("Exit",parent)
        self.triggered.connect(self.doit)

    def doit(self):
        print("Exit")

 
class ImportMenu(QMenu):

    def __init__(self,parent):
        super().__init__("Import",parent)
        self.addAction(ImportPlyAction(self))

class ExportMenu(QMenu):

    def __init__(self,parent):
        super().__init__("Export",parent)
        self.addAction(ExportSceneAction(self))

# IMPORT ACTIONS
class ImportPlyAction(QAction):

    def __init__(self,parent):
        super().__init__("Ply",parent)
        self.triggered.connect(self.doit)

    def doit(self):
        print("Ply")


# EXPORT ACTIONS 
class ExportSceneAction(QAction):

    def __init__(self,parent):
        super().__init__("Scene",parent)
        self.triggered.connect(self.doit)

    def doit(self):
        print("Scene")

 
class FileMenu(QMenu):

    def __init__(self,name):
        super().__init__(name)
        self.addAction(FileNewAction(self))
        self.addAction(FileSaveAction(self))
        self.addSeparator()
        self.addMenu(ImportMenu(self))
        self.addMenu(ExportMenu(self))
        self.addSeparator()
        self.addAction(FileExitAction(self))
 

class MainMenu(QMenuBar):

    def __init__(self):
        super().__init__()
        self.fileMenu = FileMenu("File")

        self.addMenu(self.fileMenu)

 
# MAIN WINDOW

class RenderingAction(QAction):

    def __init__(self,lux,parent):
        super().__init__('Paused',parent)
        self.lux = lux
        self.triggered.connect(self.doit)
        self.lux.sg.stop()

    def doit(self):
        if self.text() == 'Paused':
            self.setText('Rendering')
            #self.lux.sg.paused(0)
        else:
            #self.lux.sg.paused(1)
            self.setText('Paused')

 
class Example(QMainWindow):
    
    def __init__(self):
        super().__init__()
        self.thread = QThread()
        self.lux = LuxWidget(1200,800)        

        # Create UI widgets 
        self.sceneLayout = SceneLayout(self.lux)
        self.attributeEditor = NodeEditor(self.lux)
        self.renderSettings = RenderSettings(self.lux)
        self.toolbar = self.addToolBar("tools")
        self.renderAct = RenderingAction(self.lux,self) 
        self.status = QStatusBar()
        frame = QFrame()
        luxframe = QFrame()
        luxframe.setFrameStyle(QFrame.StyledPanel | QFrame.Plain)
        luxvbox = QHBoxLayout()
        timeeditor = TimeEditor(self.lux)

        self.toolbar.addAction(self.renderAct)
        luxframe.setLayout(luxvbox)
        luxframe.setAutoFillBackground(1)
        palette = QPalette()
        palette.setColor(QPalette.Background,QColor(0,0,0))
        luxframe.setPalette(palette)

        luxvbox.addWidget(self.lux,Qt.AlignCenter)

        self.menu = MainMenu()
        self.setMenuBar(self.menu)

        # Layout UI widgets
        vbox = QVBoxLayout()
        vbox.addWidget(luxframe,Qt.AlignCenter)
        vbox.addWidget(timeeditor)
        self.setCentralWidget(frame)
        self.addDockWidget(Qt.RightDockWidgetArea, self.sceneLayout);
        self.addDockWidget(Qt.RightDockWidgetArea, self.attributeEditor);
        self.addDockWidget(Qt.LeftDockWidgetArea, self.renderSettings);
        self.setStatusBar(self.status)

        # Setup UI widgets
        self.status.showMessage("Starting...")
        frame.setLayout(vbox)
        self.setWindowTitle('LuxEd')


        # Connections setup
        self.sceneLayout.objectSelected.connect(self.objectSelected)
        self.sceneLayout.materialSelected.connect(self.materialSelected)
        self.sceneLayout.textureSelected.connect(self.textureSelected)
        self.sceneLayout.lightSelected.connect(self.lightSelected)
     
        self.show()

        self.sceneLayout.updateTabs()

        t = QTimer(self)
        t.timeout.connect(self.updateLux)
        t.start(1000)

        # Start the render
        self.lux.startRendering()

        # Create a default material
        matstring = "scene.materials.luxed_default_mat.type = \"matte\"\n"
        matstring += "scene.materials.luxed_default_mat.kd = 1 1 1\n"
        self.lux.sg.lux.setProperties(matstring)
 
    def updateLux(self):
        self.lux.sg.write()
        self.lux.repaint()
        self.status.clearMessage()
        self.status.showMessage(("[Elapsed time: %3d/5sec][Samples %4d][Avg. samples/sec %3.2fM on %.1fK tris]" % (
                self.lux.getTime(),
                self.lux.getPass(),
                (self.lux.getSpp() / 1000000.0),
                (self.lux.getTriCount() / 1000.0))))


    def keyPressEvent(self, e):
        if e.key() == Qt.Key_Escape:
            self.lux.stopRendering()
            self.close()

    def objectSelected(self,item):
        print("Object Selected %s"%item)
        self.attributeEditor.setEditor(item)


    def materialSelected(self,item):
        print("Material Selected %s"%item)
        self.attributeEditor.setEditor(item)

    def textureSelected(self,item):
        print("Texture Selected %s"%item)
        self.attributeEditor.setEditor("texture",self.lux.core().getTextureType(item),item)

    def lightSelected(self,item):
        print("Light Selected %s"%item)
        #self.attributeEditor.setEditor("object","",item)

if __name__ == '__main__':
    
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
