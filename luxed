#!/bin/python

###########################################################################
# Filename: luxed 
#
# Description: Editor for LuxRender.
#
# Copyright (C) 2016 Richard Layman, rlayman2000@yahoo.com 
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###########################################################################

import time
import sys
from array import *
sys.path.append("./lib")

import pyluxcore

from PyQt5.QtCore import pyqtSignal, Qt, QRect, QThread, QTimer
from PyQt5.QtWidgets import QMainWindow, QSlider, QMenuBar, QMenu, QAction, QDialog, QGroupBox, QStackedWidget, QGridLayout, QComboBox, QListWidget, QTabWidget, QLineEdit, QStatusBar, QFrame, QWidget, QPushButton, QLabel, QHBoxLayout, QVBoxLayout, QDockWidget, QFileDialog, QColorDialog, QApplication
from PyQt5.QtGui import QImage, QPalette, QIcon, QPainter, QFont, QColor, QPen, QIntValidator, QDoubleValidator


# PROPERTIES CONTAINERS

MaterialsType = ["matte","glossy2","glass","metal2","mattetranslucent","mirror","mix","null"]
TexturesType = ["imagemap"]

class Property:
    
    def __init__(self, ntype, nname, vname, vtype, luxprop, vmin, vmax, vdefault, desc=""):
        self.ntype = ntype
        self.nname = nname
        self.vname = vname
        self.vtype = vtype # bool, int, u_int, float, double, u_longlong, string, texture, uv, vector, normal, point, matrix4x4, spectrum
        self.value = vdefault
        self.default = vdefault 
        self.min = vmin 
        self.max = vmax 
        self.enabled = 1
        self.desc = desc
        self.luxprop = luxprop
 
    def setType(self, vtype):
        self.vtype = vtype

    def getType(self):
        return self.vtype
    
    def setName(self, name):
        self.name = name
    
    def getName(self):
        return self.name

    def setValue(self, val):
        self.value = val

    def getValue(self):
        return self.value

    def getPropertyString(self):
        out=""
        if self.vtype is 'string':
            out = "%s = \"%s\"" % (self.getCallString(), self.value[0])
        if self.vtype is 'bool' or self.vtype is'int' or self.vtype is'u_int':
            out = "%s = %d" % (self.getCallString(), int(self.value))
        if self.vtype is 'float' or self.vtype is 'double' or self.vtype is 'u_longlong' or self.vtype is 'spectrum':
            out = "%s = %f" % (self.getCallString(), float(self.value))
        if self.vtype is 'uv':
            out = "%s = %f %f" % (self.getCallString(), float(self.value[0]), float(self.value[1]))
        if self.vtype is 'texture':
            out = "%s = %f %f %f" % (self.getCallString(), float(self.value[0]), float(self.value[1]), float(self.value[2]))
        return out

    def getCallString(self):
        if self.nname is None or self.ntype is None:
            return ''
        elif self.ntype is 'objects':
            return "scene.objects.%s.%s"%(self.nname,self.vname)
        elif self.ntype is 'materials':
            return "scene.materials.%s.%s"%(self.nname,self.vname)
        return "%s.%s"%(self.nname,self.vname)

# NODE
class Node:

    def __init__(self,name=None,ntype=None):
        self.name = name
        self.ntype = ntype # 'camera','light','texture','material','object' 
        self.props = []

    def clear(self):
        self.name = None
        self.ntype = None
        self.props = []

    def addProperty(self,prop):
        self.props.append(prop)

    def getPropertyString(self):
        out = ""
        for prop in self.props:
            out += prop.getPropertyString() + "\n"
        return out


# LUX SCENE
class Lux(QThread):

    def __init__(self):
        super().__init__()
        pyluxcore.Init()

        # Load the configuration from files
        #self.props = pyluxcore.Properties("render.cfg")
        #self.scene = pyluxcore.Scene("scene.scn")
        #self.scnprops = pyluxcore.Properties("scene.scn")
        #self.config = pyluxcore.RenderConfig(self.props, self.scene)
        #self.session = pyluxcore.RenderSession(self.config)

        self.props = pyluxcore.Properties()
        self.props.Set(pyluxcore.Property("renderengine.type", ["PATHCPU"]))
        self.props.Set(pyluxcore.Property("opencl.platform.index", [-1]))
        self.props.Set(pyluxcore.Property("opencl.cpu.use", [0]))
        self.props.Set(pyluxcore.Property("opencl.gpu.use", [1]))
        self.props.Set(pyluxcore.Property("opencl.gpu.workgroup.size", [64]))
        self.props.Set(pyluxcore.Property("film.width", [1024]))
        self.props.Set(pyluxcore.Property("film.height", [576]))
        # camera
        self.sceneprops = pyluxcore.Properties()
        self.sceneprops.Set(pyluxcore.Property("scene.camera.lookat.orig", [0.64, 0.27, 0.14]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.lookat.target", [0.10, 1.04, -0.18]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.up", [0, 0, 1]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.cliphither", [0.001]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.clipyon", [1.00]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.lensradius", [0.00]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.focaldistance", [0.28]))
        self.sceneprops.Set(pyluxcore.Property("scene.camera.fieldofview", [49]))

        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain", [0, 0, 0]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.transformation", [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.samples", [-1]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.visibility.indirect.diffuse.enable", [1]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.visibility.indirect.glossy.enable", [1]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.visibility.indirect.specular.enable", [1]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.dir", [-0.51, -3.38, 0.76]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.turbidity", [2.20]))
        self.sceneprops.Set(pyluxcore.Property("scene.lights.ext_light.gain.relsize", [1]))

        self.scene = pyluxcore.Scene()
        self.scene.Parse(self.sceneprops) 
       
        self.config = pyluxcore.RenderConfig(self.props, self.scene)
        self.session = pyluxcore.RenderSession(self.config)
      
        # PROPERTIES
        self.fov = 65

    def load(self):
        val = 0
        print("Object Count:%d"%(self.scene.GetObjectCount()))
        print("Light Count:%d"%(self.scene.GetObjectCount()))

        #self.textures = self.scnprops.GetAllUniqueSubNames("scene.textures")
        #self.materials = self.scnprops.GetAllUniqueSubNames("scene.materials")
        #self.lights = self.scnprops.GetAllUniqueSubNames("scene.lights")
        #self.objects = self.scnprops.GetAllUniqueSubNames("scene.objects")
        #print("Loaded... Lights:%d, Textures%d, Materials%d, Objects%d"%(len(self.lights), len(self.textures), len(self.materials), len(self.objects))) 
       
    def startRendering(self):
        self.session.Start() 
        
    def paused(self,state):
        if(state):
            self.session.EndSceneEdit()
        else:
            self.session.BeginSceneEdit()

    def writeImage(self):
        self.session.UpdateStats()
        self.session.GetFilm().Save()

    def stopRendering(self):
        self.session.GetFilm().Save()
        self.session.Stop()

    def getTime(self):
        stats = self.session.GetStats();
        return stats.Get("stats.renderengine.time").GetFloat()

    def getPass(self):
        stats = self.session.GetStats();
        return stats.Get("stats.renderengine.pass").GetInt()

    def getSpp(self):
        stats = self.session.GetStats();
        return stats.Get("stats.renderengine.total.samplesec").GetFloat()

    def getTriCount(self):
        stats = self.session.GetStats();
        return stats.Get("stats.dataset.trianglecount").GetFloat()

    def getMaterialType(self,name):
        mtype = ""
        mtype=self.scnprops.Get("scene.materials.%s.type"%name).Get() 
        print("mtype = %s"%mtype)
        return mtype 

    def getTextureType(self,name):
        return self.scnprops.Get("scene.textures.%s.type"%name).Get() 

    def beginEdit(self):
        self.session.BeginSceneEdit()

    def endEdit(self):
        self.session.EndSceneEdit()
        self.writeImage()



    # This is needed since luxcore will crash if you try to set a property that was not set in the file.
    # To fix this we will call this method before we try to set any properties.
    # When the AE is first loaded it will load the properties for lux and then this method will get called
    # for each property.
    # It will ask lux if the property exists and add it if it doesn't.   
    def verifyProperty(self,name,prop):
        if self.scnprops.IsDefined(name) is False:
            print(name + " is missing. Adding it")
            if prop.type is 'string':
                self.scnprops.Set(pyluxcore.Property(name, [prop.value]))
            if prop.type is 'bool' or prop.type is'int' or prop.type is'u_int':
                self.scnprops.Set(pyluxcore.Property(name, [prop.value]))
            if prop.type is 'float' or prop.type is 'double' or prop.type is 'u_longlong' or prop.type is 'spectrum':
                self.scnprops.Set(pyluxcore.Property(name, [prop.value]))
            if prop.type is 'uv':
                self.scnprops.Set(pyluxcore.Property(name, [prop.value[0],prop.value[1]]))
            if prop.type is 'texture':
                self.scnprops.Set(pyluxcore.Property(name, [prop.value[0],prop.value[1],prop.value[2]]))

    def changeSize(self,width,height):
        print("CHANGE SIZE")
        self.setFixedWidth(width)
        self.setFixedHeight(height)

        # Stop the rendering
        self.session.Stop()
        self.session = None

        # Set the new size
        self.scene.Parse(pyluxcore.Properties().
            Set(pyluxcore.Property("film.width", [width])).
            Set(pyluxcore.Property("film.height", [height])))

        # Re-start the rendering
        self.session = pyluxcore.RenderSession(self.config)
        self.session.Start()

    '''
    def setProperty(self,propname,propval):
        self.session.BeginSceneEdit()
        self.scene.Parse(pyluxcore.Properties().Set(pyluxcore.Property(propname, [propval])).
            Set(pyluxcore.Property("scene.camera.lookat.orig", [-5.35,7.7,-4.35])).
            Set(pyluxcore.Property("scene.camera.lookat.target", [10,5.69,-9.98])).
            Set(pyluxcore.Property("scene.camera.up", [0,1,0]))
        )
        self.session.EndSceneEdit()
        self.writeImage()
    '''

    def setProperties(self,propstring):
        names = self.sceneprops.GetAllNames()
        print("setProperties() List BEFORE")
        for name in names:
            print(name)
        print("END")
        print("PROP CALL STRING")
        print(propstring)
        self.session.BeginSceneEdit()
        try:
            #self.scene.Parse(pyluxcore.Properties().SetFromString(propstring))
            self.scene.Parse(self.sceneprops.SetFromString(propstring))
        except RuntimeError:
            pass
        self.session.EndSceneEdit()
        self.writeImage()

    '''
    def getMaterialProperties(self,mtype,name):
        if mtype is "materialcommmon":
            props = MaterialCommonProps()
            props.id.setValue(self.scnprops.Get("scene.materials.%s.id"%name).Get())
            props.bumptex.setValue(self.scnprops.Get("scene.materials.%s.bumptex"%name).Get())
            props.normaltex.setValue(self.scnprops.Get("scene.materials.%s.normaltex"%name).Get())
 
        if mtype is "materialemission":
            props = MaterialEmissionProps()
            props.emission.setValue(self.scnprops.Get("scene.materials.%s.emission"%name).Get())
            props.emissiongain.setValue(self.scnprops.Get("scene.materials.%s.emission.gain"%name).Get())
            props.emissionpower.setValue(self.scnprops.Get("scene.materials.%s.emission.power"%name).Get())
            props.emissionefficency.setValue(self.scnprops.Get("scene.materials.%s.emission.efficency"%name).Get())
        
        if mtype is "matte":
            props = MatteProps()
            props.kd.setValue(self.scnprops.Get("scene.materials.%s.kd"%name).Get())

        if mtype is "carpaint":
            props = CarPaintProps()
            props.preset.setValue(self.scnprops.Get("scene.materials.%s.preset"%name).Get())
            props.ka.setValue(self.scnprops.Get("scene.materials.%s.ka"%name).Get())
            props.d.setValue(self.scnprops.Get("scene.materials.%s.d"%name).Get())
            props.kd.setValue(self.scnprops.Get("scene.materials.%s.kd"%name).Get())
            props.ks1.setValue(self.scnprops.Get("scene.materials.%s.ks1"%name).Get())
            props.ks2.setValue(self.scnprops.Get("scene.materials.%s.ks2"%name).Get())
            props.ks3.setValue(self.scnprops.Get("scene.materials.%s.ks3"%name).Get())
            props.r1.setValue(self.scnprops.Get("scene.materials.%s.r1"%name).Get())
            props.r2.setValue(self.scnprops.Get("scene.materials.%s.r2"%name).Get())
            props.r3.setValue(self.scnprops.Get("scene.materials.%s.r3"%name).Get())
            props.m1.setValue(self.scnprops.Get("scene.materials.%s.m1"%name).Get())
            props.m2.setValue(self.scnprops.Get("scene.materials.%s.m2"%name).Get())
            props.m3.setValue(self.scnprops.Get("scene.materials.%s.m3"%name).Get())

        if mtype is "glass":
            props = GlassProps()
            props.kr.setValue(self.scnprops.Get("scene.materials.%s.kr"%name).Get())
            props.kt.setValue(self.scnprops.Get("scene.materials.%s.kt"%name).Get())
            props.interior.setValue(self.scnprops.Get("scene.materials.%s.interior"%name).Get())
            props.exterior.setValue(self.scnprops.Get("scene.materials.%s.exterior"%name).Get())

        if mtype is "glossy2":
            props = Glossy2Props()
            #stats = self.session.GetStats();
            #props.kd.setValue(self.session.Parse(self.scnprops.Get("scene.materials.%s.kd"%name).Get()))
            #val = None
            #val = stats.Get("stats.scene.materials.%s.kd"%name).GetString()
            #self.config.GetProperty(self.scnprops.Get("scene.materials.%s.ks"%name).Get())
            #self.scene.Parse(self.scnprops.Get("scene.materials.%s.kd"%name).Get())
            print("GLOSSY NAME")
            #print(self.scnprops.Get("scene.materials.%s.ks"%name).Get())
            props.kd.setValue(self.scnprops.Get("scene.materials.%s.kd"%name).Get())
            props.ks.setValue(self.scnprops.Get("scene.materials.%s.ks"%name).Get())
            #print(self.scnprops.Get("scene.materials.%s.ks"%name).Get())
            #self.config.GetProperty(self.scnprops.Get("scene.materials.%s.ks"%name).GetName())
            #print(self.scene.ToProperties().Get(self.scnprops.Get("scene.materials.%s.ks"%name)).Get())



            props.uroughness.setValue(self.scnprops.Get("scene.materials.%s.uroughness"%name).Get())
            props.vroughness.setValue(self.scnprops.Get("scene.materials.%s.vroughness"%name).Get())

        if mtype is "mix":
            props = MaterialMixProps()
            props.material1.setValue(self.scnprops.Get("scene.materials.%s.material1"%name).Get())
            props.material2.setValue(self.scnprops.Get("scene.materials.%s.material2"%name).Get())
            props.amount.setValue(self.scnprops.Get("scene.materials.%s.amount"%name).Get())
 
        return props 
 
    def getTextureProperties(self,mtype,name):
        props = None
        if mtype is "imagemap":
            props = ImageMapProps()
            props.file.setValue(self.scnprops.Get("scene.textures.%s.file"%name).Get())
            props.gamma.setValue(self.scnprops.Get("scene.textures.%s.gamma"%name).Get())
            props.gain.setValue(self.scnprops.Get("scene.textures.%s.gain"%name).Get())
        return props 
    '''
    
    def setRenderSettings(self,propstring):
        # Stop the rendering
        self.session.Stop()
        self.session = None

        print("NEW RENDER SETTINGS")
        print(propstring)
        self.config.Parse(pyluxcore.Properties().SetFromString(propstring))

        # Re-start the rendering
        self.session = pyluxcore.RenderSession(self.config)
        self.session.Start()

    def getRenderSettings(self):
        self.session.UpdateStats()
        #props = RenderProps()
        #props.width.value = self.session.GetFilm().GetWidth()
        #props.height.value = self.session.GetFilm().GetHeight()
        #return props


    def getWidth(self):
        self.session.UpdateStats()
        return self.session.GetFilm().GetWidth()

    def getHeight(self):
        self.session.UpdateStats()
        return self.session.GetFilm().GetHeight()

    def getNode(self, node):
        for prop in node.props:
            print("PROP NAME")
            #name = prop.luxprop.GetName() #self.sceneprops.Get(prop.getCallString()).Get()
            print(prop.luxprop)
            print(self.sceneprops.GetAllUniqueSubNames(prop.getCallString()))

    # TESTING
    def setColor(self,prop,val):
        prop.Set(val)
        self.scene.Parse(self.sceneprops.Set(prop))

    # TESTING
    def getColor(self,prop):
        print(prop.Get())

    # TODO - FIX THIS!!!
    def removeNode(self,node):
        names = self.sceneprops.GetAllNames()
        print("Property List BEFORE")
        for name in names:
            print(name)
        print("END")
        for prop in node.props:
            #luxprop = pyluxcore.Property(prop.getCallString(), prop.value)
            #self.scene.Parse(self.sceneprops.Delete(prop.getCallString()))
            self.sceneprops.Delete(prop.getCallString())
            #self.sceneprops.Clear()

        self.session.BeginSceneEdit()
        self.scene.Parse(self.sceneprops) 
        self.session.EndSceneEdit()
        names = ""
        names = self.sceneprops.GetAllNames()
        print("Property List AFTER")
        for name in names:
            print(name)
        print("END")

        self.config = pyluxcore.RenderConfig(self.props, self.scene)
        self.session = pyluxcore.RenderSession(self.config)
        self.writeImage()
            
    def addNode(self,node):

        print("ADD NODE %s"%node.name)
        for prop in node.props:
            luxprop = pyluxcore.Property(prop.getCallString(), prop.value)
            self.sceneprops.Set(luxprop)
            prop.luxprop = luxprop

        self.scene.Parse(self.sceneprops)

        return node
 
    def addObject(self):
        self.session.BeginSceneEdit()

        #self.scene.Parse(pyluxcore.Properties().

        mattekd = pyluxcore.Property("scene.materials.mat.kd", [1,1,1])
        mattename = mattekd.GetName()
        print("NEW PROP NAME: " + mattename)
 
        #self.scene.Parse(self.sceneprops.Set(pyluxcore.Property("scene.materials.light_mat.type", ["matte"]))
 
        self.scene.Parse(pyluxcore.Properties().
            Set(pyluxcore.Property("scene.materials.light_mat.type", ["matte"])).
            Set(pyluxcore.Property("scene.materials.light_mat.kd", [1, 1, 1])). 
            Set(pyluxcore.Property("scene.materials.light_mat.emission", [1, 1, 1])).
            Set(pyluxcore.Property("scene.materials.light_mat.emission.gain", [1, 1, 1])).
            Set(pyluxcore.Property("scene.materials.light_mat.emission.power", [1000])).
            Set(pyluxcore.Property("scene.materials.light_mat.emission.efficency", [1])).
            Set(pyluxcore.Property("scene.materials.mat.type", ["matte"])).
            Set(mattekd).
            Set(pyluxcore.Property("scene.objects.ball.material", ["mat"])).
            Set(pyluxcore.Property("scene.objects.ball.ply", ["mesh/outer_ball.ply"])).
            Set(pyluxcore.Property("scene.objects.light_obj.material", ["light_mat"])).
            Set(pyluxcore.Property("scene.objects.light_obj.ply", ["mesh/light_left.ply"]))
        )

        self.session.EndSceneEdit()
        self.writeImage()
        return mattekd

    def getName(self,prop):
        print("PASSED PROP NAME " + prop.GetName())

        self.session.BeginSceneEdit()
        self.scene.Parse(pyluxcore.Properties().
            Set(pyluxcore.Property(prop.GetName(), [1,0,0]))
        ) 
        self.session.EndSceneEdit()
        self.writeImage()
 
        names = self.scene.ToProperties().GetAllUniqueSubNames("scene.materials")
        for n in names:
            print(n)
        return("DONE")

# SCENEGRAPH

class SceneGraph():

    def __init__(self):
        self.lux = Lux()

        # Property containers
        #self.render = RenderProps()
        self.rendernodes = []
        self.nodes = []

        self.initRenderNodes()
        #self.lux.setRenderSettings(self.render.getPropertyString)

    def initRenderNodes(self):
        # render engine
        renderengine = Node('renderengine','renderengine')
        renderengine.addProperty(Property('renderengine','renderengine','type','string',None,None,None,['PATHCPU'],""))
        # PATHCPU
        path = Node('path','path')
        path.addProperty(Property('path','path','maxdepth','int',None,1,16,5,""))
        path.addProperty(Property('path','path','russianroulette.depth','int',None,1,16,3,""))
        path.addProperty(Property('path','path','russianroulette.cap','float',None,0.0,1.0,0.5,""))
        path.addProperty(Property('path','path','clamping.variance.maxvalue','float',None,0.0,None,0.0,""))
        path.addProperty(Property('path','path','clamping.pdf.value','float',None,0.0,1.0,0.0,""))
        path.addProperty(Property('path','path','fastpixelfilter.enable','bool',None,0,1,1,""))
 
        # SAMPLERS

        # METROPOLIS 
        sampler= Node('sampler','sampler')
        sampler.addProperty(Property('sampler','sampler','type','string',None,None,None,['SOBOL'],""))
        samplermetropolis = Node('sampler.metropolis','sampler.metropolis')
        samplermetropolis.addProperty(Property('sampler.metropolis','sampler.metropolis','largesteprate','float',None,0.0,1.0,0.4,""))
        samplermetropolis.addProperty(Property('sampler.metropolis','sampler.metropolis','maxconsecutivereject','int',None,0,32768,512,""))
        samplermetropolis.addProperty(Property('sampler.metropolis','sampler.metropolis','imagemutationrate','float',None,0.0,1.0,0.1,""))
 
        # film 
        film = Node('film','film')
        film.addProperty(Property('film','film','width','int',None,10,None,720,""))
        film.addProperty(Property('film','film','height','int',None,10,None,480,""))

        self.rendernodes.append(renderengine)
        self.rendernodes.append(sampler)
        self.rendernodes.append(samplermetropolis)
        self.rendernodes.append(path)
        self.rendernodes.append(film)
 
    def start(self):
        self.lux.startRendering() 
        
    def stop(self):
        self.lux.stopRendering()

    def paused(self,state):
        self.lux.paused(state)

    def write(self):
        self.lux.writeImage()

    def loadConfig(self, path):
        if(path == None):
            pass            

    def loadScene(self, path):
        if(path == None):
            pass

    def beginEdit(self):
        self.lux.beginEdit()
 
    def endEdit(self):
        self.lux.endEdit()
    
    def getRenderProperty(self,ntype,pname):
        for node in self.rendernodes:
            if node.ntype == ntype:
                for prop in node.props:
                    if prop.vname == pname:
                        return prop 
        return None 
 
    def getNames(self, ntype):
        nodelist = []
       
        for node in self.nodes:
            print("looking at node")
            if node.ntype == ntype:
                print("adding node " + node.name)
                nodelist.append(node.name)

        return nodelist 

    def getRenderSettings(self):
        propstring = ''

        # ENGINE
        enginenode = None
        for node in self.rendernodes:
            if node.ntype == 'renderengine':
                enginenode = node

        propstring += enginenode.getPropertyString()         

        for node in self.rendernodes:
            if node.ntype == 'path' and enginenode.props[0].value[0] == 'PATHCPU':
                 propstring += node.getPropertyString()

        # SAMPLER
        samplernode = None
        # get sampler type
        for node in self.rendernodes:
            if node.ntype == 'sampler':
                 samplernode = node

        # build sampler string
        propstring += samplernode.getPropertyString()
        for node in self.rendernodes:
            print("sampler type = %s"%samplernode.props[0].value[0])
            if node.ntype == 'sampler.metropolis' and samplernode.props[0].value[0] == 'METROPOLIS':
                propstring += node.getPropertyString()

        # FILM
        for node in self.rendernodes:
            if node.ntype == 'film':
                propstring += node.getPropertyString()

        return propstring

    def setRenderSettings(self):
        self.lux.setRenderSettings(self.getRenderSettings())

    def getNode(self, name):
        for node in self.nodes:
            if node.name == name:
                return node

    def addNode(self, node):
        self.nodes.append(self.lux.addNode(node))

    def addSceneNode(self,name,ntype,subtype):
        # if the scene node already exist, replace it
        # else add it
        print("addSceneNode() name=%s, ntype=%s, subtype=%s"%(name,ntype,subtype))
        '''
        node = None
        i = 0
        for n in self.nodes:
            if n.name == name:
                node = n
                if n.ntype == ntype:
                    for prop in n.props:
                        #print("prop value name is " + prop.vname + " and it's value is " + prop.value[0])
                        if prop.vname == 'type': # and prop.value[0] != subtype:
                            print("replacing node %s with type %s node"%(name,prop.value[0]))
                            #self.removeNode(n)
                            #del self.nodes[i]
                            #node = self.createNode(name,ntype,subtype)
                            n.name = name
                            n.ntype = ntype
                            n.subtype = subtype
                            prop.value = ['glossy2']
                            node = n
                            self.lux.setProperties(node.getPropertyString())
                else:
                    print("can't add node because of node of the same name already exist as a different type")
            i += 1

        if node == None:
            print("no node %s found, creating a new one"%name)
            node = self.createNode(name,ntype,subtype)
            self.nodes.append(node)
            self.lux.setProperties(node.getPropertyString())

        print("FINISHED!!!")
        print("ALL NODES IN SCENEGRAPH")
        for n in self.nodes:
            print("NODE: %s,%s"%(node.name,node.ntype))
            for prop in n.props:
                print("\tPROP: %s"%prop.vname)
        '''
        node = None
        for n in self.nodes:
            if n.name == name:
                n = self.createNode(name,ntype,subtype)
                n.name = name
                n.ntype = ntype
                n.subtype = subtype
                node = n
                self.lux.setProperties(node.getPropertyString())
        if node is None:
                node = self.createNode(name,ntype,subtype)
                self.lux.setProperties(node.getPropertyString())
                self.nodes.append(node)

        return node 

    def removeNode(self,node):
        self.lux.removeNode(node)

    def createNode(self,name,ntype,subtype):
        print("Creating Node")
        print(name)
        print(ntype)
        print(subtype)
        node = Node(name,ntype)
        if subtype == 'ply':
            node.addProperty(Property('objects',name,'material','string',None,None,None,['mat'],"type of material"))
            node.addProperty(Property('objects',name,'ply','string',None,None,None,[''],"mesh path (e.g scenes/luxball/luxball-shell.ply)"))
        if subtype == 'matte':
            node.addProperty(Property('materials',name,'type','string',None,None,None,['matte'],"type of material"))
            node.addProperty(Property('materials',name,'kd','texture',None,None,None,[1,1,1],"texture or constant color of the matte material"))
        if subtype == 'glossy2':
            node.addProperty(Property('materials',name,'type','string',None,None,None,['glossy2'],"type of material"))
            node.addProperty(Property('materials',name,'kd','texture',None,None,None,[1,1,1],"texture or constant diffuse color of the material"))
            node.addProperty(Property('materials',name,'ks','texture',None,None,None,[1,1,1],"texture or constant specular color of the material"))
            node.addProperty(Property('materials',name,'uroughness','texture',None,None,None,[0.1,0.1,0.1],"texture or constant roughness value along u coordinate of the material"))
            node.addProperty(Property('materials',name,'vroughness','texture',None,None,None,[0.1,0.1,0.1],"texture or constant roughness value along v coordinate of the material"))
            node.addProperty(Property('materials',name,'ka','texture',None,None,None,[0.0,0.0,0.0],"texture or constant value of coefficient of absorption of the coating layer"))
            node.addProperty(Property('materials',name,'d','texture',None,None,None,[0.0,0.0,0.0],"texture or constant value of the depth (thickness) of the coating layer for absorption effects. (0 = disables)"))
            node.addProperty(Property('materials',name,'index','texture',None,None,None,[0.0,0.0,0.0],"IOR of the coating. IOR overrides color Ks if both are specified"))

        if subtype == 'glass':
            node.addProperty(Property('materials',name,'type','string',None,None,None,['glass'],"type of material"))
            node.addProperty(Property('materials',name,'kr','texture',None,None,None,[1,1,1],"texture or constant reflected color of the material"))
            node.addProperty(Property('materials',name,'kt','texture',None,None,None,[1,1,1],"texture or constant transmitted color of the material"))
            node.addProperty(Property('materials',name,'interiorior','texture',None,None,None,[1,1,1],"inside texture or constant index of refraction (only for volume-less rendering)"))
            node.addProperty(Property('materials',name,'exteriorior','texture',None,None,None,[1,1,1],"outside texture or constant index of refraction (only for volume-less rendering)"))
 
        if subtype == 'metal2':
            node.addProperty(Property('materials',name,'type','string',None,None,None,['metal2'],"type of material"))
            node.addProperty(Property('materials',name,'fresnel','texture',None,None,None,[1,1,1],""))
            node.addProperty(Property('materials',name,'uroughness','texture',None,None,None,[0.1,0.1,0.1],"texture or constant roughness value along u coordinate of the material"))
            node.addProperty(Property('materials',name,'vroughness','texture',None,None,None,[0.1,0.1,0.1],"texture or constant roughness value along v coordinate of the material"))
 
 
        if subtype == 'mattetranslucent':
            node.addProperty(Property('materials',name,'type','string',None,None,None,['mattetranslucent'],"type of material"))
            node.addProperty(Property('materials',name,'kr','texture',None,None,None,[0.5,0.5,0.5],"texture or constant reflected color of the material"))
            node.addProperty(Property('materials',name,'kt','texture',None,None,None,[0.5,0.5,0.5],"texture or constant transmitted color of the material"))
  
        if subtype == 'mirror':
            node.addProperty(Property('materials',name,'type','string',None,None,None,['mirror'],"type of material"))
            node.addProperty(Property('materials',name,'kr','texture',None,None,None,[1,1,1],"texture or constant reflected color of the material"))
  
        if subtype == 'mix':
            node.addProperty(Property('materials',name,'type','string',None,None,None,['mix'],"type of material"))
            node.addProperty(Property('materials',name,'material1','string',None,None,None,[''],"name of another material"))
            node.addProperty(Property('materials',name,'material2','string',None,None,None,[''],"name of another material"))
            node.addProperty(Property('materials',name,'amount','texture',None,None,None,[1,1,1],"texture or constant value used to mix the materials"))
 
        if subtype == 'null':
            node.addProperty(Property('materials',name,'type','string',None,None,None,['null'],"type of material"))


        if ntype == 'materials':
            node.addProperty(Property('materials',name,'emission','texture',None,None,None,[0,0,0],"color of the emitted light"))
            node.addProperty(Property('materials',name,'emission.gain','texture',None,None,None,[0,0,0],""))
            node.addProperty(Property('materials',name,'emission.power','spectrum',None,None,None,0.0,"lamp output power in watts. Setting 0 for both power and efficacy bypasses this feature and uses only the lamp gain"))
            node.addProperty(Property('materials',name,'emission.efficency','float',None,None,None,0.0,"luminous efficacy in lumens/watt. Setting 0 for both power and efficacy bypasses this feature and uses only the lamp gain"))
            node.addProperty(Property('materials',name,'emission.samples','int',None,-1,1000,-1,"the number of shadow ray to trace to compute direct light from this material. This property is an hint and the render engine can ignore this information. -1 means use the default global value."))
 
        return node

    def getSceneString(self):
        out = ''
        for node in self.nodes:
            out += node.getPropertyString() + '\n\n'
        return out

    def addObject(self):
        node = Node('mat_test','materials')
        #node.addProperty(Property(ntype,name, attribute, luxprop, vtype, vmin, vmax, vdefault, desc=""))
        node.addProperty(Property(node.ntype,'mat_test', 'type', None, 'string', None, None, ["matte"], desc="Test"))
        node.addProperty(Property(node.ntype,'mat_test', 'kd', None, 'texture', None, None, [1,0,0], desc="Test"))

        node = self.lux.addNode(node)
        for prop in node.props:
            print(prop.luxprop)
            print(prop.getCallString())
            print(prop.value)
        #prop = self.lux.addObject()
        #print(self.lux.getName(prop))

 
class LuxWidget(QWidget):
    nodeAdded = pyqtSignal()


    def __init__(self,width,height):
        super().__init__()
        self.sg = SceneGraph()
        self.fov = 65
        self.setFixedWidth(self.sg.lux.getWidth())
        self.setFixedHeight(self.sg.lux.getHeight())
        
    def paintEvent(self,e):
        qp = QPainter()
        qp.begin(self)
        self.drawWidget(qp)
        qp.end()

    def drawWidget(self,qp):
        rect = QRect(0,0,self.width(),self.height())
        image = QImage("image.png")
        qp.drawImage(rect,image)

    def changeSize(self,width,height):
        self.setFixedWidth(width)
        self.setFixedHeight(height)
        self.lux.changeSize(width,height)

    def startRendering(self):
        self.sg.start() 

    def writeImage(self):
        self.sg.write()

    def stopRendering(self):
        self.sg.stop()

    def getTime(self):
        return self.sg.lux.getTime()

    def getPass(self):
        return self.sg.lux.getPass() 

    def getSpp(self):
        return self.sg.lux.getSpp()

    def getTriCount(self):
        return self.sg.lux.getTriCount()

    def setRenderSettings(self):
        self.sg.setRenderSettings()
        self.setFixedWidth(self.sg.lux.getWidth())
        self.setFixedHeight(self.sg.lux.getHeight())

    def wheelEvent(self,e):
        self.fov = self.fov + (e.angleDelta().y() * 0.1)
        if self.fov > 1000.0:
            self.fov = 1000.0
        if self.fov < 5.0:
            self.fov = 5.0
        print("fov = %.1f, x = %d" % (self.fov,e.angleDelta().y()))
        self.lux.setProperty("scene.camera.fieldofview",self.fov)
        self.repaint()


# EDITOR WIDGETS


# Color Widget 
class ColorWidget(QFrame):
    colorChanged = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.colorValue = QFrame()
        self.setFixedWidth(32)
        self.setFrameStyle(QFrame.StyledPanel | QFrame.Plain)
        self.setAutoFillBackground(1)
        self.palette = QPalette()
        self.palette.setColor(QPalette.Window,QColor(255,255,255))
        self.setPalette(self.palette)

    def mousePressEvent(self,e):
        color = QColorDialog(self.palette.color(QPalette.Window)).getColor()
        self.palette.setColor(QPalette.Window,color)
        self.setPalette(self.palette)
        self.colorChanged.emit()

    def getColor(self):
        return self.palette.color(QPalette.Window)
 
    def setColor(self,color):
        self.palette.setColor(QPalette.Window,color)
        self.setPalette(self.palette)


# Link Dialog
class LinkDialog(QDialog):
    linkSelected = pyqtSignal(['QString'])

    def __init__(self,lux,ltype):
        super().__init__()
        self.lux = lux
        self.list = QListWidget() 
        self.link = ""

        vbox = QVBoxLayout()
        vbox.addWidget(self.list)
        self.setLayout(vbox)

        if(ltype == 'materials'):
            self.list.clear()
            for t in self.lux.sg.getNames('materials'):
                self.list.addItem(t)

        if(ltype == 'textures'):
            self.list.clear()
            for t in self.lux.sg.getNames('textures'):
                self.list.addItem(t)


        self.show()
        self.list.itemClicked.connect(self.setCurrentLink)

    def setCurrentLink(self,item):
        self.link = item.text()
        self.linkSelected.emit(self.link)
        self.hide()

 
# Texture Attribute
class TextureAttribute(QWidget):
    valueChanged = pyqtSignal()

    def __init__(self,prop,lux):
        super().__init__()
        self.lux = lux
        self.prop = prop
        self.label = QLabel(self.prop.vname)
        self.colorValue = ColorWidget()
        self.colorValue.setColor(QColor(255.0*prop.value[0],255.0*prop.value[1],255.0*prop.value[2]))
        self.linkValue = QPushButton("select")
        self.linkEnabled = 0 # use a color value or a texture link
        self.valueTypeBtn = QPushButton("T")
        self.valueTypeBtn.setFixedWidth(30)
        self.link = None
        if prop.nname == 'materials':
            self.link = LinkDialog(self.lux,'textures')
        if prop.nname == 'objects':
            self.link = LinkDialog(self.lux,'materials')

        self.setToolTip(self.prop.desc)
 
        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(self.label)
        hbox.addWidget(self.colorValue)
        hbox.addWidget(self.linkValue)
        hbox.addWidget(self.valueTypeBtn)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        self.setValueWidget()
     
        self.colorValue.colorChanged.connect(self.changed) 
        self.valueTypeBtn.clicked.connect(self.toggleValueType)
        self.linkValue.clicked.connect(self.showLinkDialog)
        if self.link:
            self.link.linkSelected.connect(self.setLink)
            self.link.hide()

    def enabled(self):
        return self.label.isEnabled()

    def toggleValueType(self):
        if(self.linkEnabled):
            self.linkEnabled = 0 
        else:
            self.linkEnabled = 1 
        self.setValueWidget()

    def setValueWidget(self):
        if(self.linkEnabled):
            self.colorValue.setVisible(0)
            self.linkValue.setVisible(1)
        else:
            self.colorValue.setVisible(1)
            self.linkValue.setVisible(0)

    def showLinkDialog(self):
        self.link.show()

    def setLink(self,link):
        self.linkValue.setText(link)
        self.changed()

    def changed(self):
        self.getColorValue() 
        self.valueChanged.emit()

    def changeColorValue(self,e):
        pass

    def getColorValue(self):
        if(self.linkEnabled):
            self.prop.type = 'string'
            self.prop.value = self.linkValue.text()
        else:
            color = self.colorValue.getColor()
            self.prop.type = 'texture'
            self.prop.value = [color.red()/255.0, color.green()/255.0, color.blue()/255.0]
        return self.prop.value

    def setProperty(self,prop):
        self.prop = prop
        if(len(prop.value) == 1):
            self.colorValue.setColor(QColor(255.0 * float(self.prop.value[0]), 255.0 * float(self.prop.value[0]), 255.0 * float(self.prop.value[0])))
        else:
            self.colorValue.setColor(QColor(255.0 * float(self.prop.value[0]), 255.0 * float(self.prop.value[1]), 255.0 * float(self.prop.value[2])))


# Option Attribute
class OptionAttribute(QWidget):
    valueChanged = pyqtSignal()

    def __init__(self,prop,options=None):
        super().__init__()
        self.prop = prop
        self.label = QLabel(self.prop.vname)
        self.value = QComboBox()

        self.setToolTip(self.prop.desc)

        if options is not None: 
            for item in options:
                self.value.addItem(item)
        else:
            if self.prop.ntype == 'materials':
                for item in MaterialsType:
                    self.value.addItem(item)

        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(self.label)
        hbox.addWidget(self.value)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        self.value.setCurrentText(self.prop.value[0])        
        self.value.currentIndexChanged.connect(self.changed)

        self.prop.value[0] = self.value.currentText()

    def enabled(self):
        return self.label.isEnabled()

    def changed(self,index):
        #self.prop.setValue(self.value.currentText())
        self.prop.value[0] = self.value.currentText()
        self.valueChanged.emit()

    def getValue(self):
        return self.value.currentText()

    def setValue(self,val):
        self.prop.setValue(val)
        return self.value.setCurrentText(val)

    def getIndex(self):
        return self.value.currentIndex()       

    def setProperty(self,prop):
        self.prop = prop
        self.value.setCurrentText(self.prop.value[0])


# Int Attribute
class IntAttribute(QWidget):
    valueChanged = pyqtSignal()


    def __init__(self,prop):
        super().__init__()
        self.prop = prop
        self.label = QLabel(self.prop.vname)
        self.value = QLineEdit()
        self.value.setFixedWidth(80)
        if self.prop.min is not None and self.prop.max is not None:
            self.validator = QIntValidator(self.prop.min,self.prop.max)
            self.value.setValidator(self.validator)
        self.value.setText("%d"%self.prop.value)

        self.setToolTip(self.prop.desc)
       
        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(self.label)
        hbox.addWidget(self.value)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        # connections
        self.value.editingFinished.connect(self.changed)

    def enabled(self):
        return self.label.isEnabled()

    def changed(self):
        self.prop.value = int(self.value.text())
        self.valueChanged.emit()

    def getValue(self):
        return int(self.prop.value)

    def setValue(self,val):
        self.prop.value = val
        self.value.setText("%d"%val)

    def setProperty(self,prop):
        self.prop = prop
        self.value.setText(self.prop.value[0])


# Float Attribute
class FloatAttribute(QWidget):
    valueChanged = pyqtSignal()


    def __init__(self,prop):
        super().__init__()
        self.prop = prop
        self.label = QLabel(self.prop.vname)
        self.value = QLineEdit()
        self.value.setFixedWidth(80)
        if self.prop.min is not None and self.prop.max is not None:
            self.validator = QDoubleValidator(self.prop.min,self.prop.max,4)
            self.value.setValidator(self.validator)
        self.value.setText("%f"%self.prop.value)

        self.setToolTip(self.prop.desc)
       
        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(self.label)
        hbox.addWidget(self.value)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        # connections
        self.value.editingFinished.connect(self.changed)

    def enabled(self):
        return self.label.isEnabled()

    def changed(self):
        self.prop.value = float(self.value.text())
        self.valueChanged.emit()

    def getValue(self):
        return float(self.prop.value)

    def setValue(self,val):
        self.prop.value = val
        self.value.setText("%f"%val)

    def loadProperty(self):
        self.value.setText(self.prop.value[0])

    def setProperty(self,prop):
        self.prop = prop
        self.value.setText(self.prop.value[0])


# String Attribute
class StringAttribute(QWidget):
    valueChanged = pyqtSignal()

    def __init__(self,prop):
        super().__init__()
        self.prop = prop
        self.label = QLabel(self.prop.vname)
        self.value = QLineEdit()
        self.value.setFixedWidth(80)
        self.value.setText(self.prop.value[0])

        self.setToolTip(self.prop.desc)
       
        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(self.label)
        hbox.addWidget(self.value)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        # connections
        self.value.editingFinished.connect(self.changed)

    def enabled(self):
        return self.label.isEnabled()

    def changed(self):
        self.prop.value = self.value.text()
        self.valueChanged.emit()

    def getValue(self):
        return self.prop.value

    def setValue(self,val):
        self.prop.value = val
        self.value.setText(val)

    def setProperty(self,prop):
        self.prop = prop
        self.value.setText(self.prop.value[0])

# File Attribute
class FileAttribute(QWidget):
    valueChanged = pyqtSignal()

    def __init__(self,prop):
        super().__init__()
        self.prop = prop
        label = QLabel(self.prop.vname)
        self.value = QPushButton("browse")
        if len(self.prop.value) > 0:
            self.value.setText(self.prop.value[0])
        self.value.setFixedWidth(150)
        #self.value.setText(self.prop.value)
 
        self.setToolTip(self.prop.desc)
              
        hbox = QHBoxLayout()        
        hbox.addStretch()
        hbox.addWidget(label)
        hbox.addWidget(self.value)
        hbox.setSpacing(2)
        hbox.setContentsMargins(1,1,1,1)

        self.setLayout(hbox)

        # connections
        self.value.clicked.connect(self.getFile)

    def getFile(self):
        filename = QFileDialog.getOpenFileName(self,"Open Ply Mesh",".","Ply Files (*.ply)")
        self.value.setText(filename[0])
        self.prop.value[0] = self.value.text()
        self.valueChanged.emit()

    def getValue(self):
        return self.prop.value

    def setValue(self,val):
        self.prop.value = val
        self.value.setText(val)

    def setProperty(self,prop):
        self.prop = prop
        self.value.setText(self.prop.value[0])

# DOCKS

# ATTRIBUTE EDITOR DOCK


# NODE ATTRIBUTE LOADER
class NodeAttributeLoader(QWidget):
    nodeChanged = pyqtSignal()

    def __init__(self,lux,node):
        super().__init__()
        self.vbox = QVBoxLayout()
        self.lux = lux
        self.label = QLabel("name:")
        self.vbox.addWidget(self.label)
        self.setLayout(self.vbox)
        self.node = None

    def load(self,node):
        print("loading node: %s"%node.name)
        self.node = node
        for i in reversed(range(self.vbox.count())):
            self.vbox.itemAt(i).widget().setParent(None)
        self.vbox.addWidget(self.label)

        for prop in self.node.props:
            if prop.vtype is 'string':
                # is it a type option?
                if prop.vname is 'type':
                    attribute = OptionAttribute(prop)
                    attribute.valueChanged.connect(self.typeChanged)
                    self.vbox.addWidget(attribute)
                elif prop.vname is 'material':
                    matlist = self.lux.sg.getNames('materials')
                    attribute = OptionAttribute(prop,matlist)
                    attribute.valueChanged.connect(self.updateNode)
                    self.vbox.addWidget(attribute)
                elif prop.vname is 'ply':
                    attribute = FileAttribute(prop)
                    attribute.valueChanged.connect(self.updateNode)
                    self.vbox.addWidget(attribute)
                else:
                    attribute = StringAttribute(prop)
                    attribute.valueChanged.connect(self.updateNode)
                    self.vbox.addWidget(attribute)
            if prop.vtype is 'int':
                attribute = IntAttribute(prop)
                attribute.valueChanged.connect(self.updateNode)
                self.vbox.addWidget(attribute)        
            if prop.vtype is 'float':
                attribute = FloatAttribute(prop)
                attribute.valueChanged.connect(self.updateNode)
                self.vbox.addWidget(attribute)        
            if prop.vtype is 'texture':
                attribute = TextureAttribute(prop,self.lux)
                attribute.valueChanged.connect(self.updateNode)
                self.vbox.addWidget(attribute)        
            if prop.vtype is 'spectrum':
                attribute = FloatAttribute(prop)
                attribute.valueChanged.connect(self.updateNode)
                self.vbox.addWidget(attribute)        
        print("finished loading node: %s"%node.name)
 
    def updateNode(self):
        self.nodeChanged.emit()

    def typeChanged(self):
        for prop in self.node.props:
            if prop.vname == 'type':
                subtype = prop.value[0]
        self.node = self.lux.sg.addSceneNode(self.node.name,self.node.ntype,subtype)
        self.load(self.node)
        self.nodeChanged.emit()    

# NODE EDITOR DOCK

class NodeEditor(QDockWidget):
    nodeChanged = pyqtSignal()

    def __init__(self,lux):
        super().__init__()
        self.lux = lux
        self.setWindowTitle("Node Editor")
        self.label = QLabel("----")
        self.label.setFont(QFont("Sans",12))
        self.label.setAlignment(Qt.AlignCenter)
        self.label.setFrameStyle(QFrame.Panel | QFrame.Raised)
        palette = QPalette()
        palette.setColor(QPalette.Base,QColor(1,0,0))
        self.label.setPalette(palette)
        self.attributes = NodeAttributeLoader(self.lux,None)
        self.node = None

        frame = QFrame()

        self.vbox = QVBoxLayout()
        self.vbox.addWidget(self.label)
        self.vbox.addWidget(self.attributes)
        self.vbox.addStretch()
        self.vbox.setContentsMargins(0,0,0,0)
        self.vbox.setSpacing(0)

        frame.setLayout(self.vbox)
        self.setWidget(frame)
        
        self.attributes.nodeChanged.connect(self.nodeUpdate)

    def load(self):
        print("load()")
        self.node = self.lux.sg.getNode(name)
        self.attributes.load(self.node)

    def setEditor(self,name):
        print("setEditor()")
        self.label.setText(name)
        self.node = self.lux.sg.getNode(name)
        self.attributes.load(self.node)

    def nodeUpdate(self):
        self.node = self.attributes.node
        self.lux.sg.lux.setProperties(self.node.getPropertyString())
        self.nodeChanged.emit()
 
# ADD DIALOG
class AddNodeDialog(QDialog):
    nodeAdded = pyqtSignal(['QString','QString','QString'])

    def __init__(self,ntype):
        super().__init__()
        #self.setFixedWidth(400)
        #self.setFixedHeight(400)
        self.setWindowTitle("Add Node")
        self.name = QLineEdit()
        self.vtype = QComboBox()

        self.addBtn = QPushButton("Add")
        self.cancelBtn = QPushButton("Cancel")
        self.ntype = ntype
        
        gbox = QGridLayout()
        gbox.addWidget(QLabel("name:"),0,0)
        gbox.addWidget(QLabel("type:"),1,0)
        gbox.addWidget(self.name,0,1)
        gbox.addWidget(self.vtype,1,1)
        vbox = QVBoxLayout()
        vbox.addLayout(gbox)
        vbox.addWidget(self.addBtn)
        vbox.addWidget(self.cancelBtn)
        self.setLayout(vbox)

        self.setType(self.ntype)
        self.addBtn.clicked.connect(self.setNode)
        self.cancelBtn.clicked.connect(self.reject)
        self.hide()

    def setType(self,ntype):
        self.ntype = ntype
        self.vtype.clear() 
        if self.ntype == 'objects':
            self.vtype.addItem('ply')
            self.vtype.addItem('stl')
        if self.ntype == 'materials':
            self.vtype.addItem('matte')
            self.vtype.addItem('glossy2')
            self.vtype.addItem('glass')
            self.vtype.addItem('metal2')
            self.vtype.addItem('mattetranslucent')
            self.vtype.addItem('mirror')
            self.vtype.addItem('mix')
            self.vtype.addItem('null')
        if self.ntype == 'textures':
            self.vtype.addItem('imagemap')


    def setNode(self):
        self.nodeAdded.emit(self.name.text(),self.ntype,self.vtype.currentText())
        self.hide()


# SCENE LAYOUT DOCK

class SceneLayout(QDockWidget):
    objectSelected = pyqtSignal(['QString'])
    materialSelected = pyqtSignal(['QString'])
    textureSelected = pyqtSignal(['QString'])
    lightSelected = pyqtSignal(['QString'])

    def __init__(self,lux):
        super().__init__()
        self.lux = lux
        self.setWindowTitle("Scene Layout")
        frame = QFrame(self)
        self.tabs = QTabWidget()
        self.objects = QListWidget()
        self.materials = QListWidget()
        self.textures = QListWidget()
        self.lights = QListWidget()
        self.addBtn = QPushButton("+")
        self.removeBtn = QPushButton("-")
        self.renameBtn = QPushButton("rename")

        self.tabs.addTab(self.objects,"objects")
        self.tabs.addTab(self.materials,"materials")
        self.tabs.addTab(self.textures, "textures")
        self.tabs.addTab(self.lights, "lights")
        self.tabs.setTabPosition(QTabWidget.North)

        hbox = QHBoxLayout()
        hbox.addWidget(self.renameBtn)
        hbox.addWidget(self.addBtn)
        hbox.addWidget(self.removeBtn)

        vbox = QVBoxLayout(self) 
        frame.setLayout(vbox)
        vbox.addWidget(self.tabs)
        vbox.addLayout(hbox)

        self.setWidget(frame)

        self.addNodeDialog = AddNodeDialog(self.tabs.tabText(self.tabs.currentIndex()))

        self.objects.itemClicked.connect(self.objectChanged)
        self.materials.itemClicked.connect(self.materialChanged)
        self.textures.itemClicked.connect(self.textureChanged)
        self.lights.itemClicked.connect(self.lightChanged)
        self.renameBtn.clicked.connect(self.rename)
        self.addBtn.clicked.connect(self.add)
        self.removeBtn.clicked.connect(self.remove)
        self.addNodeDialog.nodeAdded.connect(self.addNode)

    def addNode(self,name,ntype,vtype):
        print("%s, %s, %s node to add"%(name,ntype,vtype))
        self.lux.sg.addSceneNode(name,ntype,vtype)
        self.updateTabs()

    def add(self):
        #self.lux.sg.addObject()
        #node = Node(name,ntype)
        #node.addProperty(Property(ntype,name, attribute, luxprop, vtype, vmin, vmax, vdefault, desc=""))
        #if ntype is 'objects':
        #    node.addProperty(Property(node.ntype,'mat_test', 'type', None, 'string', None, None, ["matte"], desc="Test"))
        #    node.addProperty(Property(node.ntype,'mat_test', 'kd', None, 'texture', None, None, [1,0,0], desc="Test"))

        # Open AddDialog
        self.addNodeDialog.setType(self.tabs.tabText(self.tabs.currentIndex()))
        self.addNodeDialog.exec()
        self.updateTabs()

        self.updateTabs() 

    def remove(self):
        pass

    def rename(self):
        pass
 
    def updateTabs(self):
        # Objects
        print("updateTabs")
        self.objects.clear()
        objects = self.lux.sg.getNames('objects')
        materials = self.lux.sg.getNames('materials')


        for o in objects:
            self.objects.addItem(o)

        # Materials
        self.materials.clear()
        for m in materials:
            self.materials.addItem(m)

        # Materials
        self.textures.clear()
        for t in self.lux.sg.getNames('textures'):
            self.textures.addItem(t)

        # Materials
        self.lights.clear()
        for l in self.lux.sg.getNames('lights'):
            self.lights.addItem(l)

    def objectChanged(self,item):
        self.objectSelected.emit(item.text())

    def materialChanged(self,item):
        self.materialSelected.emit(item.text())

    def textureChanged(self,item):
        self.textureSelected.emit(item.text())

    def lightChanged(self,item):
        self.lightSelected.emit(item.text())


# RENDER SETTINGS

class RenderSettings(QDockWidget):
    objectSelected = pyqtSignal(['QString'])

    def __init__(self,lux):
        super().__init__()
        self.lux = lux
        self.setWindowTitle("Render Settings")

        self.props = self.lux.sg.lux.getRenderSettings()

        self.preset = QComboBox()
        self.preset.addItem("custom")
        self.preset.addItem("4:3 low res")
        self.preset.addItem("1:79 low res")
        self.preset.addItem("2.39 low res")
        self.preset.addItem("4:3 med res")
        self.preset.addItem("1:79 med res")
        self.preset.addItem("2.39 med res")
        self.preset.addItem("4:3 hd")
        self.preset.addItem("1:79 hd")
        self.preset.addItem("2.39 hd")
        self.preset.addItem("4:3 4k")
        self.preset.addItem("1:79 4k")
        self.preset.addItem("2.39 4k")

        frame = QFrame()
        self.renderWidth = IntAttribute(self.lux.sg.getRenderProperty('film','width'))
        self.renderHeight = IntAttribute(self.lux.sg.getRenderProperty('film','height'))

        # Engine 
        self.engine = QGroupBox('engine')
        self.engineType = OptionAttribute(self.lux.sg.getRenderProperty('renderengine','type'),['PATHCPU','BIASPATHCPU','BIDIRCPU','PATHOCL','RTPATHOCL','BIASPATHOCL','RTBIASPATHOCL'])
        self.enginevbox = QVBoxLayout()
        self.enginevbox.addWidget(self.engineType)
        self.enginevbox.setContentsMargins(0,0,0,0)
        self.enginevbox.setSpacing(0)
        self.engine.setLayout(self.enginevbox)
 
        # Sampler
        self.sampler = QGroupBox('sampler')
        self.samplerType = OptionAttribute(self.lux.sg.getRenderProperty('sampler','type'),["SOBOL","METROPOLIS","RANDOM"])
        self.samplervbox = QVBoxLayout()
        self.samplervbox.addWidget(self.samplerType)
        self.samplervbox.setContentsMargins(0,0,0,0)
        self.samplervbox.setSpacing(0)
        self.sampler.setLayout(self.samplervbox)
 
        vbox = QVBoxLayout()
        vbox.addWidget(QLabel("Presets"))
        vbox.addWidget(self.preset)
        vbox.addWidget(self.renderWidth)
        vbox.addWidget(self.renderHeight)
        vbox.addWidget(self.engine)
        vbox.addWidget(self.sampler)
        vbox.addStretch()
        vbox.setSpacing(0)

        frame.setLayout(vbox)
        self.setWidget(frame)

        self.renderWidth.valueChanged.connect(self.updateSettings)
        self.renderHeight.valueChanged.connect(self.updateSettings)
        self.engineType.valueChanged.connect(self.updateEngine)
        self.samplerType.valueChanged.connect(self.updateSampler)

        self.updateEngine()
        self.updateSampler()


    def updateEngine(self):
        for i in reversed(range(self.enginevbox.count())):
            self.enginevbox.itemAt(i).widget().setParent(None)
        self.enginevbox.addWidget(self.engineType)
        if self.engineType.getValue() == 'PATHCPU':
            maxdepth = IntAttribute(self.lux.sg.getRenderProperty('path','maxdepth'))
            russianroulettedepth = IntAttribute(self.lux.sg.getRenderProperty('path','russianroulette.depth'))
            russianroulettecap = FloatAttribute(self.lux.sg.getRenderProperty('path','russianroulette.cap'))
            clampingvariancemaxvalue = FloatAttribute(self.lux.sg.getRenderProperty('path','clamping.variance.maxvalue'))
            clampingpdfvalue = FloatAttribute(self.lux.sg.getRenderProperty('path','clamping.pdf.value'))
            fastpixelfilterenable = IntAttribute(self.lux.sg.getRenderProperty('path','fastpixelfilter.enable'))

            maxdepth.valueChanged.connect(self.updateSettings)
            russianroulettedepth.valueChanged.connect(self.updateSettings)
            russianroulettecap.valueChanged.connect(self.updateSettings)
            clampingvariancemaxvalue.valueChanged.connect(self.updateSettings)
            clampingpdfvalue.valueChanged.connect(self.updateSettings)
            fastpixelfilterenable.valueChanged.connect(self.updateSettings)

            self.enginevbox.addWidget(maxdepth)
            self.enginevbox.addWidget(russianroulettedepth)
            self.enginevbox.addWidget(russianroulettecap)
            self.enginevbox.addWidget(clampingvariancemaxvalue)
            self.enginevbox.addWidget(clampingpdfvalue)
            self.enginevbox.addWidget(fastpixelfilterenable)

 
    def updateSampler(self):
        for i in reversed(range(self.samplervbox.count())):
            self.samplervbox.itemAt(i).widget().setParent(None)
        self.samplervbox.addWidget(self.samplerType)
        if self.samplerType.getValue() == 'METROPOLIS':
            largesteprate = FloatAttribute(self.lux.sg.getRenderProperty('sampler.metropolis','largesteprate'))
            maxconsecutivereject = IntAttribute(self.lux.sg.getRenderProperty('sampler.metropolis','maxconsecutivereject'))
            imagemutationrate = FloatAttribute(self.lux.sg.getRenderProperty('sampler.metropolis','largesteprate'))
 
            largesteprate.valueChanged.connect(self.updateSettings)
            maxconsecutivereject.valueChanged.connect(self.updateSettings)
            imagemutationrate.valueChanged.connect(self.updateSettings)

            self.samplervbox.addWidget(largesteprate)
            self.samplervbox.addWidget(maxconsecutivereject)
            self.samplervbox.addWidget(imagemutationrate)
 
        
    def updateSettings(self):
        print("Updating Render Settings")
        self.lux.setRenderSettings()

class TimeEditor(QWidget):
    frameChanged = pyqtSignal(['int'])

    def __init__(self,lux):
        super().__init__()
        self.sframe = QLineEdit()
        self.eframe = QLineEdit()
        self.cframe = QLabel()
        self.slider = QSlider(Qt.Horizontal)

        self.sframe.setFixedWidth(50)
        self.eframe.setFixedWidth(50)

        self.framevalidator = QIntValidator(-10000,10000)
        self.sframe.setValidator(self.framevalidator)
        self.eframe.setValidator(self.framevalidator)
 
        self.sframe.setText('1')
        self.eframe.setText('24')
        self.cframe.setText('1')

        self.cframe.setFont(QFont("Sans",12))
        self.cframe.setAlignment(Qt.AlignCenter)
        self.cframe.setFrameStyle(QFrame.Panel | QFrame.Raised)
 
        vbox = QVBoxLayout(self)
        vbox.addWidget(self.cframe)
        hbox = QHBoxLayout()
        hbox.addWidget(self.sframe)
        hbox.addWidget(self.slider)
        hbox.addWidget(self.eframe)
        vbox.addLayout(hbox) 

        self.slider.setMinimum(int(self.sframe.text()))
        self.slider.setMaximum(int(self.eframe.text()))
        self.slider.valueChanged.connect(self.setCurrentFrame)

    def setCurrentFrame(self,val):
        self.cframe.setText("%d"%val)
        self.frameChanged.emit(val)


# MAIN MENU

# FILE ACTIONS
class FileNewAction(QAction):

    def __init__(self,parent):
        super().__init__("New",parent)
        self.triggered.connect(self.doit)

    def doit(self):
        print("New")

'''
class FileSaveAction(QAction):

    def __init__(self,parent):
        super().__init__("Save",parent)
        self.triggered.connect(self.doit)

    def doit(self):
        print("Save")
'''

class FileExitAction(QAction):

    def __init__(self,parent):
        super().__init__("Exit",parent)
        self.triggered.connect(self.doit)

    def doit(self):
        print("Exit")

 
class ImportMenu(QMenu):

    def __init__(self,lux,parent):
        super().__init__("Import",parent)
        self.addAction(ImportPlyAction(self))

class ExportMenu(QMenu):

    def __init__(self,lux,parent):
        super().__init__("Export",parent)
        self.addAction(ExportRenderAction(lux,self))
        self.addAction(ExportSceneAction(lux,self))


# IMPORT ACTIONS
class ImportPlyAction(QAction):

    def __init__(self,parent):
        super().__init__("Ply",parent)
        self.triggered.connect(self.doit)

    def doit(self):
        print("Ply")


# EXPORT ACTIONS 
class ExportRenderAction(QAction):

    def __init__(self,lux,parent):
        super().__init__("Render",parent)
        self.triggered.connect(self.doit)
        self.lux = lux

    def doit(self):
        filename = QFileDialog.getSaveFileName(None,"Export Render Configuration",".","Config Files (*.cfg)")
        out = self.lux.sg.getRenderSettings()
        file = open(filename[0],'w')
        file.write(out)
        file.close()

class ExportSceneAction(QAction):

    def __init__(self,lux,parent):
        super().__init__("Scene",parent)
        self.triggered.connect(self.doit)
        self.lux = lux

    def doit(self):
        filename = QFileDialog.getSaveFileName(None,"Export Scene File",".","Scene Files (*.scn)")
        out = self.lux.sg.getSceneString()
        file = open(filename[0],'w')
        file.write(out)
        file.close()


class FileMenu(QMenu):

    def __init__(self,lux,name):
        super().__init__(name)
        self.addAction(FileNewAction(self))
        self.addSeparator()
        self.addMenu(ImportMenu(lux,self))
        self.addMenu(ExportMenu(lux,self))
        self.addSeparator()
        self.addAction(FileExitAction(self))
 

class MainMenu(QMenuBar):

    def __init__(self,lux):
        super().__init__()
        self.fileMenu = FileMenu(lux,"File")

        self.addMenu(self.fileMenu)

 
# MAIN WINDOW

class RenderingAction(QAction):

    def __init__(self,lux,parent):
        super().__init__('Paused',parent)
        self.lux = lux
        self.triggered.connect(self.doit)
        self.lux.sg.stop()

    def doit(self):
        if self.text() == 'Paused':
            self.setText('Rendering')
            #self.lux.sg.paused(0)
        else:
            #self.lux.sg.paused(1)
            self.setText('Paused')

 
class Example(QMainWindow):
    
    def __init__(self):
        super().__init__()
        self.thread = QThread()
        self.lux = LuxWidget(1200,800)        

        # Create UI widgets 
        self.sceneLayout = SceneLayout(self.lux)
        self.attributeEditor = NodeEditor(self.lux)
        self.renderSettings = RenderSettings(self.lux)
        self.toolbar = self.addToolBar("tools")
        self.renderAct = RenderingAction(self.lux,self) 
        self.status = QStatusBar()
        frame = QFrame()
        luxframe = QFrame()
        luxframe.setFrameStyle(QFrame.StyledPanel | QFrame.Plain)
        luxvbox = QHBoxLayout()
        timeeditor = TimeEditor(self.lux)

        self.toolbar.addAction(self.renderAct)
        luxframe.setLayout(luxvbox)
        luxframe.setAutoFillBackground(1)
        palette = QPalette()
        palette.setColor(QPalette.Background,QColor(0,0,0))
        luxframe.setPalette(palette)

        luxvbox.addWidget(self.lux,Qt.AlignCenter)

        self.menu = MainMenu(self.lux)
        self.setMenuBar(self.menu)

        # Layout UI widgets
        vbox = QVBoxLayout()
        vbox.addWidget(luxframe,Qt.AlignCenter)
        vbox.addWidget(timeeditor)
        self.setCentralWidget(frame)
        self.addDockWidget(Qt.RightDockWidgetArea, self.sceneLayout);
        self.addDockWidget(Qt.RightDockWidgetArea, self.attributeEditor);
        self.addDockWidget(Qt.LeftDockWidgetArea, self.renderSettings);
        self.setStatusBar(self.status)

        # Setup UI widgets
        self.status.showMessage("Starting...")
        frame.setLayout(vbox)
        self.setWindowTitle('LuxEd')


        # Connections setup
        self.sceneLayout.objectSelected.connect(self.objectSelected)
        self.sceneLayout.materialSelected.connect(self.materialSelected)
        self.sceneLayout.textureSelected.connect(self.textureSelected)
        self.sceneLayout.lightSelected.connect(self.lightSelected)
     
        self.show()

        self.sceneLayout.updateTabs()

        t = QTimer(self)
        t.timeout.connect(self.updateLux)
        t.start(1000)

        # Start the render
        self.lux.startRendering()

        # Create a default material
        matstring = "scene.materials.luxed_default_mat.type = \"matte\"\n"
        matstring += "scene.materials.luxed_default_mat.kd = 1 1 1\n"
        self.lux.sg.lux.setProperties(matstring)

        self.attributeEditor.nodeChanged.connect(self.updateSceneLayout)
 
    def updateLux(self):
        self.lux.sg.write()
        self.lux.repaint()
        self.status.clearMessage()
        self.status.showMessage(("[Elapsed time: %3d/5sec][Samples %4d][Avg. samples/sec %3.2fM on %.1fK tris]" % (
                self.lux.getTime(),
                self.lux.getPass(),
                (self.lux.getSpp() / 1000000.0),
                (self.lux.getTriCount() / 1000.0))))


    def keyPressEvent(self, e):
        if e.key() == Qt.Key_Escape:
            self.lux.stopRendering()
            self.close()

    def objectSelected(self,item):
        print("Object Selected %s"%item)
        self.attributeEditor.setEditor(item)


    def materialSelected(self,item):
        print("Material Selected %s"%item)
        self.attributeEditor.setEditor(item)

    def textureSelected(self,item):
        print("Texture Selected %s"%item)
        self.attributeEditor.setEditor("texture",self.lux.core().getTextureType(item),item)

    def lightSelected(self,item):
        print("Light Selected %s"%item)
        #self.attributeEditor.setEditor("object","",item)

    def updateSceneLayout(self):
        self.sceneLayout.updateTabs()
 

if __name__ == '__main__':
    
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
